/*
 * Copyright 2001-2018 The OpenSSL Project Authors. All Rights Reserved.
 * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved
 *
 * Licensed under the OpenSSL license (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#define SIZE_T unsigned int
#undef NULL
#define NULL 0

typedef struct bignum_st BIGNUM;
typedef struct bignum_ctx BN_CTX;
typedef struct bn_mont_ctx_st BN_MONT_CTX;

#undef SIXTY_FOUR_BIT_LONG
#define SIXTY_FOUR_BIT_LONG //default

/*
 * 64-bit processor with LP64 ABI
 */
# ifdef SIXTY_FOUR_BIT_LONG
#  define BN_ULONG        unsigned long
#  define BN_BYTES        8
# endif

/*
 * 64-bit processor other than LP64 ABI
 */
# ifdef SIXTY_FOUR_BIT
# undef SIXTY_FOUR_BIT_LONG
#  undef BN_ULONG
#  undef BN_BYTES
#  define BN_ULONG        unsigned long long
#  define BN_BYTES        8
# endif

# ifdef THIRTY_TWO_BIT
# undef SIXTY_FOUR_BIT_LONG
#  undef BN_ULONG
#  undef BN_BYTES
#  define BN_ULONG        unsigned int
#  define BN_BYTES        4
# endif

# define BN_BITS2       (BN_BYTES * 8)
# define BN_BITS        (BN_BITS2 * 2)
# define BN_TBIT        ((BN_ULONG)1 << (BN_BITS2 - 1))


# define BN_num_bytes(a) ((BN_num_bits(a)+7)/8)

int BN_abs_is_word(const BIGNUM *a, const BN_ULONG w);
int BN_is_zero(const BIGNUM *a);
int BN_is_one(const BIGNUM *a);
int BN_is_odd(const BIGNUM *a);

# define BN_one(a)       (BN_set_word((a),1))

void BN_zero_ex(BIGNUM *a);
#  define BN_zero(a)      BN_zero_ex(a)

const BIGNUM *BN_value_one(void);
void BN_CTX_init(BN_CTX *ctx);
void BN_CTX_start(BN_CTX *ctx);
BIGNUM *BN_CTX_get(BN_CTX *ctx);
void BN_CTX_end(BN_CTX *ctx);

int BN_num_bits(const BIGNUM *a);
int BN_num_bits_word(BN_ULONG l);

BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);
void BN_swap(BIGNUM *a, BIGNUM *b);
BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);
int BN_bn2bin(const BIGNUM *a, unsigned char *to);

int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx);
/** BN_set_negative sets sign of a BIGNUM
 * \param  b  pointer to the BIGNUM object
 * \param  n  0 if the BIGNUM b should be positive and a value != 0 otherwise
 */
void BN_set_negative(BIGNUM *b, int n);
/** BN_is_negative returns 1 if the BIGNUM is negative
 * \param  b  pointer to the BIGNUM object
 * \return 1 if a < 0 and 0 otherwise
 */
int BN_is_negative(const BIGNUM *b);

int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
           BN_CTX *ctx);
# define BN_mod(rem,m,d,ctx) BN_div(NULL,(rem),(m),(d),(ctx))
int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
int BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                     const BIGNUM *m);
int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                     const BIGNUM *m);
int BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
               BN_CTX *ctx);
int BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
int BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m);
int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m);

int BN_add_word(BIGNUM *a, BN_ULONG w);
int BN_sub_word(BIGNUM *a, BN_ULONG w);
int BN_set_word(BIGNUM *a, BN_ULONG w);

int BN_cmp(const BIGNUM *a, const BIGNUM *b);
int BN_is_bit_set(const BIGNUM *a, int n);
int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);
int BN_lshift1(BIGNUM *r, const BIGNUM *a);

int BN_mask_bits(BIGNUM *a, int n);

int BN_rshift(BIGNUM *r, const BIGNUM *a, int n);
int BN_rshift1(BIGNUM *r, const BIGNUM *a);

int BN_ucmp(const BIGNUM *a, const BIGNUM *b);
int BN_set_bit(BIGNUM *a, int n);

BIGNUM *BN_mod_inverse(BIGNUM *ret,
                       const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);

int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          BN_MONT_CTX *mont, BN_CTX *ctx);
int BN_to_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,
                     BN_CTX *ctx);
int BN_from_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,
                       BN_CTX *ctx);
int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx);

///////////////////////////////////////////////////////////////////////////////
typedef struct ec_group_st EC_GROUP;
typedef struct ec_point_st EC_POINT;

/********************************************************************/
/*                   EC_GROUP functions                             */
/********************************************************************/

/** Sets the generator and it's order/cofactor of a EC_GROUP object.
 *  \param  group      EC_GROUP object
 *  \param  generator  EC_POINT object with the generator.
 *  \param  order      the order of the group generated by the generator.
 *  \param  cofactor   the index of the sub-group generated by the generator
 *                     in the group of all points on the elliptic curve.
 *  \return 1 on success and 0 if an error occurred
 */
int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,
                           const BIGNUM *order, const BIGNUM *cofactor, BN_CTX *ctx);

/** Returns the generator of a EC_GROUP object.
 *  \param  group  EC_GROUP object
 *  \return the currently used generator (possibly NULL).
 */
const EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group);

/** Creates a EC_GROUP object with a curve specified by a NID
 *  \param  nid  NID of the OID of the curve name
 *  \return newly created EC_GROUP object with specified curve or NULL
 *          if an error occurred
 */
EC_GROUP *EC_GROUP_init_curve(EC_GROUP *group, BN_CTX *ctx);

/********************************************************************/
/*                    EC_POINT functions                            */
/********************************************************************/

/** Copies EC_POINT object
 *  \param  dst  destination EC_POINT object
 *  \param  src  source EC_POINT object
 *  \return 1 on success and 0 if an error occurred
 */
int EC_POINT_copy(EC_POINT *dst, const EC_POINT *src);

/** Gets the affine coordinates of an EC_POINT.
 *  \param  group  underlying EC_GROUP object
 *  \param  p      EC_POINT object
 *  \param  x      BIGNUM for the x-coordinate
 *  \param  y      BIGNUM for the y-coordinate
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occurred
 */
int EC_POINT_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *p,
                                    BIGNUM *x, BIGNUM *y, BN_CTX *ctx);

/********************************************************************/
/*         functions for doing EC_POINT arithmetic                  */
/********************************************************************/

/** Computes r = generator * n + sum_{i=0}^{num-1} p[i] * m[i]
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result
 *  \param  n      BIGNUM with the multiplier for the group generator (optional)
 *  \param  num    number further summands
 *  \param  p      array of size num of EC_POINT objects
 *  \param  m      array of size num of BIGNUM objects
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occurred
 */
int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
                  SIZE_T num, const EC_POINT *p[], const BIGNUM *m[],
                  BN_CTX *ctx);

/** Computes r = generator * n + q * m
 *  \param  group  underlying EC_GROUP object
 *  \param  r      EC_POINT object for the result
 *  \param  n      BIGNUM with the multiplier for the group generator (optional)
 *  \param  q      EC_POINT object with the first factor of the second summand
 *  \param  m      BIGNUM with the second factor of the second summand
 *  \param  ctx    BN_CTX object (optional)
 *  \return 1 on success and 0 if an error occurred
 */
int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);

///////////////////////////////////////////////////////////////////////////////

BIGNUM *bn_wexpand(BIGNUM *a, int words);

void bn_correct_top(BIGNUM *a);

/*
 * Determine the modified width-(w+1) Non-Adjacent Form (wNAF) of 'scalar'.
 * This is an array r[] of values that are either zero or odd with an
 * absolute value less than 2^w satisfying scalar = \sum_j r[j]*2^j where at
 * most one of any w+1 consecutive digits is non-zero with the exception that
 * the most significant digit may be only w-1 zeros away from that next
 * non-zero digit.
 */
signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, SIZE_T *ret_len, signed char* r);

/*
 * Some BIGNUM functions assume most significant limb to be non-zero, which
 * is customarily arranged by bn_correct_top. Output from below functions
 * is not processed with bn_correct_top, and for this reason it may not be
 * returned out of public API. It may only be passed internally into other
 * functions known to support non-minimal or zero-padded BIGNUMs.
 */
int bn_mul_mont_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          BN_MONT_CTX *mont, BN_CTX *ctx);

int bn_from_mont_fixed_top(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,
                           BN_CTX *ctx);
int bn_mod_add_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                         const BIGNUM *m);

int bn_mul_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
int bn_sqr_fixed_top(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx);

#  define BN_MUL_COMBA
#  define BN_SQR_COMBA

/*
 * 64-bit processor with LP64 ABI
 */
# ifdef SIXTY_FOUR_BIT_LONG
#  define BN_ULLONG       unsigned long long
#  define BN_BITS4        32
#  define BN_MASK2        (0xffffffffffffffffL)
#  define BN_MASK2l       (0xffffffffL)
#  define BN_MASK2h       (0xffffffff00000000L)
#  define BN_MASK2h1      (0xffffffff80000000L)
#  define BN_DEC_CONV     (10000000000000000000UL)
#  define BN_DEC_NUM      19
#  define BN_DEC_FMT1     "%lu"
#  define BN_DEC_FMT2     "%019lu"
# endif

/*
 * 64-bit processor other than LP64 ABI
 */
# ifdef SIXTY_FOUR_BIT
#  undef BN_ULLONG
#  define BN_BITS4        32
#  define BN_MASK2        (0xffffffffffffffffLL)
#  define BN_MASK2l       (0xffffffffL)
#  define BN_MASK2h       (0xffffffff00000000LL)
#  define BN_MASK2h1      (0xffffffff80000000LL)
#  define BN_DEC_CONV     (10000000000000000000ULL)
#  define BN_DEC_NUM      19
#  define BN_DEC_FMT1     "%llu"
#  define BN_DEC_FMT2     "%019llu"
# endif

# ifdef THIRTY_TWO_BIT
#  define BN_BITS4        16
#  define BN_MASK2        (0xffffffffL)
#  define BN_MASK2l       (0xffff)
#  define BN_MASK2h1      (0xffff8000L)
#  define BN_MASK2h       (0xffff0000L)
#  define BN_DEC_CONV     (1000000000L)
#  define BN_DEC_NUM      9
#  define BN_DEC_FMT1     "%u"
#  define BN_DEC_FMT2     "%09u"
# endif

BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num,
                          BN_ULONG w);
BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w);
void bn_sqr_words(BN_ULONG *rp, const BN_ULONG *ap, int num);
BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
BN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
                      int num);
BN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
                      int num);

struct bignum_st {
    BN_ULONG dd[8*12/BN_BYTES];     /* bn_correct_top debug, max use is 12 */
    BN_ULONG *d;                /* Pointer to an array of 'BN_BITS2' bit
                                 * chunks. */
    int top;                    /* Index of last used d +1. */
    /* The next are internal book keeping for bn_expand. */
    int dmax;                   /* Size of the d array. */
    int neg;                    /* one if the number is negative */
};

/* Used for montgomery multiplication */
struct bn_mont_ctx_st {
    int ri;                     /* number of bits in R */
    BIGNUM RR;                  /* used to convert to montgomery form,
                                   possibly zero-padded */
    BIGNUM N;                   /* The modulus */
    BIGNUM Ni;                  /* R*(1/R mod N) - N*Ni = 1 (Ni is only
                                 * stored for bignum algorithm) */
    BN_ULONG n0[2];             /* least significant word(s) of Ni; (type
                                 * changed with 0.9.9, was "BN_ULONG n0;"
                                 * before) */
};

/* How many bignums are in each "pool item"; */
#define BN_CTX_POOL_SIZE        11 //orig 16, ok 13, debug at BN_POOL_get
/* The stack frame info is resizing, set a first-time expansion size; */
#define BN_CTX_START_FRAMES     4 //orig 32, ok 4

/***********/
/* BN_POOL */
/***********/
/* A linked-list of bignums grouped in bundles */
typedef struct bignum_pool {
    /* Linked-list admin */
    BIGNUM vals[BN_CTX_POOL_SIZE];
    /* Stack depth and allocation size */
    unsigned used, size;
} BN_POOL;

/************/
/* BN_STACK */
/************/

/* A wrapper to manage the "stack frames" */
typedef struct bignum_ctx_stack {
    /* Array of indexes into the bignum stack */
    unsigned int indexes[BN_CTX_START_FRAMES];
    /* Number of stack frames, and the size of the allocated array */
    unsigned int depth, size;
} BN_STACK;

/**********/
/* BN_CTX */
/**********/

/* The opaque BN_CTX type */
struct bignum_ctx {
    /* The bignum bundles */
    BN_POOL pool;
    /* The "stack frames", if you will */
    BN_STACK stack;
    /* The number of bignums currently assigned */
    unsigned int used;
    /* Depth of stack overflow */
    int err_stack;
    /* Block "gets" until an "end" (compatibility behaviour) */
    int too_many;
};


#  define LBITS(a)        ((a)&BN_MASK2l)
#  define HBITS(a)        (((a)>>BN_BITS4)&BN_MASK2l)
#  define L2HBITS(a)      (((a)<<BN_BITS4)&BN_MASK2)

#  define LLBITS(a)       ((a)&BN_MASKl)
#  define LHBITS(a)       (((a)>>BN_BITS2)&BN_MASKl)
#  define LL2HBITS(a)     ((BN_ULLONG)((a)&BN_MASKl)<<BN_BITS2)

#  define mul64(l,h,bl,bh) \
        { \
        BN_ULONG m,m1,lt,ht; \
 \
        lt=l; \
        ht=h; \
        m =(bh)*(lt); \
        lt=(bl)*(lt); \
        m1=(bl)*(ht); \
        ht =(bh)*(ht); \
        m=(m+m1)&BN_MASK2; if (m < m1) ht+=L2HBITS((BN_ULONG)1); \
        ht+=HBITS(m); \
        m1=L2HBITS(m); \
        lt=(lt+m1)&BN_MASK2; if (lt < m1) ht++; \
        (l)=lt; \
        (h)=ht; \
        }

#  define sqr64(lo,ho,in) \
        { \
        BN_ULONG l,h,m; \
 \
        h=(in); \
        l=LBITS(h); \
        h=HBITS(h); \
        m =(l)*(h); \
        l*=l; \
        h*=h; \
        h+=(m&BN_MASK2h1)>>(BN_BITS4-1); \
        m =(m&BN_MASK2l)<<(BN_BITS4+1); \
        l=(l+m)&BN_MASK2; if (l < m) h++; \
        (lo)=l; \
        (ho)=h; \
        }

#  define mul_add(r,a,bl,bh,c) { \
        BN_ULONG l,h; \
 \
        h= (a); \
        l=LBITS(h); \
        h=HBITS(h); \
        mul64(l,h,(bl),(bh)); \
 \
        /* non-multiply part */ \
        l=(l+(c))&BN_MASK2; if (l < (c)) h++; \
        (c)=(r); \
        l=(l+(c))&BN_MASK2; if (l < (c)) h++; \
        (c)=h&BN_MASK2; \
        (r)=l; \
        }

#  define mul(r,a,bl,bh,c) { \
        BN_ULONG l,h; \
 \
        h= (a); \
        l=LBITS(h); \
        h=HBITS(h); \
        mul64(l,h,(bl),(bh)); \
 \
        /* non-multiply part */ \
        l+=(c); if ((l&BN_MASK2) < (c)) h++; \
        (c)=h&BN_MASK2; \
        (r)=l&BN_MASK2; \
        }

void BN_MONT_CTX_init(BN_MONT_CTX *ctx);

void bn_init(BIGNUM *a);
void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb);
void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
void bn_sqr_normal(BN_ULONG *r, const BN_ULONG *a, int n, BN_ULONG *tmp);
void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a);
void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a);

int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
                const BN_ULONG *np, const BN_ULONG *n0, int num);

BIGNUM *int_bn_mod_inverse(BIGNUM *in,
                           const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx,
                           int *noinv);

static inline BIGNUM *bn_expand(BIGNUM *a, int bits)
{
    if (((bits+BN_BITS2-1)/BN_BITS2) <= (a)->dmax)
        return a;

    return bn_wexpand((a),(bits+BN_BITS2-1)/BN_BITS2);
}

///////////////////////////////////////////////////////////////////////////////
const BIGNUM *BN_value_one(void)
{
    static const BN_ULONG data_one = 1L;
    static const BIGNUM const_one =
        { .d=(BN_ULONG *)&data_one, .top=1, .dmax=1, .neg=0 };

    return &const_one;
}

int BN_num_bits_word(BN_ULONG l)
{
    BN_ULONG x, mask;
    int bits = (l != 0);

#if BN_BITS2 > 32
    x = l >> 32;
    mask = (0 - x) & BN_MASK2;
    mask = (0 - (mask >> (BN_BITS2 - 1)));
    bits += 32 & mask;
    l ^= (x ^ l) & mask;
#endif

    x = l >> 16;
    mask = (0 - x) & BN_MASK2;
    mask = (0 - (mask >> (BN_BITS2 - 1)));
    bits += 16 & mask;
    l ^= (x ^ l) & mask;

    x = l >> 8;
    mask = (0 - x) & BN_MASK2;
    mask = (0 - (mask >> (BN_BITS2 - 1)));
    bits += 8 & mask;
    l ^= (x ^ l) & mask;

    x = l >> 4;
    mask = (0 - x) & BN_MASK2;
    mask = (0 - (mask >> (BN_BITS2 - 1)));
    bits += 4 & mask;
    l ^= (x ^ l) & mask;

    x = l >> 2;
    mask = (0 - x) & BN_MASK2;
    mask = (0 - (mask >> (BN_BITS2 - 1)));
    bits += 2 & mask;
    l ^= (x ^ l) & mask;

    x = l >> 1;
    mask = (0 - x) & BN_MASK2;
    mask = (0 - (mask >> (BN_BITS2 - 1)));
    bits += 1 & mask;

    return bits;
}

int BN_num_bits(const BIGNUM *a)
{
    int i = a->top - 1;

    if (BN_is_zero(a))
        return 0;
    return ((i * BN_BITS2) + BN_num_bits_word(a->d[i]));
}

void bn_init(BIGNUM *a)
{
    /* Set up for static allocation */
    a->d = a->dd;  /* 'd' points to the statically allocated 'dd' */
    a->dmax = sizeof(a->dd) / sizeof(BN_ULONG);  /* Set maximum size */
}

BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)
{
    int i;
    if (a == b)
        return a;
    if (bn_wexpand(a, b->top) == NULL)
        return NULL;
    for (i = 0; i < b->top; i++)
        a->d[i] = b->d[i];

    a->neg = b->neg;
    a->top = b->top;
    return a;
}

int BN_set_word(BIGNUM *a, BN_ULONG w)
{
    if (bn_expand(a, (int)sizeof(BN_ULONG) * 8) == NULL)
        return 0;
    a->neg = 0;
    a->d[0] = w;
    a->top = (w ? 1 : 0);
    return 1;
}

BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)
{
    unsigned int i, m;
    unsigned int n;
    BN_ULONG l;

    /* Skip leading zero's. */
    for ( ; len > 0 && *s == 0; s++, len--)
        continue;
    n = len;
    if (n == 0) {
        ret->top = 0;
        return ret;
    }
    i = ((n - 1) / BN_BYTES) + 1;
    m = ((n - 1) % (BN_BYTES));
    if (bn_wexpand(ret, (int)i) == NULL) {
        return NULL;
    }
    ret->top = i;
    ret->neg = 0;
    l = 0;
    while (n--) {
        l = (l << 8L) | *(s++);
        if (m-- == 0) {
            ret->d[--i] = l;
            l = 0;
            m = BN_BYTES - 1;
        }
    }
    /*
     * need to call this due to clear byte at top if avoiding having the top
     * bit set (-ve number)
     */
    bn_correct_top(ret);
    return ret;
}

/* ignore negative */
static int bn2binpad(const BIGNUM *a, unsigned char *to, int tolen)
{
    int n;
    SIZE_T i, lasti, j, atop, mask;
    BN_ULONG l;

    /*
     * In case |a| is fixed-top, BN_num_bytes can return bogus length,
     * but it's assumed that fixed-top inputs ought to be "nominated"
     * even for padded output, so it works out...
     */
    n = BN_num_bytes(a);
    if (tolen == -1) {
        tolen = n;
    } else if (tolen < n) {     /* uncommon/unlike case */
        BIGNUM temp = *a;

        bn_correct_top(&temp);
        n = BN_num_bytes(&temp);
        if (tolen < n)
            return -1;
    }

    /* Swipe through whole available data and don't give away padded zero. */
    atop = a->dmax * BN_BYTES;
    if (atop == 0) {
        return tolen;
    }

    lasti = atop - 1;
    atop = a->top * BN_BYTES;
    for (i = 0, j = 0, to += tolen; j < (SIZE_T)tolen; j++) {
        l = a->d[i / BN_BYTES];
        mask = 0 - ((j - atop) >> (8 * sizeof(i) - 1));
        *--to = (unsigned char)(l >> (8 * (i % BN_BYTES)) & mask);
        i += (i - lasti) >> (8 * sizeof(i) - 1); /* stay on last limb */
    }

    return tolen;
}

int BN_bn2bin(const BIGNUM *a, unsigned char *to)
{
    return bn2binpad(a, to, -1);
}

int BN_ucmp(const BIGNUM *a, const BIGNUM *b)
{
    int i;
    BN_ULONG t1, t2, *ap, *bp;


    i = a->top - b->top;
    if (i != 0)
        return i;
    ap = a->d;
    bp = b->d;
    for (i = a->top - 1; i >= 0; i--) {
        t1 = ap[i];
        t2 = bp[i];
        if (t1 != t2)
            return ((t1 > t2) ? 1 : -1);
    }
    return 0;
}

int BN_cmp(const BIGNUM *a, const BIGNUM *b)
{
    int i;
    int gt, lt;
    BN_ULONG t1, t2;

    if ((a == NULL) || (b == NULL)) {
        if (a != NULL)
            return -1;
        else if (b != NULL)
            return 1;
        else
            return 0;
    }


    if (a->neg != b->neg) {
        if (a->neg)
            return -1;
        else
            return 1;
    }
    if (a->neg == 0) {
        gt = 1;
        lt = -1;
    } else {
        gt = -1;
        lt = 1;
    }

    if (a->top > b->top)
        return gt;
    if (a->top < b->top)
        return lt;
    for (i = a->top - 1; i >= 0; i--) {
        t1 = a->d[i];
        t2 = b->d[i];
        if (t1 > t2)
            return gt;
        if (t1 < t2)
            return lt;
    }
    return 0;
}

int BN_set_bit(BIGNUM *a, int n)
{
    int i, j, k;

    if (n < 0)
        return 0;

    i = n / BN_BITS2;
    j = n % BN_BITS2;
    if (a->top <= i) {
        if (bn_wexpand(a, i + 1) == NULL)
            return 0;
        for (k = a->top; k < i + 1; k++)
            a->d[k] = 0;
        a->top = i + 1;
    }

    a->d[i] |= (((BN_ULONG)1) << j);
    return 1;
}

int BN_is_bit_set(const BIGNUM *a, int n)
{
    int i, j;

    if (n < 0)
        return 0;
    i = n / BN_BITS2;
    j = n % BN_BITS2;
    if (a->top <= i)
        return 0;
    return (int)(((a->d[i]) >> j) & ((BN_ULONG)1));
}

int BN_mask_bits(BIGNUM *a, int n)
{
    int b, w;

    if (n < 0)
        return 0;

    w = n / BN_BITS2;
    b = n % BN_BITS2;
    if (w >= a->top)
        return 0;
    if (b == 0)
        a->top = w;
    else {
        a->top = w + 1;
        a->d[w] &= ~(BN_MASK2 << b);
    }
    bn_correct_top(a);
    return 1;
}

void BN_set_negative(BIGNUM *a, int b)
{
    if (b && !BN_is_zero(a))
        a->neg = 1;
    else
        a->neg = 0;
}

void BN_zero_ex(BIGNUM *a)
{
    a->neg = 0;
    a->top = 0;
}

int BN_abs_is_word(const BIGNUM *a, const BN_ULONG w)
{
    return ((a->top == 1) && (a->d[0] == w)) || ((w == 0) && (a->top == 0));
}

int BN_is_zero(const BIGNUM *a)
{
    return a->top == 0;
}

int BN_is_one(const BIGNUM *a)
{
    return BN_abs_is_word(a, 1) && !a->neg;
}

int BN_is_odd(const BIGNUM *a)
{
    return (a->top > 0) && (a->d[0] & 1);
}

int BN_is_negative(const BIGNUM *a)
{
    return (a->neg != 0);
}

int BN_to_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,
                     BN_CTX *ctx)
{
    return BN_mod_mul_montgomery(r, a, &(mont->RR), mont, ctx);
}

BIGNUM *bn_wexpand(BIGNUM *a, int words)
{
    a->d = a->dd;
    a->dmax = words;
    return a;
}

///////////////////////////////////////////////////////////////////////////////

int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
    int ret = bn_mul_fixed_top(r, a, b, ctx);

    bn_correct_top(r);

    return ret;
}

int bn_mul_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
    int ret = 0;
    int top, al, bl;
    BIGNUM *rr;
#if defined(BN_MUL_COMBA)
    int i;
#endif

    al = a->top;
    bl = b->top;

    if ((al == 0) || (bl == 0)) {
        BN_zero(r);
        return 1;
    }
    top = al + bl;

    BN_CTX_start(ctx);
    if ((r == a) || (r == b)) {
        if ((rr = BN_CTX_get(ctx)) == NULL)
            goto err;
    } else
        rr = r;

#if defined(BN_MUL_COMBA)
    i = al - bl;
#endif
#ifdef BN_MUL_COMBA
    if (i == 0) {
# if 0
        if (al == 4) {
            if (bn_wexpand(rr, 8) == NULL)
                goto err;
            rr->top = 8;
            bn_mul_comba4(rr->d, a->d, b->d);
            goto end;
        }
# endif
        if (al == 8) {
            if (bn_wexpand(rr, 16) == NULL)
                goto err;
            rr->top = 16;
            bn_mul_comba8(rr->d, a->d, b->d);
            goto end;
        }
    }
#endif                          /* BN_MUL_COMBA */
    if (bn_wexpand(rr, top) == NULL)
        goto err;
    rr->top = top;
    bn_mul_normal(rr->d, a->d, al, b->d, bl);

#if defined(BN_MUL_COMBA)
 end:
#endif
    rr->neg = a->neg ^ b->neg;
    if (r != rr && BN_copy(r, rr) == NULL)
        goto err;

    ret = 1;
 err:
    BN_CTX_end(ctx);
    return ret;
}

void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)
{
    BN_ULONG *rr;

    if (na < nb) {
        int itmp;
        BN_ULONG *ltmp;

        itmp = na;
        na = nb;
        nb = itmp;
        ltmp = a;
        a = b;
        b = ltmp;

    }
    rr = &(r[na]);
    if (nb <= 0) {
        (void)bn_mul_words(r, a, na, 0);
        return;
    } else
        rr[0] = bn_mul_words(r, a, na, b[0]);

    for (;;) {
        if (--nb <= 0)
            return;
        rr[1] = bn_mul_add_words(&(r[1]), a, na, b[1]);
        if (--nb <= 0)
            return;
        rr[2] = bn_mul_add_words(&(r[2]), a, na, b[2]);
        if (--nb <= 0)
            return;
        rr[3] = bn_mul_add_words(&(r[3]), a, na, b[3]);
        if (--nb <= 0)
            return;
        rr[4] = bn_mul_add_words(&(r[4]), a, na, b[4]);
        rr += 4;
        r += 4;
        b += 4;
    }
}

///////////////////////////////////////////////////////////////////////////////
static void BN_POOL_init(BN_POOL *);
static BIGNUM *BN_POOL_get(BN_POOL *);
static void BN_POOL_release(BN_POOL *, unsigned int);


static void BN_STACK_init(BN_STACK *);
static int BN_STACK_push(BN_STACK *, unsigned int);
static unsigned int BN_STACK_pop(BN_STACK *);

void BN_CTX_init(BN_CTX *ctx)
{
    BN_CTX *ret = ctx;
    ret->err_stack = ret->too_many = ret->used = 0;
    BN_POOL_init(&ret->pool);
    BN_STACK_init(&ret->stack);
}

void BN_CTX_start(BN_CTX *ctx)
{
    /* If we're already overflowing ... */
    if (ctx->err_stack || ctx->too_many)
        ctx->err_stack++;
    /* (Try to) get a new frame pointer */
    else if (!BN_STACK_push(&ctx->stack, ctx->used)) {
        ctx->err_stack++;
    }
}

void BN_CTX_end(BN_CTX *ctx)
{
    if (ctx->err_stack)
        ctx->err_stack--;
    else {
        unsigned int fp = BN_STACK_pop(&ctx->stack);
        /* Does this stack frame have anything to release? */
        if (fp < ctx->used)
            BN_POOL_release(&ctx->pool, ctx->used - fp);
        ctx->used = fp;
        /* Unjam "too_many" in case "get" had failed */
        ctx->too_many = 0;
    }
    // printf("%s %d\n", __func__, ctx->used);
}

BIGNUM *BN_CTX_get(BN_CTX *ctx)
{
    BIGNUM *ret;
    // printf("%s id %d : %d\n", __func__, ctx->stack.depth, ctx->used);
    if (ctx->err_stack || ctx->too_many)
        return NULL;
    if ((ret = BN_POOL_get(&ctx->pool)) == NULL) {
        /*
         * Setting too_many prevents repeated "get" attempts from cluttering
         * the error stack.
         */
        ctx->too_many = 1;
        return NULL;
    }
    /* OK, make sure the returned bignum is "zero" */
    BN_zero(ret);
    ctx->used++;
    return ret;
}

/************/
/* BN_STACK */
/************/

static void BN_STACK_init(BN_STACK *st)
{
    // printf("BN_STACK %zd\n", sizeof(BN_STACK));
    st->depth = st->size = 0;
}

static int BN_STACK_push(BN_STACK *st, unsigned int idx)
{
    // printf("%s + %d\n", __func__, st->depth);
    if (st->depth == BN_CTX_START_FRAMES) {
        return 0;
    }
    st->indexes[(st->depth)++] = idx;
    return 1;
}

static unsigned int BN_STACK_pop(BN_STACK *st)
{
    return st->indexes[--(st->depth)];
}

/***********/
/* BN_POOL */
/***********/

static void BN_POOL_init(BN_POOL *p)
{
    p->used = p->size = 0;
}

static BIGNUM *BN_POOL_get(BN_POOL *p)
{
    BIGNUM *bn;
    unsigned int offset = p->used % BN_CTX_POOL_SIZE;

    if (p->used == p->size) {
        // No need to allocate new pool items, we are using static memory
        if (p->used >= BN_CTX_POOL_SIZE) {
            // Pool is full, no more bignums can be allocated
            return NULL;
        }
        // Move to the next pool item
        p->size++;
    }

    bn = &p->vals[offset];
    // printf("used %d offset %d\n", p->used, offset);
    p->used++;
    // bn_init(bn);
    return bn;
}

static void BN_POOL_release(BN_POOL *p, unsigned int num)
{
    if (num > p->used) {
        return;
    }

    p->used -= num;
}

///////////////////////////////////////////////////////////////////////////////

void bn_correct_top(BIGNUM *a)
{
    BN_ULONG *ftl;
    int tmp_top = a->top;

    // if(a->top > 5) printf("%s : %p top %d\n", __func__, a, a->top);
    if (tmp_top > 0) {
        for (ftl = &(a->d[tmp_top]); tmp_top > 0; tmp_top--) {
            ftl--;
            if (*ftl != 0)
                break;
        }
        a->top = tmp_top;
    }
    if (a->top == 0)
        a->neg = 0;
}

BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num,
                          BN_ULONG w)
{
    BN_ULONG c = 0;
    BN_ULONG bl, bh;

    if (num <= 0)
        return (BN_ULONG)0;

    bl = LBITS(w);
    bh = HBITS(w);

    while (num & ~3) {
        mul_add(rp[0], ap[0], bl, bh, c);
        mul_add(rp[1], ap[1], bl, bh, c);
        mul_add(rp[2], ap[2], bl, bh, c);
        mul_add(rp[3], ap[3], bl, bh, c);
        ap += 4;
        rp += 4;
        num -= 4;
    }

    while (num) {
        mul_add(rp[0], ap[0], bl, bh, c);
        ap++;
        rp++;
        num--;
    }
    return c;
}

BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
{
    BN_ULONG carry = 0;
    BN_ULONG bl, bh;

    if (num <= 0)
        return (BN_ULONG)0;

    bl = LBITS(w);
    bh = HBITS(w);

    while (num & ~3) {
        mul(rp[0], ap[0], bl, bh, carry);
        mul(rp[1], ap[1], bl, bh, carry);
        mul(rp[2], ap[2], bl, bh, carry);
        mul(rp[3], ap[3], bl, bh, carry);
        ap += 4;
        rp += 4;
        num -= 4;
    }

    while (num) {
        mul(rp[0], ap[0], bl, bh, carry);
        ap++;
        rp++;
        num--;
    }
    return carry;
}

void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)
{
    if (n <= 0)
        return;

    while (n & ~3) {
        sqr64(r[0], r[1], a[0]);
        sqr64(r[2], r[3], a[1]);
        sqr64(r[4], r[5], a[2]);
        sqr64(r[6], r[7], a[3]);
        a += 4;
        r += 8;
        n -= 4;
    }

    while (n) {
        sqr64(r[0], r[1], a[0]);
        a++;
        r += 2;
        n--;
    }
}


/* Divide h,l by d and return the result. */
/* I need to test this some more :-( */
BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)
{
    BN_ULONG dh, dl, q, ret = 0, th, tl, t;
    int i, count = 2;

    if (d == 0)
        return BN_MASK2;

    i = BN_num_bits_word(d);

    i = BN_BITS2 - i;
    if (h >= d)
        h -= d;

    if (i) {
        d <<= i;
        h = (h << i) | (l >> (BN_BITS2 - i));
        l <<= i;
    }
    dh = (d & BN_MASK2h) >> BN_BITS4;
    dl = (d & BN_MASK2l);
    for (;;) {
        if ((h >> BN_BITS4) == dh)
            q = BN_MASK2l;
        else
            q = h / dh;

        th = q * dh;
        tl = dl * q;
        for (;;) {
            t = h - th;
            if ((t & BN_MASK2h) ||
                ((tl) <= ((t << BN_BITS4) | ((l & BN_MASK2h) >> BN_BITS4))))
                break;
            q--;
            th -= dh;
            tl -= dl;
        }
        t = (tl >> BN_BITS4);
        tl = (tl << BN_BITS4) & BN_MASK2h;
        th += t;

        if (l < tl)
            th++;
        l -= tl;
        if (h < th) {
            h += d;
            q--;
        }
        h -= th;

        if (--count == 0)
            break;

        ret = q << BN_BITS4;
        h = ((h << BN_BITS4) | (l >> BN_BITS4)) & BN_MASK2;
        l = (l & BN_MASK2l) << BN_BITS4;
    }
    ret |= q;
    return ret;
}

BN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,
                      int n)
{
    BN_ULONG c, l, t;

    if (n <= 0)
        return (BN_ULONG)0;

    c = 0;

    while (n & ~3) {
        t = a[0];
        t = (t + c) & BN_MASK2;
        c = (t < c);
        l = (t + b[0]) & BN_MASK2;
        c += (l < t);
        r[0] = l;
        t = a[1];
        t = (t + c) & BN_MASK2;
        c = (t < c);
        l = (t + b[1]) & BN_MASK2;
        c += (l < t);
        r[1] = l;
        t = a[2];
        t = (t + c) & BN_MASK2;
        c = (t < c);
        l = (t + b[2]) & BN_MASK2;
        c += (l < t);
        r[2] = l;
        t = a[3];
        t = (t + c) & BN_MASK2;
        c = (t < c);
        l = (t + b[3]) & BN_MASK2;
        c += (l < t);
        r[3] = l;
        a += 4;
        b += 4;
        r += 4;
        n -= 4;
    }

    while (n) {
        t = a[0];
        t = (t + c) & BN_MASK2;
        c = (t < c);
        l = (t + b[0]) & BN_MASK2;
        c += (l < t);
        r[0] = l;
        a++;
        b++;
        r++;
        n--;
    }
    return (BN_ULONG)c;
}


BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,
                      int n)
{
    BN_ULONG t1, t2;
    int c = 0;

    if (n <= 0)
        return (BN_ULONG)0;

    while (n & ~3) {
        t1 = a[0];
        t2 = b[0];
        r[0] = (t1 - t2 - c) & BN_MASK2;
        if (t1 != t2)
            c = (t1 < t2);
        t1 = a[1];
        t2 = b[1];
        r[1] = (t1 - t2 - c) & BN_MASK2;
        if (t1 != t2)
            c = (t1 < t2);
        t1 = a[2];
        t2 = b[2];
        r[2] = (t1 - t2 - c) & BN_MASK2;
        if (t1 != t2)
            c = (t1 < t2);
        t1 = a[3];
        t2 = b[3];
        r[3] = (t1 - t2 - c) & BN_MASK2;
        if (t1 != t2)
            c = (t1 < t2);
        a += 4;
        b += 4;
        r += 4;
        n -= 4;
    }

    while (n) {
        t1 = a[0];
        t2 = b[0];
        r[0] = (t1 - t2 - c) & BN_MASK2;
        if (t1 != t2)
            c = (t1 < t2);
        a++;
        b++;
        r++;
        n--;
    }
    return c;
}

/*
 * Keep in mind that additions to hi can not overflow, because
 * the high word of a multiplication result cannot be all-ones.
 */
#  define mul_add_c(a,b,c0,c1,c2)       do {    \
        BN_ULONG lo = LBITS(a), hi = HBITS(a);  \
        BN_ULONG bl = LBITS(b), bh = HBITS(b);  \
        mul64(lo,hi,bl,bh);                     \
        c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++; \
        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \
        } while(0)

#  define mul_add_c2(a,b,c0,c1,c2)      do {    \
        BN_ULONG tt;                            \
        BN_ULONG lo = LBITS(a), hi = HBITS(a);  \
        BN_ULONG bl = LBITS(b), bh = HBITS(b);  \
        mul64(lo,hi,bl,bh);                     \
        tt = hi;                                \
        c0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++; \
        c1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++; \
        c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++; \
        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \
        } while(0)

#  define sqr_add_c(a,i,c0,c1,c2)       do {    \
        BN_ULONG lo, hi;                        \
        sqr64(lo,hi,(a)[i]);                    \
        c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++; \
        c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++; \
        } while(0)

#  define sqr_add_c2(a,i,j,c0,c1,c2) \
        mul_add_c2((a)[i],(a)[j],c0,c1,c2)

void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
{
    BN_ULONG c1, c2, c3;

    c1 = 0;
    c2 = 0;
    c3 = 0;
    mul_add_c(a[0], b[0], c1, c2, c3);
    r[0] = c1;
    c1 = 0;
    mul_add_c(a[0], b[1], c2, c3, c1);
    mul_add_c(a[1], b[0], c2, c3, c1);
    r[1] = c2;
    c2 = 0;
    mul_add_c(a[2], b[0], c3, c1, c2);
    mul_add_c(a[1], b[1], c3, c1, c2);
    mul_add_c(a[0], b[2], c3, c1, c2);
    r[2] = c3;
    c3 = 0;
    mul_add_c(a[0], b[3], c1, c2, c3);
    mul_add_c(a[1], b[2], c1, c2, c3);
    mul_add_c(a[2], b[1], c1, c2, c3);
    mul_add_c(a[3], b[0], c1, c2, c3);
    r[3] = c1;
    c1 = 0;
    mul_add_c(a[4], b[0], c2, c3, c1);
    mul_add_c(a[3], b[1], c2, c3, c1);
    mul_add_c(a[2], b[2], c2, c3, c1);
    mul_add_c(a[1], b[3], c2, c3, c1);
    mul_add_c(a[0], b[4], c2, c3, c1);
    r[4] = c2;
    c2 = 0;
    mul_add_c(a[0], b[5], c3, c1, c2);
    mul_add_c(a[1], b[4], c3, c1, c2);
    mul_add_c(a[2], b[3], c3, c1, c2);
    mul_add_c(a[3], b[2], c3, c1, c2);
    mul_add_c(a[4], b[1], c3, c1, c2);
    mul_add_c(a[5], b[0], c3, c1, c2);
    r[5] = c3;
    c3 = 0;
    mul_add_c(a[6], b[0], c1, c2, c3);
    mul_add_c(a[5], b[1], c1, c2, c3);
    mul_add_c(a[4], b[2], c1, c2, c3);
    mul_add_c(a[3], b[3], c1, c2, c3);
    mul_add_c(a[2], b[4], c1, c2, c3);
    mul_add_c(a[1], b[5], c1, c2, c3);
    mul_add_c(a[0], b[6], c1, c2, c3);
    r[6] = c1;
    c1 = 0;
    mul_add_c(a[0], b[7], c2, c3, c1);
    mul_add_c(a[1], b[6], c2, c3, c1);
    mul_add_c(a[2], b[5], c2, c3, c1);
    mul_add_c(a[3], b[4], c2, c3, c1);
    mul_add_c(a[4], b[3], c2, c3, c1);
    mul_add_c(a[5], b[2], c2, c3, c1);
    mul_add_c(a[6], b[1], c2, c3, c1);
    mul_add_c(a[7], b[0], c2, c3, c1);
    r[7] = c2;
    c2 = 0;
    mul_add_c(a[7], b[1], c3, c1, c2);
    mul_add_c(a[6], b[2], c3, c1, c2);
    mul_add_c(a[5], b[3], c3, c1, c2);
    mul_add_c(a[4], b[4], c3, c1, c2);
    mul_add_c(a[3], b[5], c3, c1, c2);
    mul_add_c(a[2], b[6], c3, c1, c2);
    mul_add_c(a[1], b[7], c3, c1, c2);
    r[8] = c3;
    c3 = 0;
    mul_add_c(a[2], b[7], c1, c2, c3);
    mul_add_c(a[3], b[6], c1, c2, c3);
    mul_add_c(a[4], b[5], c1, c2, c3);
    mul_add_c(a[5], b[4], c1, c2, c3);
    mul_add_c(a[6], b[3], c1, c2, c3);
    mul_add_c(a[7], b[2], c1, c2, c3);
    r[9] = c1;
    c1 = 0;
    mul_add_c(a[7], b[3], c2, c3, c1);
    mul_add_c(a[6], b[4], c2, c3, c1);
    mul_add_c(a[5], b[5], c2, c3, c1);
    mul_add_c(a[4], b[6], c2, c3, c1);
    mul_add_c(a[3], b[7], c2, c3, c1);
    r[10] = c2;
    c2 = 0;
    mul_add_c(a[4], b[7], c3, c1, c2);
    mul_add_c(a[5], b[6], c3, c1, c2);
    mul_add_c(a[6], b[5], c3, c1, c2);
    mul_add_c(a[7], b[4], c3, c1, c2);
    r[11] = c3;
    c3 = 0;
    mul_add_c(a[7], b[5], c1, c2, c3);
    mul_add_c(a[6], b[6], c1, c2, c3);
    mul_add_c(a[5], b[7], c1, c2, c3);
    r[12] = c1;
    c1 = 0;
    mul_add_c(a[6], b[7], c2, c3, c1);
    mul_add_c(a[7], b[6], c2, c3, c1);
    r[13] = c2;
    c2 = 0;
    mul_add_c(a[7], b[7], c3, c1, c2);
    r[14] = c3;
    r[15] = c1;
}

void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
{
    BN_ULONG c1, c2, c3;

    c1 = 0;
    c2 = 0;
    c3 = 0;
    mul_add_c(a[0], b[0], c1, c2, c3);
    r[0] = c1;
    c1 = 0;
    mul_add_c(a[0], b[1], c2, c3, c1);
    mul_add_c(a[1], b[0], c2, c3, c1);
    r[1] = c2;
    c2 = 0;
    mul_add_c(a[2], b[0], c3, c1, c2);
    mul_add_c(a[1], b[1], c3, c1, c2);
    mul_add_c(a[0], b[2], c3, c1, c2);
    r[2] = c3;
    c3 = 0;
    mul_add_c(a[0], b[3], c1, c2, c3);
    mul_add_c(a[1], b[2], c1, c2, c3);
    mul_add_c(a[2], b[1], c1, c2, c3);
    mul_add_c(a[3], b[0], c1, c2, c3);
    r[3] = c1;
    c1 = 0;
    mul_add_c(a[3], b[1], c2, c3, c1);
    mul_add_c(a[2], b[2], c2, c3, c1);
    mul_add_c(a[1], b[3], c2, c3, c1);
    r[4] = c2;
    c2 = 0;
    mul_add_c(a[2], b[3], c3, c1, c2);
    mul_add_c(a[3], b[2], c3, c1, c2);
    r[5] = c3;
    c3 = 0;
    mul_add_c(a[3], b[3], c1, c2, c3);
    r[6] = c1;
    r[7] = c2;
}

void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
{
    BN_ULONG c1, c2, c3;

    c1 = 0;
    c2 = 0;
    c3 = 0;
    sqr_add_c(a, 0, c1, c2, c3);
    r[0] = c1;
    c1 = 0;
    sqr_add_c2(a, 1, 0, c2, c3, c1);
    r[1] = c2;
    c2 = 0;
    sqr_add_c(a, 1, c3, c1, c2);
    sqr_add_c2(a, 2, 0, c3, c1, c2);
    r[2] = c3;
    c3 = 0;
    sqr_add_c2(a, 3, 0, c1, c2, c3);
    sqr_add_c2(a, 2, 1, c1, c2, c3);
    r[3] = c1;
    c1 = 0;
    sqr_add_c(a, 2, c2, c3, c1);
    sqr_add_c2(a, 3, 1, c2, c3, c1);
    sqr_add_c2(a, 4, 0, c2, c3, c1);
    r[4] = c2;
    c2 = 0;
    sqr_add_c2(a, 5, 0, c3, c1, c2);
    sqr_add_c2(a, 4, 1, c3, c1, c2);
    sqr_add_c2(a, 3, 2, c3, c1, c2);
    r[5] = c3;
    c3 = 0;
    sqr_add_c(a, 3, c1, c2, c3);
    sqr_add_c2(a, 4, 2, c1, c2, c3);
    sqr_add_c2(a, 5, 1, c1, c2, c3);
    sqr_add_c2(a, 6, 0, c1, c2, c3);
    r[6] = c1;
    c1 = 0;
    sqr_add_c2(a, 7, 0, c2, c3, c1);
    sqr_add_c2(a, 6, 1, c2, c3, c1);
    sqr_add_c2(a, 5, 2, c2, c3, c1);
    sqr_add_c2(a, 4, 3, c2, c3, c1);
    r[7] = c2;
    c2 = 0;
    sqr_add_c(a, 4, c3, c1, c2);
    sqr_add_c2(a, 5, 3, c3, c1, c2);
    sqr_add_c2(a, 6, 2, c3, c1, c2);
    sqr_add_c2(a, 7, 1, c3, c1, c2);
    r[8] = c3;
    c3 = 0;
    sqr_add_c2(a, 7, 2, c1, c2, c3);
    sqr_add_c2(a, 6, 3, c1, c2, c3);
    sqr_add_c2(a, 5, 4, c1, c2, c3);
    r[9] = c1;
    c1 = 0;
    sqr_add_c(a, 5, c2, c3, c1);
    sqr_add_c2(a, 6, 4, c2, c3, c1);
    sqr_add_c2(a, 7, 3, c2, c3, c1);
    r[10] = c2;
    c2 = 0;
    sqr_add_c2(a, 7, 4, c3, c1, c2);
    sqr_add_c2(a, 6, 5, c3, c1, c2);
    r[11] = c3;
    c3 = 0;
    sqr_add_c(a, 6, c1, c2, c3);
    sqr_add_c2(a, 7, 5, c1, c2, c3);
    r[12] = c1;
    c1 = 0;
    sqr_add_c2(a, 7, 6, c2, c3, c1);
    r[13] = c2;
    c2 = 0;
    sqr_add_c(a, 7, c3, c1, c2);
    r[14] = c3;
    r[15] = c1;
}

void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
{
    BN_ULONG c1, c2, c3;

    c1 = 0;
    c2 = 0;
    c3 = 0;
    sqr_add_c(a, 0, c1, c2, c3);
    r[0] = c1;
    c1 = 0;
    sqr_add_c2(a, 1, 0, c2, c3, c1);
    r[1] = c2;
    c2 = 0;
    sqr_add_c(a, 1, c3, c1, c2);
    sqr_add_c2(a, 2, 0, c3, c1, c2);
    r[2] = c3;
    c3 = 0;
    sqr_add_c2(a, 3, 0, c1, c2, c3);
    sqr_add_c2(a, 2, 1, c1, c2, c3);
    r[3] = c1;
    c1 = 0;
    sqr_add_c(a, 2, c2, c3, c1);
    sqr_add_c2(a, 3, 1, c2, c3, c1);
    r[4] = c2;
    c2 = 0;
    sqr_add_c2(a, 3, 2, c3, c1, c2);
    r[5] = c3;
    c3 = 0;
    sqr_add_c(a, 3, c1, c2, c3);
    r[6] = c1;
    r[7] = c2;
}

///////////////////////////////////////////////////////////////////////////////
int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
    /*
     * like BN_mod, but returns non-negative remainder (i.e., 0 <= r < |d|
     * always holds)
     */

    if (!(BN_mod(r, m, d, ctx)))
        return 0;
    if (!r->neg)
        return 1;
    /* now   -|d| < r < 0,  so we have to set  r := r + |d| */
    // return (d->neg ? BN_sub : BN_add) (r, r, d);
    if(d->neg)
      return BN_sub(r, r, d);
    else
      return BN_add(r, r, d);
}

/*
 * BN_mod_add variant that may be used if both a and b are non-negative and
 * less than m. The original algorithm was
 *
 *    if (!BN_uadd(r, a, b))
 *       return 0;
 *    if (BN_ucmp(r, m) >= 0)
 *       return BN_usub(r, r, m);
 *
 * which is replaced with addition, subtracting modulus, and conditional
 * move depending on whether or not subtraction borrowed.
 */
int bn_mod_add_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                         const BIGNUM *m)
{
    SIZE_T i, ai, bi, mtop = m->top;
    BN_ULONG storage[1024 / BN_BITS2]; //see struct bignum_st 8*12, 12 is enough
    BN_ULONG carry, temp, mask, *rp, *tp = storage;
    const BN_ULONG *ap, *bp;

    if (bn_wexpand(r, mtop) == NULL)
        return 0;

    if (mtop > sizeof(storage) / sizeof(storage[0]))
        return 0;

    ap = a->d != NULL ? a->d : tp;
    bp = b->d != NULL ? b->d : tp;

    for (i = 0, ai = 0, bi = 0, carry = 0; i < mtop;) {
        mask = (BN_ULONG)0 - ((i - a->top) >> (8 * sizeof(i) - 1));
        temp = ((ap[ai] & mask) + carry) & BN_MASK2;
        carry = (temp < carry);

        mask = (BN_ULONG)0 - ((i - b->top) >> (8 * sizeof(i) - 1));
        tp[i] = ((bp[bi] & mask) + temp) & BN_MASK2;
        carry += (tp[i] < temp);

        i++;
        ai += (i - a->dmax) >> (8 * sizeof(i) - 1);
        bi += (i - b->dmax) >> (8 * sizeof(i) - 1);
    }
    rp = r->d;
    carry -= bn_sub_words(rp, tp, m->d, mtop);
    for (i = 0; i < mtop; i++) {
        rp[i] = (carry & tp[i]) | (~carry & rp[i]);
        ((volatile BN_ULONG *)tp)[i] = 0;
    }
    r->top = mtop;
    r->neg = 0;

    return 1;
}

int BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                     const BIGNUM *m)
{
    int ret = bn_mod_add_fixed_top(r, a, b, m);

    if (ret)
        bn_correct_top(r);

    return ret;
}

/*
 * BN_mod_sub variant that may be used if both a and b are non-negative and
 * less than m
 */
int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                     const BIGNUM *m)
{
    if (!BN_sub(r, a, b))
        return 0;
    if (r->neg)
        return BN_add(r, r, m);
    return 1;
}

/* slow but works */
int BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
               BN_CTX *ctx)
{
    BIGNUM *t;
    int ret = 0;


    BN_CTX_start(ctx);
    if ((t = BN_CTX_get(ctx)) == NULL)
        goto err;
    if (a == b) {
        if (!BN_sqr(t, a, ctx))
            goto err;
    } else {
        if (!BN_mul(t, a, b, ctx))
            goto err;
    }
    if (!BN_nnmod(r, t, m, ctx))
        goto err;
    ret = 1;
 err:
    BN_CTX_end(ctx);
    return ret;
}

int BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)
{
    if (!BN_sqr(r, a, ctx))
        return 0;
    /* r->neg == 0,  thus we don't need BN_nnmod */
    return BN_mod(r, r, m, ctx);
}

/*
 * BN_mod_lshift1 variant that may be used if a is non-negative and less than
 * m
 */
int BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m)
{
    if (!BN_lshift1(r, a))
        return 0;
    if (BN_cmp(r, m) >= 0)
        return BN_sub(r, r, m);
    return 1;
}

/*
 * BN_mod_lshift variant that may be used if a is non-negative and less than
 * m
 */
int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m)
{
    if (r != a) {
        if (BN_copy(r, a) == NULL)
            return 0;
    }

    while (n > 0) {
        int max_shift;

        /* 0 < r < m */
        max_shift = BN_num_bits(m) - BN_num_bits(r);
        /* max_shift >= 0 */

        if (max_shift < 0) {
            return 0;
        }

        if (max_shift > n)
            max_shift = n;

        if (max_shift) {
            if (!BN_lshift(r, r, max_shift))
                return 0;
            n -= max_shift;
        } else {
            if (!BN_lshift1(r, r))
                return 0;
            --n;
        }

        /* BN_num_bits(r) <= BN_num_bits(m) */

        if (BN_cmp(r, m) >= 0) {
            if (!BN_sub(r, r, m))
                return 0;
        }
    }

    return 1;
}

///////////////////////////////////////////////////////////////////////////////
/* signed add of b to a. */
int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
    int ret, r_neg, cmp_res;


    if (a->neg == b->neg) {
        r_neg = a->neg;
        ret = BN_uadd(r, a, b);
    } else {
        cmp_res = BN_ucmp(a, b);
        if (cmp_res > 0) {
            r_neg = a->neg;
            ret = BN_usub(r, a, b);
        } else if (cmp_res < 0) {
            r_neg = b->neg;
            ret = BN_usub(r, b, a);
        } else {
            r_neg = 0;
            BN_zero(r);
            ret = 1;
        }
    }

    r->neg = r_neg;
    return ret;
}

/* signed sub of b from a. */
int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
    int ret, r_neg, cmp_res;


    if (a->neg != b->neg) {
        r_neg = a->neg;
        ret = BN_uadd(r, a, b);
    } else {
        cmp_res = BN_ucmp(a, b);
        if (cmp_res > 0) {
            r_neg = a->neg;
            ret = BN_usub(r, a, b);
        } else if (cmp_res < 0) {
            r_neg = !b->neg;
            ret = BN_usub(r, b, a);
        } else {
            r_neg = 0;
            BN_zero(r);
            ret = 1;
        }
    }

    r->neg = r_neg;
    return ret;
}

/* unsigned add of b to a, r can be equal to a or b. */
int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
    int max, min, dif;
    const BN_ULONG *ap, *bp;
    BN_ULONG *rp, carry, t1, t2;


    if (a->top < b->top) {
        const BIGNUM *tmp;

        tmp = a;
        a = b;
        b = tmp;
    }
    max = a->top;
    min = b->top;
    dif = max - min;

    if (bn_wexpand(r, max + 1) == NULL)
        return 0;

    r->top = max;

    ap = a->d;
    bp = b->d;
    rp = r->d;

    carry = bn_add_words(rp, ap, bp, min);
    rp += min;
    ap += min;

    while (dif) {
        dif--;
        t1 = *(ap++);
        t2 = (t1 + carry) & BN_MASK2;
        *(rp++) = t2;
        carry &= (t2 == 0);
    }
    *rp = carry;
    r->top += carry;

    r->neg = 0;
    return 1;
}

/* unsigned subtraction of b from a, a must be larger than b. */
int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
    int max, min, dif;
    BN_ULONG t1, t2, borrow, *rp;
    const BN_ULONG *ap, *bp;


    max = a->top;
    min = b->top;
    dif = max - min;

    if (dif < 0) {              /* hmm... should not be happening */
        return 0;
    }

    if (bn_wexpand(r, max) == NULL)
        return 0;

    ap = a->d;
    bp = b->d;
    rp = r->d;

    borrow = bn_sub_words(rp, ap, bp, min);
    ap += min;
    rp += min;

    while (dif) {
        dif--;
        t1 = *(ap++);
        t2 = (t1 - borrow) & BN_MASK2;
        *(rp++) = t2;
        borrow &= (t1 == 0);
    }

    while (max && *--rp == 0)
        max--;

    r->top = max;
    r->neg = 0;

    return 1;
}


///////////////////////////////////////////////////////////////////////////////
/* r must not be a */
/*
 * I've just gone over this and it is now %20 faster on x86 - eay - 27 Jun 96
 */
int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
{
    int ret = bn_sqr_fixed_top(r, a, ctx);

    bn_correct_top(r);

    return ret;
}

int bn_sqr_fixed_top(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
{
    int max, al;
    int ret = 0;
    BIGNUM *tmp, *rr;

    al = a->top;
    if (al <= 0) {
        r->top = 0;
        r->neg = 0;
        return 1;
    }

    BN_CTX_start(ctx);
    rr = (a != r) ? r : BN_CTX_get(ctx);
    tmp = BN_CTX_get(ctx);
    if (rr == NULL || tmp == NULL)
        goto err;

    max = 2 * al;               /* Non-zero (from above) */
    if (bn_wexpand(rr, max) == NULL)
        goto err;

    if (al == 4) {
#ifndef BN_SQR_COMBA
        BN_ULONG t[8];
        bn_sqr_normal(rr->d, a->d, 4, t);
#else
        bn_sqr_comba4(rr->d, a->d);
#endif
    } else if (al == 8) {
#ifndef BN_SQR_COMBA
        BN_ULONG t[16];
        bn_sqr_normal(rr->d, a->d, 8, t);
#else
        bn_sqr_comba8(rr->d, a->d);
#endif
    } else {
        if (bn_wexpand(tmp, max) == NULL)
            goto err;
        bn_sqr_normal(rr->d, a->d, al, tmp->d);
    }

    rr->neg = 0;
    rr->top = max;
    if (r != rr && BN_copy(r, rr) == NULL)
        goto err;

    ret = 1;
 err:
    BN_CTX_end(ctx);
    return ret;
}

/* tmp must have 2*n words */
void bn_sqr_normal(BN_ULONG *r, const BN_ULONG *a, int n, BN_ULONG *tmp)
{
    int i, j, max;
    const BN_ULONG *ap;
    BN_ULONG *rp;

    max = n * 2;
    ap = a;
    rp = r;
    rp[0] = rp[max - 1] = 0;
    rp++;
    j = n;

    if (--j > 0) {
        ap++;
        rp[j] = bn_mul_words(rp, ap, j, ap[-1]);
        rp += 2;
    }

    for (i = n - 2; i > 0; i--) {
        j--;
        ap++;
        rp[j] = bn_mul_add_words(rp, ap, j, ap[-1]);
        rp += 2;
    }

    bn_add_words(r, r, r, max);

    /* There will not be a carry */

    bn_sqr_words(tmp, a, n);

    bn_add_words(r, r, tmp, max);
}

///////////////////////////////////////////////////////////////////////////////
int BN_lshift1(BIGNUM *r, const BIGNUM *a)
{
    BN_ULONG *ap, *rp, t, c;
    int i;


    if (r != a) {
        r->neg = a->neg;
        if (bn_wexpand(r, a->top + 1) == NULL)
            return 0;
        r->top = a->top;
    } else {
        if (bn_wexpand(r, a->top + 1) == NULL)
            return 0;
    }
    ap = a->d;
    rp = r->d;
    c = 0;
    for (i = 0; i < a->top; i++) {
        t = *(ap++);
        *(rp++) = ((t << 1) | c) & BN_MASK2;
        c = (t & BN_TBIT) ? 1 : 0;
    }
    if (c) {
        *rp = 1;
        r->top++;
    }
    return 1;
}

int BN_rshift1(BIGNUM *r, const BIGNUM *a)
{
    BN_ULONG *ap, *rp, t, c;
    int i, j;


    if (BN_is_zero(a)) {
        BN_zero(r);
        return 1;
    }
    i = a->top;
    ap = a->d;
    j = i - (ap[i - 1] == 1);
    if (a != r) {
        if (bn_wexpand(r, j) == NULL)
            return 0;
        r->neg = a->neg;
    }
    rp = r->d;
    t = ap[--i];
    c = (t & 1) ? BN_TBIT : 0;
    if (t >>= 1)
        rp[i] = t;
    while (i > 0) {
        t = ap[--i];
        rp[i] = ((t >> 1) & BN_MASK2) | c;
        c = (t & 1) ? BN_TBIT : 0;
    }
    r->top = j;
    if (!r->top)
        r->neg = 0; /* don't allow negative zero */
    return 1;
}

int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
{
    int i, nw, lb, rb;
    BN_ULONG *t, *f;
    BN_ULONG l;


    if (n < 0) {
        return 0;
    }

    nw = n / BN_BITS2;
    if (bn_wexpand(r, a->top + nw + 1) == NULL)
        return 0;
    r->neg = a->neg;
    lb = n % BN_BITS2;
    rb = BN_BITS2 - lb;
    f = a->d;
    t = r->d;
    t[a->top + nw] = 0;
    if (lb == 0)
        for (i = a->top - 1; i >= 0; i--)
            t[nw + i] = f[i];
    else
        for (i = a->top - 1; i >= 0; i--) {
            l = f[i];
            t[nw + i + 1] |= (l >> rb) & BN_MASK2;
            t[nw + i] = (l << lb) & BN_MASK2;
        }
    for(i = 0; i < nw; i++)
      t[i] = 0;
    r->top = a->top + nw + 1;
    bn_correct_top(r);
    return 1;
}

int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)
{
    int i, j, nw, lb, rb;
    BN_ULONG *t, *f;
    BN_ULONG l, tmp;


    if (n < 0) {
        return 0;
    }

    nw = n / BN_BITS2;
    rb = n % BN_BITS2;
    lb = BN_BITS2 - rb;
    if (nw >= a->top || a->top == 0) {
        BN_zero(r);
        return 1;
    }
    i = (BN_num_bits(a) - n + (BN_BITS2 - 1)) / BN_BITS2;
    if (r != a) {
        if (bn_wexpand(r, i) == NULL)
            return 0;
        r->neg = a->neg;
    } else {
        if (n == 0)
            return 1;           /* or the copying loop will go berserk */
    }

    f = &(a->d[nw]);
    t = r->d;
    j = a->top - nw;
    r->top = i;

    if (rb == 0) {
        for (i = j; i != 0; i--)
            *(t++) = *(f++);
    } else {
        l = *(f++);
        for (i = j - 1; i != 0; i--) {
            tmp = (l >> rb) & BN_MASK2;
            l = *(f++);
            *(t++) = (tmp | (l << lb)) & BN_MASK2;
        }
        if ((l = (l >> rb) & BN_MASK2))
            *(t) = l;
    }
    if (!r->top)
        r->neg = 0; /* don't allow negative zero */
    return 1;
}

///////////////////////////////////////////////////////////////////////////////

/*-
 * BN_div computes  dv := num / divisor, rounding towards
 * zero, and sets up rm  such that  dv*divisor + rm = num  holds.
 * Thus:
 *     dv->neg == num->neg ^ divisor->neg  (unless the result is zero)
 *     rm->neg == num->neg                 (unless the remainder is zero)
 * If 'dv' or 'rm' is NULL, the respective value is not returned.
 */
int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
           BN_CTX *ctx)
{
    int norm_shift, i, loop;
    BIGNUM *tmp, wnum, *snum, *sdiv, *res;
    BN_ULONG *resp, *wnump;
    BN_ULONG d0, d1;
    int num_n, div_n;

    if ((num->top > 0 && num->d[num->top - 1] == 0) ||
        (divisor->top > 0 && divisor->d[divisor->top - 1] == 0)) {
        return 0;
    }

    if (BN_is_zero(divisor)) {
        return 0;
    }

    if (BN_ucmp(num, divisor) < 0) {
        if (rm != NULL) {
            if (BN_copy(rm, num) == NULL)
                return 0;
        }
        if (dv != NULL)
            BN_zero(dv);
        return 1;
    }

    BN_CTX_start(ctx);
    res = (dv == NULL) ? BN_CTX_get(ctx) : dv;
    tmp = BN_CTX_get(ctx);
    snum = BN_CTX_get(ctx);
    sdiv = BN_CTX_get(ctx);
    if (sdiv == NULL)
        goto err;

    /* First we normalise the numbers */
    norm_shift = BN_BITS2 - ((BN_num_bits(divisor)) % BN_BITS2);
    if (!(BN_lshift(sdiv, divisor, norm_shift)))
        goto err;
    sdiv->neg = 0;
    norm_shift += BN_BITS2;
    if (!(BN_lshift(snum, num, norm_shift)))
        goto err;
    snum->neg = 0;

    div_n = sdiv->top;
    num_n = snum->top;
    loop = num_n - div_n;
    /*
     * Lets setup a 'window' into snum This is the part that corresponds to
     * the current 'area' being divided
     */
    wnum.neg = 0;
    wnum.d = &(snum->d[loop]);
    wnum.top = div_n;
    /*
     * only needed when BN_ucmp messes up the values between top and max
     */
    wnum.dmax = snum->dmax - loop; /* so we don't step out of bounds */

    /* Get the top 2 words of sdiv */
    /* div_n=sdiv->top; */
    d0 = sdiv->d[div_n - 1];
    d1 = (div_n == 1) ? 0 : sdiv->d[div_n - 2];

    /* pointer to the 'top' of snum */
    wnump = &(snum->d[num_n - 1]);

    /* Setup to 'res' */
    if (!bn_wexpand(res, (loop + 1)))
        goto err;
    res->neg = (num->neg ^ divisor->neg);
    res->top = loop;
    resp = &(res->d[loop - 1]);

    /* space for temp */
    if (!bn_wexpand(tmp, (div_n + 1)))
        goto err;

    {
        if (BN_ucmp(&wnum, sdiv) >= 0) {
            /*
             * If BN_DEBUG_RAND is defined BN_ucmp changes (via bn_pollute)
             * the const bignum arguments => clean the values between top and
             * max again
             */
            bn_sub_words(wnum.d, wnum.d, sdiv->d, div_n);
            *resp = 1;
        } else
            res->top--;
    }

    /* Increase the resp pointer so that we never create an invalid pointer. */
    resp++;

    /*
     * if res->top == 0 then clear the neg value otherwise decrease the resp
     * pointer
     */
    if (res->top == 0)
        res->neg = 0;
    else
        resp--;

    for (i = 0; i < loop - 1; i++, wnump--) {
        BN_ULONG q, l0;
        /*
         * the first part of the loop uses the top two words of snum and sdiv
         * to calculate a BN_ULONG q such that | wnum - sdiv * q | < sdiv
         */

        BN_ULONG n0, n1, rem = 0;

        n0 = wnump[0];
        n1 = wnump[-1];
        if (n0 == d0)
            q = BN_MASK2;
        else {                  /* n0 < d0 */

            BN_ULONG t2l, t2h;

            q = bn_div_words(n0, n1, d0);

            rem = (n1 - q * d0) & BN_MASK2;

            {
                BN_ULONG ql, qh;
                t2l = LBITS(d1);
                t2h = HBITS(d1);
                ql = LBITS(q);
                qh = HBITS(q);
                mul64(t2l, t2h, ql, qh); /* t2=(BN_ULLONG)d1*q; */
            }

            for (;;) {
                if ((t2h < rem) || ((t2h == rem) && (t2l <= wnump[-2])))
                    break;
                q--;
                rem += d0;
                if (rem < d0)
                    break;      /* don't let rem overflow */
                if (t2l < d1)
                    t2h--;
                t2l -= d1;
            }
        }

        l0 = bn_mul_words(tmp->d, sdiv->d, div_n, q);
        tmp->d[div_n] = l0;
        wnum.d--;
        /*
         * ingore top values of the bignums just sub the two BN_ULONG arrays
         * with bn_sub_words
         */
        if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n + 1)) {
            /*
             * Note: As we have considered only the leading two BN_ULONGs in
             * the calculation of q, sdiv * q might be greater than wnum (but
             * then (q-1) * sdiv is less or equal than wnum)
             */
            q--;
            if (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n))
                /*
                 * we can't have an overflow here (assuming that q != 0, but
                 * if q == 0 then tmp is zero anyway)
                 */
                (*wnump)++;
        }
        /* store part of the result */
        resp--;
        *resp = q;
    }
    bn_correct_top(snum);
    if (rm != NULL) {
        /*
         * Keep a copy of the neg flag in num because if rm==num BN_rshift()
         * will overwrite it.
         */
        int neg = num->neg;
        BN_rshift(rm, snum, norm_shift);
        if (!BN_is_zero(rm))
            rm->neg = neg;
    }

    BN_CTX_end(ctx);
    return 1;
 err:
    BN_CTX_end(ctx);
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
BIGNUM *BN_mod_inverse(BIGNUM *in,
                       const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
    BIGNUM *rv;
    int noinv;
    rv = int_bn_mod_inverse(in, a, n, ctx, &noinv);
    return rv;
}

BIGNUM *int_bn_mod_inverse(BIGNUM *in,
                           const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx,
                           int *pnoinv)
{
    BIGNUM *A, *B, *X, *Y, *T, *R = in;
    BIGNUM *ret = NULL;
    int sign;

    /* This is invalid input so we don't worry about constant time here */
    if (BN_abs_is_word(n, 1) || BN_is_zero(n)) {
        if (pnoinv != NULL)
            *pnoinv = 1;
        return NULL;
    }

    if (pnoinv != NULL)
        *pnoinv = 0;

    BN_CTX_start(ctx);
    A = BN_CTX_get(ctx);
    B = BN_CTX_get(ctx);
    X = BN_CTX_get(ctx);
    Y = BN_CTX_get(ctx);
    T = BN_CTX_get(ctx);
    if (T == NULL)
        goto err;

    if (R == NULL)
        goto err;

    BN_one(X);
    BN_zero(Y);
    if (BN_copy(B, a) == NULL)
        goto err;
    if (BN_copy(A, n) == NULL)
        goto err;
    A->neg = 0;
    if (B->neg || (BN_ucmp(B, A) >= 0)) {
        if (!BN_nnmod(B, B, A, ctx))
            goto err;
    }
    sign = -1;
    /*-
     * From  B = a mod |n|,  A = |n|  it follows that
     *
     *      0 <= B < A,
     *     -sign*X*a  ==  B   (mod |n|),
     *      sign*Y*a  ==  A   (mod |n|).
     */

    // SM2使用的模数是椭圆曲线的阶，即一个大素数，而素数通常是奇数
    if (BN_is_odd(n) && (BN_num_bits(n) <= 2048)) {
        /*
         * Binary inversion algorithm; requires odd modulus. This is faster
         * than the general algorithm if the modulus is sufficiently small
         * (about 400 .. 500 bits on 32-bit systems, but much more on 64-bit
         * systems)
         */
        int shift;

        while (!BN_is_zero(B)) {
            /*-
             *      0 < B < |n|,
             *      0 < A <= |n|,
             * (1) -sign*X*a  ==  B   (mod |n|),
             * (2)  sign*Y*a  ==  A   (mod |n|)
             */

            /*
             * Now divide B by the maximum possible power of two in the
             * integers, and divide X by the same value mod |n|. When we're
             * done, (1) still holds.
             */
            shift = 0;
            while (!BN_is_bit_set(B, shift)) { /* note that 0 < B */
                shift++;

                if (BN_is_odd(X)) {
                    if (!BN_uadd(X, X, n))
                        goto err;
                }
                /*
                 * now X is even, so we can easily divide it by two
                 */
                if (!BN_rshift1(X, X))
                    goto err;
            }
            if (shift > 0) {
                if (!BN_rshift(B, B, shift))
                    goto err;
            }

            /*
             * Same for A and Y.  Afterwards, (2) still holds.
             */
            shift = 0;
            while (!BN_is_bit_set(A, shift)) { /* note that 0 < A */
                shift++;

                if (BN_is_odd(Y)) {
                    if (!BN_uadd(Y, Y, n))
                        goto err;
                }
                /* now Y is even */
                if (!BN_rshift1(Y, Y))
                    goto err;
            }
            if (shift > 0) {
                if (!BN_rshift(A, A, shift))
                    goto err;
            }

            /*-
             * We still have (1) and (2).
             * Both  A  and  B  are odd.
             * The following computations ensure that
             *
             *     0 <= B < |n|,
             *      0 < A < |n|,
             * (1) -sign*X*a  ==  B   (mod |n|),
             * (2)  sign*Y*a  ==  A   (mod |n|),
             *
             * and that either  A  or  B  is even in the next iteration.
             */
            if (BN_ucmp(B, A) >= 0) {
                /* -sign*(X + Y)*a == B - A  (mod |n|) */
                if (!BN_uadd(X, X, Y))
                    goto err;
                /*
                 * NB: we could use BN_mod_add_quick(X, X, Y, n), but that
                 * actually makes the algorithm slower
                 */
                if (!BN_usub(B, B, A))
                    goto err;
            } else {
                /*  sign*(X + Y)*a == A - B  (mod |n|) */
                if (!BN_uadd(Y, Y, X))
                    goto err;
                /*
                 * as above, BN_mod_add_quick(Y, Y, X, n) would slow things down
                 */
                if (!BN_usub(A, A, B))
                    goto err;
            }
        }
    } else {
        // printf("%s never here...\n", __func__);
        goto err;
    }

    /*-
     * The while loop (Euclid's algorithm) ends when
     *      A == gcd(a,n);
     * we have
     *       sign*Y*a  ==  A  (mod |n|),
     * where  Y  is non-negative.
     */

    if (sign < 0) {
        if (!BN_sub(Y, n, Y))
            goto err;
    }
    /* Now  Y*a  ==  A  (mod |n|).  */

    if (BN_is_one(A)) {
        /* Y*a == 1  (mod |n|) */
        if (!Y->neg && BN_ucmp(Y, n) < 0) {
            if (!BN_copy(R, Y))
                goto err;
        } else {
            if (!BN_nnmod(R, Y, n, ctx))
                goto err;
        }
    } else {
        if (pnoinv)
            *pnoinv = 1;
        goto err;
    }
    ret = R;
 err:
    BN_CTX_end(ctx);
    return ret;
}

///////////////////////////////////////////////////////////////////////////////
int BN_add_word(BIGNUM *a, BN_ULONG w)
{
    BN_ULONG l;
    int i;

    w &= BN_MASK2;

    /* degenerate case: w is zero */
    if (!w)
        return 1;
    /* degenerate case: a is zero */
    if (BN_is_zero(a))
        return BN_set_word(a, w);
    /* handle 'a' when negative */
    if (a->neg) {
        a->neg = 0;
        i = BN_sub_word(a, w);
        if (!BN_is_zero(a))
            a->neg = !(a->neg);
        return i;
    }
    for (i = 0; w != 0 && i < a->top; i++) {
        a->d[i] = l = (a->d[i] + w) & BN_MASK2;
        w = (w > l) ? 1 : 0;
    }
    if (w && i == a->top) {
        if (bn_wexpand(a, a->top + 1) == NULL)
            return 0;
        a->top++;
        a->d[i] = w;
    }
    return 1;
}

int BN_sub_word(BIGNUM *a, BN_ULONG w)
{
    int i;

    w &= BN_MASK2;

    /* degenerate case: w is zero */
    if (!w)
        return 1;
    /* degenerate case: a is zero */
    if (BN_is_zero(a)) {
        i = BN_set_word(a, w);
        if (i != 0)
            BN_set_negative(a, 1);
        return i;
    }
    /* handle 'a' when negative */
    if (a->neg) {
        a->neg = 0;
        i = BN_add_word(a, w);
        a->neg = 1;
        return i;
    }

    if ((a->top == 1) && (a->d[0] < w)) {
        a->d[0] = w - a->d[0];
        a->neg = 1;
        return 1;
    }
    i = 0;
    for (;;) {
        if (a->d[i] >= w) {
            a->d[i] -= w;
            break;
        } else {
            a->d[i] = (a->d[i] - w) & BN_MASK2;
            i++;
            w = 1;
        }
    }
    if ((a->d[i] == 0) && (i == (a->top - 1)))
        a->top--;
    return 1;
}

///////////////////////////////////////////////////////////////////////////////
#define MONT_WORD               /* use the faster word-based algorithm */

#ifdef MONT_WORD
static int bn_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont);
#endif

int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          BN_MONT_CTX *mont, BN_CTX *ctx)
{
    int ret = bn_mul_mont_fixed_top(r, a, b, mont, ctx);

    bn_correct_top(r);

    return ret;
}

int bn_mul_mont_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          BN_MONT_CTX *mont, BN_CTX *ctx)
{
    BIGNUM *tmp;
    int ret = 0;
    int num = mont->N.top;

#if defined(OPENSSL_BN_ASM_MONT) && defined(MONT_WORD)
    if (num > 1 && a->top == num && b->top == num) {
        if (bn_wexpand(r, num) == NULL)
            return 0;
        if (bn_mul_mont(r->d, a->d, b->d, mont->N.d, mont->n0, num)) {
            r->neg = a->neg ^ b->neg;
            r->top = num;
            return 1;
        }
    }
#endif

    if ((a->top + b->top) > 2 * num)
        return 0;

    BN_CTX_start(ctx);
    tmp = BN_CTX_get(ctx);
    if (tmp == NULL)
        goto err;

    if (a == b) {
        if (!bn_sqr_fixed_top(tmp, a, ctx))
            goto err;
    } else {
        if (!bn_mul_fixed_top(tmp, a, b, ctx))
            goto err;
    }
    /* reduce from aRR to aR */
#ifdef MONT_WORD
    if (!bn_from_montgomery_word(r, tmp, mont))
        goto err;
#else
    if (!BN_from_montgomery(r, tmp, mont, ctx))
        goto err;
#endif
    ret = 1;
 err:
    BN_CTX_end(ctx);
    return ret;
}

#ifdef MONT_WORD
static int bn_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)
{
    BIGNUM *n;
    BN_ULONG *ap, *np, *rp, n0, v, carry;
    int nl, max, i;
    unsigned int rtop;

    n = &(mont->N);
    nl = n->top;
    if (nl == 0) {
        ret->top = 0;
        return 1;
    }

    max = (2 * nl);             /* carry is stored separately */
    if (bn_wexpand(r, max) == NULL)
        return 0;

    r->neg ^= n->neg;
    np = n->d;
    rp = r->d;

    /* clear the top words of T */
    for (rtop = r->top, i = 0; i < max; i++) {
        v = (BN_ULONG)0 - ((i - rtop) >> (8 * sizeof(rtop) - 1));
        rp[i] &= v;
    }

    r->top = max;
    n0 = mont->n0[0];

    /*
     * Add multiples of |n| to |r| until R = 2^(nl * BN_BITS2) divides it. On
     * input, we had |r| < |n| * R, so now |r| < 2 * |n| * R. Note that |r|
     * includes |carry| which is stored separately.
     */
    for (carry = 0, i = 0; i < nl; i++, rp++) {
        v = bn_mul_add_words(rp, np, nl, (rp[0] * n0) & BN_MASK2);
        v = (v + carry + rp[nl]) & BN_MASK2;
        carry |= (v != rp[nl]);
        carry &= (v <= rp[nl]);
        rp[nl] = v;
    }

    if (bn_wexpand(ret, nl) == NULL)
        return 0;
    ret->top = nl;
    ret->neg = r->neg;

    rp = ret->d;

    /*
     * Shift |nl| words to divide by R. We have |ap| < 2 * |n|. Note that |ap|
     * includes |carry| which is stored separately.
     */
    ap = &(r->d[nl]);

    carry -= bn_sub_words(rp, ap, np, nl);
    /*
     * |carry| is -1 if |ap| - |np| underflowed or zero if it did not. Note
     * |carry| cannot be 1. That would imply the subtraction did not fit in
     * |nl| words, and we know at most one subtraction is needed.
     */
    for (i = 0; i < nl; i++) {
        rp[i] = (carry & ap[i]) | (~carry & rp[i]);
        ap[i] = 0;
    }

    return 1;
}
#endif                          /* MONT_WORD */

int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
                       BN_CTX *ctx)
{
    int retn;

    retn = bn_from_mont_fixed_top(ret, a, mont, ctx);
    bn_correct_top(ret);

    return retn;
}

int bn_from_mont_fixed_top(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
                           BN_CTX *ctx)
{
    int retn = 0;
#ifdef MONT_WORD
    BIGNUM *t;

    BN_CTX_start(ctx);
    if ((t = BN_CTX_get(ctx)) && BN_copy(t, a)) {
        retn = bn_from_montgomery_word(ret, t, mont);
    }
    BN_CTX_end(ctx);
#else                           /* !MONT_WORD */
    BIGNUM *t1, *t2;

    BN_CTX_start(ctx);
    t1 = BN_CTX_get(ctx);
    t2 = BN_CTX_get(ctx);
    if (t2 == NULL)
        goto err;

    if (!BN_copy(t1, a))
        goto err;
    BN_mask_bits(t1, mont->ri);

    if (!BN_mul(t2, t1, &mont->Ni, ctx))
        goto err;
    BN_mask_bits(t2, mont->ri);

    if (!BN_mul(t1, t2, &mont->N, ctx))
        goto err;
    if (!BN_add(t2, a, t1))
        goto err;
    if (!BN_rshift(ret, t2, mont->ri))
        goto err;

    if (BN_ucmp(ret, &(mont->N)) >= 0) {
        if (!BN_usub(ret, ret, &(mont->N)))
            goto err;
    }
    retn = 1;
 err:
    BN_CTX_end(ctx);
#endif                          /* MONT_WORD */
    return retn;
}

void BN_MONT_CTX_init(BN_MONT_CTX *ctx)
{
    ctx->ri = 0;
    // bn_init(&ctx->RR);
    // bn_init(&ctx->N);
    // bn_init(&ctx->Ni);
    ctx->n0[0] = ctx->n0[1] = 0;
}

int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
{
    int i, ret = 0;
    BIGNUM *Ri, *R;

    if (BN_is_zero(mod))
        return 0;

    BN_CTX_start(ctx);
    if ((Ri = BN_CTX_get(ctx)) == NULL)
        goto err;
    R = &(mont->RR);            /* grab RR as a temp */
    if (!BN_copy(&(mont->N), mod))
        goto err;               /* Set N */

    mont->N.neg = 0;

#ifdef MONT_WORD
    {
        BIGNUM tmod;
        BN_ULONG buf[2];
        tmod.d = buf;
        tmod.dmax = 2;
        tmod.neg = 0;

        mont->ri = (BN_num_bits(mod) + (BN_BITS2 - 1)) / BN_BITS2 * BN_BITS2;

# if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)
        /*
         * Only certain BN_BITS2<=32 platforms actually make use of n0[1],
         * and we could use the #else case (with a shorter R value) for the
         * others.  However, currently only the assembler files do know which
         * is which.
         */

        BN_zero(R);
        if (!(BN_set_bit(R, 2 * BN_BITS2)))
            goto err;

        tmod.top = 0;
        if ((buf[0] = mod->d[0]))
            tmod.top = 1;
        if ((buf[1] = mod->top > 1 ? mod->d[1] : 0))
            tmod.top = 2;

        if (BN_is_one(&tmod))
            BN_zero(Ri);
        else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)
            goto err;
        if (!BN_lshift(Ri, Ri, 2 * BN_BITS2))
            goto err;           /* R*Ri */
        if (!BN_is_zero(Ri)) {
            if (!BN_sub_word(Ri, 1))
                goto err;
        } else {                /* if N mod word size == 1 */

            if (bn_expand(Ri, (int)sizeof(BN_ULONG) * 2) == NULL)
                goto err;
            /* Ri-- (mod double word size) */
            Ri->neg = 0;
            Ri->d[0] = BN_MASK2;
            Ri->d[1] = BN_MASK2;
            Ri->top = 2;
        }
        if (!BN_div(Ri, NULL, Ri, &tmod, ctx))
            goto err;
        /*
         * Ni = (R*Ri-1)/N, keep only couple of least significant words:
         */
        mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;
        mont->n0[1] = (Ri->top > 1) ? Ri->d[1] : 0;
# else
        BN_zero(R);
        if (!(BN_set_bit(R, BN_BITS2)))
            goto err;           /* R */

        buf[0] = mod->d[0];     /* tmod = N mod word size */
        buf[1] = 0;
        tmod.top = buf[0] != 0 ? 1 : 0;
        /* Ri = R^-1 mod N */
        if (BN_is_one(&tmod))
            BN_zero(Ri);
        else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)
            goto err;
        if (!BN_lshift(Ri, Ri, BN_BITS2))
            goto err;           /* R*Ri */
        if (!BN_is_zero(Ri)) {
            if (!BN_sub_word(Ri, 1))
                goto err;
        } else {                /* if N mod word size == 1 */

            if (!BN_set_word(Ri, BN_MASK2))
                goto err;       /* Ri-- (mod word size) */
        }
        if (!BN_div(Ri, NULL, Ri, &tmod, ctx))
            goto err;
        /*
         * Ni = (R*Ri-1)/N, keep only least significant word:
         */
        mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;
        mont->n0[1] = 0;
# endif
    }
#else                           /* !MONT_WORD */
    {                           /* bignum version */
        mont->ri = BN_num_bits(&mont->N);
        BN_zero(R);
        if (!BN_set_bit(R, mont->ri))
            goto err;           /* R = 2^ri */
        /* Ri = R^-1 mod N */
        if ((BN_mod_inverse(Ri, R, &mont->N, ctx)) == NULL)
            goto err;
        if (!BN_lshift(Ri, Ri, mont->ri))
            goto err;           /* R*Ri */
        if (!BN_sub_word(Ri, 1))
            goto err;
        /*
         * Ni = (R*Ri-1) / N
         */
        if (!BN_div(&(mont->Ni), NULL, Ri, &mont->N, ctx))
            goto err;
    }
#endif

    /* setup RR for conversions */
    BN_zero(&(mont->RR));
    if (!BN_set_bit(&(mont->RR), mont->ri * 2))
        goto err;
    if (!BN_mod(&(mont->RR), &(mont->RR), &(mont->N), ctx))
        goto err;

    for (i = mont->RR.top, ret = mont->N.top; i < ret; i++)
        mont->RR.d[i] = 0;
    mont->RR.top = ret;

    ret = 1;
 err:
    BN_CTX_end(ctx);
    return ret;
}

///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////

/*
 * Types and functions to manipulate pre-computed values.
 */
typedef struct ec_pre_comp_st EC_PRE_COMP;

struct ec_point_st {
    BIGNUM X;
    BIGNUM Y;
    BIGNUM Z;                  /* Jacobian projective coordinates: * (X, Y,
                                 * Z) represents (X/Z^2, Y/Z^3) if Z != 0 */
    int Z_is_one;               /* enable optimized point arithmetics for
                                 * special case */
};

/* structure for precomputed multiples of the generator */
struct ec_pre_comp_st {
    SIZE_T blocksize;           /* block size for wNAF splitting */
    SIZE_T numblocks;           /* max. number of blocks for which we have
                                 * precomputation */
    SIZE_T w;                   /* window size */
    // EC_POINT point_st[256];
    EC_POINT *point[256];
    EC_POINT **points;          /* array with pre-calculated multiples of
                                 * generator: 'num' pointers to EC_POINT
                                 * objects followed by a NULL */
    SIZE_T num;                 /* numblocks * 2^(w-1) */
};

struct ec_group_st {
    BIGNUM one;
    EC_POINT generator;        /* optional */
    BIGNUM order, cofactor;

    /*
     * The following members are handled by the method functions, even if
     * they appear generic
     */
    /*
     * Field specification. For curves over GF(p), this is the modulus; for
     * curves over GF(2^m), this is the irreducible polynomial defining the
     * field.
     */
    BIGNUM field;
    /*
     * Curve coefficients. (Here the assumption is that BIGNUMs can be used
     * or abused for all kinds of fields, not just GF(p).) For characteristic
     * > 3, the curve is defined by a Weierstrass equation of the form y^2 =
     * x^3 + a*x + b. For characteristic 2, the curve is defined by an
     * equation of the form y^2 + x*y = x^3 + a*x^2 + b.
     */
    BIGNUM a, b;
    /* enable optimized point arithmetics for special case */
    int a_is_minus3;
    /* method-specific (e.g., Montgomery structure) */
    void *field_data1;
    /* method-specific */
    void *field_data2;

    /* data for ECDSA inverse */
    BN_MONT_CTX mont_data;
    BN_MONT_CTX mont_curve;

    EC_PRE_COMP ec;
};

/*
 * method functions in ec_mult.c (ec_lib.c uses these as defaults if
 * group->method->mul is 0)
 */
int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                SIZE_T num, const EC_POINT *points[], const BIGNUM *scalars[],
                BN_CTX *);
int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *, EC_POINT *);
int ec_wNAF_precompute_mult_load(EC_GROUP *group, EC_POINT *);

/* method functions in ecp_smpl.c */

int ec_GFp_simple_group_set_curve(EC_GROUP *, const BIGNUM *p,
                                  const BIGNUM *a, const BIGNUM *b, BN_CTX *);

int ec_GFp_simple_point_init(EC_POINT *);
int ec_GFp_simple_point_copy(EC_POINT *, const EC_POINT *);
int ec_GFp_simple_point_set_to_infinity(const EC_GROUP *, EC_POINT *);
int ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *,
                                                  EC_POINT *, const BIGNUM *x,
                                                  const BIGNUM *y,
                                                  const BIGNUM *z, BN_CTX *);

int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *,
                                               const EC_POINT *, BIGNUM *x,
                                               BIGNUM *y, BN_CTX *);

SIZE_T ec_GFp_simple_point2oct(const EC_GROUP *, const EC_POINT *,
                               unsigned char *buf, SIZE_T len, BN_CTX *);

int ec_GFp_simple_add(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
                      const EC_POINT *b, BN_CTX *);
int ec_GFp_simple_dbl(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
                      BN_CTX *);
int ec_GFp_simple_invert(const EC_GROUP *, EC_POINT *, BN_CTX *);
int ec_GFp_simple_is_at_infinity(const EC_GROUP *, const EC_POINT *);
int ec_GFp_simple_is_on_curve(const EC_GROUP *, const EC_POINT *, BN_CTX *);

/* method functions in ecp_mont.c */
int ec_GFp_mont_group_set_curve(EC_GROUP *, const BIGNUM *p, const BIGNUM *a,
                                const BIGNUM *b, BN_CTX *);

int ec_GFp_mont_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
                          const BIGNUM *b, BN_CTX *);
int ec_GFp_mont_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
                          BN_CTX *);
int ec_GFp_mont_field_encode(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
                             BN_CTX *);
int ec_GFp_mont_field_decode(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
                             BN_CTX *);
int ec_GFp_mont_field_set_to_one(const EC_GROUP *, BIGNUM *r, BN_CTX *);

///////////////////////////////////////////////////////////////////////////////
/*
 * Most method functions in this file are designed to work with
 * non-trivial representations of field elements if necessary
 * (see ecp_mont.c): while standard modular addition and subtraction
 * are used, the field_mul and field_sqr methods will be used for
 * multiplication, and field_encode and field_decode (if defined)
 * will be used for converting between representations.
 *
 * Functions ec_GFp_simple_points_make_affine() and
 * ec_GFp_simple_point_get_affine_coordinates() specifically assume
 * that if a non-trivial representation is used, it is a Montgomery
 * representation (i.e. 'encoding' means multiplying by some factor R).
 */

int ec_GFp_simple_group_set_curve(EC_GROUP *group,
                                  const BIGNUM *p, const BIGNUM *a,
                                  const BIGNUM *b, BN_CTX *ctx)
{
    int ret = 0;
    BIGNUM *tmp_a;

    /* p must be a prime > 3 */
    if (BN_num_bits(p) <= 2 || !BN_is_odd(p)) {
        return 0;
    }

    if (ctx == NULL)
        return 0;

    BN_CTX_start(ctx);
    tmp_a = BN_CTX_get(ctx);
    if (tmp_a == NULL)
        goto err;

    /* group->field */
    if (!BN_copy(&group->field, p))
        goto err;
    BN_set_negative(&group->field, 0);

    /* group->a */
    if (!BN_nnmod(tmp_a, a, p, ctx))
        goto err;
    {
        if (!ec_GFp_mont_field_encode(group, &group->a, tmp_a, ctx))
            goto err;
    }

    /* group->b */
    if (!BN_nnmod(&group->b, b, p, ctx))
        goto err;

    if (!ec_GFp_mont_field_encode(group, &group->b, &group->b, ctx))
        goto err;

    /* group->a_is_minus3 */
    if (!BN_add_word(tmp_a, 3))
        goto err;
    group->a_is_minus3 = (0 == BN_cmp(tmp_a, &group->field));

    ret = 1;

 err:
    BN_CTX_end(ctx);
    return ret;
}

int ec_GFp_simple_point_init(EC_POINT *point)
{
    point->Z_is_one = 0;
    return 1;
}

int ec_GFp_simple_point_copy(EC_POINT *dest, const EC_POINT *src)
{
    if (!BN_copy(&dest->X, &src->X))
        return 0;
    if (!BN_copy(&dest->Y, &src->Y))
        return 0;
    if (!BN_copy(&dest->Z, &src->Z))
        return 0;
    dest->Z_is_one = src->Z_is_one;

    return 1;
}

int ec_GFp_simple_point_set_to_infinity(const EC_GROUP *group,
                                        EC_POINT *point)
{
    point->Z_is_one = 0;
    BN_zero(&point->Z);
    return 1;
}

int ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                                  EC_POINT *point,
                                                  const BIGNUM *x,
                                                  const BIGNUM *y,
                                                  const BIGNUM *z,
                                                  BN_CTX *ctx)
{
    int ret = 0;

    if (ctx == NULL)
        return 0;

    if (x != NULL) {
        if (!BN_nnmod(&point->X, x, &group->field, ctx))
            goto err;
        {
            if (!ec_GFp_mont_field_encode(group, &point->X, &point->X, ctx))
                goto err;
        }
    }

    if (y != NULL) {
        if (!BN_nnmod(&point->Y, y, &group->field, ctx))
            goto err;
        {
            if (!ec_GFp_mont_field_encode(group, &point->Y, &point->Y, ctx))
                goto err;
        }
    }

    if (z != NULL) {
        int Z_is_one;

        if (!BN_nnmod(&point->Z, z, &group->field, ctx))
            goto err;
        Z_is_one = BN_is_one(&point->Z);
        {
            if (Z_is_one) {
                if (!ec_GFp_mont_field_set_to_one(group, &point->Z, ctx))
                    goto err;
            } else {
                if (!ec_GFp_mont_field_encode(group, &point->Z, &point->Z, ctx))
                    goto err;
            }
        }
        point->Z_is_one = Z_is_one;
    }

    ret = 1;

 err:
    return ret;
}

int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group,
                                               const EC_POINT *point,
                                               BIGNUM *x, BIGNUM *y,
                                               BN_CTX *ctx)
{
    BIGNUM *Z, *Z_1, *Z_2, *Z_3;
    const BIGNUM *Z_;
    int ret = 0;

    if (ec_GFp_simple_is_at_infinity(group, point)) {
        return 0;
    }

    if (ctx == NULL)
        return 0;


    BN_CTX_start(ctx);
    Z = BN_CTX_get(ctx);
    Z_1 = BN_CTX_get(ctx);
    Z_2 = BN_CTX_get(ctx);
    Z_3 = BN_CTX_get(ctx);
    if (Z_3 == NULL)
        goto err;

    /* transform  (X, Y, Z)  into  (x, y) := (X/Z^2, Y/Z^3) */

    {
        if (!ec_GFp_mont_field_decode(group, Z, &point->Z, ctx))
            goto err;
        Z_ = Z;
    }

    if (BN_is_one(Z_)) {
        {
            if (x != NULL) {
                if (!ec_GFp_mont_field_decode(group, x, &point->X, ctx))
                    goto err;
            }
            if (y != NULL) {
                if (!ec_GFp_mont_field_decode(group, y, &point->Y, ctx))
                    goto err;
            }
        }
    } else {
        if (!BN_mod_inverse(Z_1, Z_, &group->field, ctx)) {
            goto err;
        }

        {
            if (!BN_mod_sqr(Z_2, Z_1, &group->field, ctx))
                goto err;
        }

        if (x != NULL) {
            /*
             * in the Montgomery case, field_mul will cancel out Montgomery
             * factor in X:
             */
            if (!ec_GFp_mont_field_mul(group, x, &point->X, Z_2, ctx))
                goto err;
        }

        if (y != NULL) {
            {
                if (!BN_mod_mul(Z_3, Z_2, Z_1, &group->field, ctx))
                    goto err;
            }

            /*
             * in the Montgomery case, field_mul will cancel out Montgomery
             * factor in Y:
             */
            if (!ec_GFp_mont_field_mul(group, y, &point->Y, Z_3, ctx))
                goto err;
        }
    }

    ret = 1;

 err:
    BN_CTX_end(ctx);
    return ret;
}

int ec_GFp_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
                      const EC_POINT *b, BN_CTX *ctx)
{
    const BIGNUM *p;

    BIGNUM *n0, *n1, *n2, *n3, *n4, *n5, *n6;
    int ret = 0;

    if (a == b)
        return ec_GFp_simple_dbl(group, r, a, ctx);
    if (ec_GFp_simple_is_at_infinity(group, a))
        return EC_POINT_copy(r, b);
    if (ec_GFp_simple_is_at_infinity(group, b))
        return EC_POINT_copy(r, a);

    p = &group->field;

    if (ctx == NULL)
        return 0;

    BN_CTX_start(ctx);
    n0 = BN_CTX_get(ctx);
    n1 = BN_CTX_get(ctx);
    n2 = BN_CTX_get(ctx);
    n3 = BN_CTX_get(ctx);
    n4 = BN_CTX_get(ctx);
    n5 = BN_CTX_get(ctx);
    n6 = BN_CTX_get(ctx);
    if (n6 == NULL)
        goto end;

    /*
     * Note that in this function we must not read components of 'a' or 'b'
     * once we have written the corresponding components of 'r'. ('r' might
     * be one of 'a' or 'b'.)
     */

    /* n1, n2 */
    if (b->Z_is_one) {
        if (!BN_copy(n1, &a->X))
            goto end;
        if (!BN_copy(n2, &a->Y))
            goto end;
        /* n1 = X_a */
        /* n2 = Y_a */
    } else {
        if (!ec_GFp_mont_field_sqr(group, n0, &b->Z, ctx))
            goto end;
        if (!ec_GFp_mont_field_mul(group, n1, &a->X, n0, ctx))
            goto end;
        /* n1 = X_a * Z_b^2 */

        if (!ec_GFp_mont_field_mul(group, n0, n0, &b->Z, ctx))
            goto end;
        if (!ec_GFp_mont_field_mul(group, n2, &a->Y, n0, ctx))
            goto end;
        /* n2 = Y_a * Z_b^3 */
    }

    /* n3, n4 */
    if (a->Z_is_one) {
        if (!BN_copy(n3, &b->X))
            goto end;
        if (!BN_copy(n4, &b->Y))
            goto end;
        /* n3 = X_b */
        /* n4 = Y_b */
    } else {
        if (!ec_GFp_mont_field_sqr(group, n0, &a->Z, ctx))
            goto end;
        if (!ec_GFp_mont_field_mul(group, n3, &b->X, n0, ctx))
            goto end;
        /* n3 = X_b * Z_a^2 */

        if (!ec_GFp_mont_field_mul(group, n0, n0, &a->Z, ctx))
            goto end;
        if (!ec_GFp_mont_field_mul(group, n4, &b->Y, n0, ctx))
            goto end;
        /* n4 = Y_b * Z_a^3 */
    }

    /* n5, n6 */
    if (!BN_mod_sub_quick(n5, n1, n3, p))
        goto end;
    if (!BN_mod_sub_quick(n6, n2, n4, p))
        goto end;
    /* n5 = n1 - n3 */
    /* n6 = n2 - n4 */

    if (BN_is_zero(n5)) {
        if (BN_is_zero(n6)) {
            /* a is the same point as b */
            BN_CTX_end(ctx);
            ret = ec_GFp_simple_dbl(group, r, a, ctx);
            ctx = NULL;
            goto end;
        } else {
            /* a is the inverse of b */
            BN_zero(&r->Z);
            r->Z_is_one = 0;
            ret = 1;
            goto end;
        }
    }

    /* 'n7', 'n8' */
    if (!BN_mod_add_quick(n1, n1, n3, p))
        goto end;
    if (!BN_mod_add_quick(n2, n2, n4, p))
        goto end;
    /* 'n7' = n1 + n3 */
    /* 'n8' = n2 + n4 */

    /* Z_r */
    if (a->Z_is_one && b->Z_is_one) {
        if (!BN_copy(&r->Z, n5))
            goto end;
    } else {
        if (a->Z_is_one) {
            if (!BN_copy(n0, &b->Z))
                goto end;
        } else if (b->Z_is_one) {
            if (!BN_copy(n0, &a->Z))
                goto end;
        } else {
            if (!ec_GFp_mont_field_mul(group, n0, &a->Z, &b->Z, ctx))
                goto end;
        }
        if (!ec_GFp_mont_field_mul(group, &r->Z, n0, n5, ctx))
            goto end;
    }
    r->Z_is_one = 0;
    /* Z_r = Z_a * Z_b * n5 */

    /* X_r */
    if (!ec_GFp_mont_field_sqr(group, n0, n6, ctx))
        goto end;
    if (!ec_GFp_mont_field_sqr(group, n4, n5, ctx))
        goto end;
    if (!ec_GFp_mont_field_mul(group, n3, n1, n4, ctx))
        goto end;
    if (!BN_mod_sub_quick(&r->X, n0, n3, p))
        goto end;
    /* X_r = n6^2 - n5^2 * 'n7' */

    /* 'n9' */
    if (!BN_mod_lshift1_quick(n0, &r->X, p))
        goto end;
    if (!BN_mod_sub_quick(n0, n3, n0, p))
        goto end;
    /* n9 = n5^2 * 'n7' - 2 * X_r */

    /* Y_r */
    if (!ec_GFp_mont_field_mul(group, n0, n0, n6, ctx))
        goto end;
    if (!ec_GFp_mont_field_mul(group, n5, n4, n5, ctx))
        goto end;               /* now n5 is n5^3 */
    if (!ec_GFp_mont_field_mul(group, n1, n2, n5, ctx))
        goto end;
    if (!BN_mod_sub_quick(n0, n0, n1, p))
        goto end;
    if (BN_is_odd(n0))
        if (!BN_add(n0, n0, p))
            goto end;
    /* now  0 <= n0 < 2*p,  and n0 is even */
    if (!BN_rshift1(&r->Y, n0))
        goto end;
    /* Y_r = (n6 * 'n9' - 'n8' * 'n5^3') / 2 */

    ret = 1;

 end:
    if (ctx)                    /* otherwise we already called BN_CTX_end */
        BN_CTX_end(ctx);
    return ret;
}

int ec_GFp_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
                      BN_CTX *ctx)
{
    const BIGNUM *p;

    BIGNUM *n0, *n1, *n2, *n3;
    int ret = 0;

    if (ec_GFp_simple_is_at_infinity(group, a)) {
        BN_zero(&r->Z);
        r->Z_is_one = 0;
        return 1;
    }

    p = &group->field;

    if (ctx == NULL)
        return 0;

    BN_CTX_start(ctx);
    n0 = BN_CTX_get(ctx);
    n1 = BN_CTX_get(ctx);
    n2 = BN_CTX_get(ctx);
    n3 = BN_CTX_get(ctx);
    if (n3 == NULL)
        goto err;

    /*
     * Note that in this function we must not read components of 'a' once we
     * have written the corresponding components of 'r'. ('r' might the same
     * as 'a'.)
     */

    /* n1 */
    if (a->Z_is_one) {
        if (!ec_GFp_mont_field_sqr(group, n0, &a->X, ctx))
            goto err;
        if (!BN_mod_lshift1_quick(n1, n0, p))
            goto err;
        if (!BN_mod_add_quick(n0, n0, n1, p))
            goto err;
        if (!BN_mod_add_quick(n1, n0, &group->a, p))
            goto err;
        /* n1 = 3 * X_a^2 + a_curve */
    } else if (group->a_is_minus3) {
        if (!ec_GFp_mont_field_sqr(group, n1, &a->Z, ctx))
            goto err;
        if (!BN_mod_add_quick(n0, &a->X, n1, p))
            goto err;
        if (!BN_mod_sub_quick(n2, &a->X, n1, p))
            goto err;
        if (!ec_GFp_mont_field_mul(group, n1, n0, n2, ctx))
            goto err;
        if (!BN_mod_lshift1_quick(n0, n1, p))
            goto err;
        if (!BN_mod_add_quick(n1, n0, n1, p))
            goto err;
        /*-
         * n1 = 3 * (X_a + Z_a^2) * (X_a - Z_a^2)
         *    = 3 * X_a^2 - 3 * Z_a^4
         */
    } else {
        if (!ec_GFp_mont_field_sqr(group, n0, &a->X, ctx))
            goto err;
        if (!BN_mod_lshift1_quick(n1, n0, p))
            goto err;
        if (!BN_mod_add_quick(n0, n0, n1, p))
            goto err;
        if (!ec_GFp_mont_field_sqr(group, n1, &a->Z, ctx))
            goto err;
        if (!ec_GFp_mont_field_sqr(group, n1, n1, ctx))
            goto err;
        if (!ec_GFp_mont_field_mul(group, n1, n1, &group->a, ctx))
            goto err;
        if (!BN_mod_add_quick(n1, n1, n0, p))
            goto err;
        /* n1 = 3 * X_a^2 + a_curve * Z_a^4 */
    }

    /* Z_r */
    if (a->Z_is_one) {
        if (!BN_copy(n0, &a->Y))
            goto err;
    } else {
        if (!ec_GFp_mont_field_mul(group, n0, &a->Y, &a->Z, ctx))
            goto err;
    }
    if (!BN_mod_lshift1_quick(&r->Z, n0, p))
        goto err;
    r->Z_is_one = 0;
    /* Z_r = 2 * Y_a * Z_a */

    /* n2 */
    if (!ec_GFp_mont_field_sqr(group, n3, &a->Y, ctx))
        goto err;
    if (!ec_GFp_mont_field_mul(group, n2, &a->X, n3, ctx))
        goto err;
    if (!BN_mod_lshift_quick(n2, n2, 2, p))
        goto err;
    /* n2 = 4 * X_a * Y_a^2 */

    /* X_r */
    if (!BN_mod_lshift1_quick(n0, n2, p))
        goto err;
    if (!ec_GFp_mont_field_sqr(group, &r->X, n1, ctx))
        goto err;
    if (!BN_mod_sub_quick(&r->X, &r->X, n0, p))
        goto err;
    /* X_r = n1^2 - 2 * n2 */

    /* n3 */
    if (!ec_GFp_mont_field_sqr(group, n0, n3, ctx))
        goto err;
    if (!BN_mod_lshift_quick(n3, n0, 3, p))
        goto err;
    /* n3 = 8 * Y_a^4 */

    /* Y_r */
    if (!BN_mod_sub_quick(n0, n2, &r->X, p))
        goto err;
    if (!ec_GFp_mont_field_mul(group, n0, n1, n0, ctx))
        goto err;
    if (!BN_mod_sub_quick(&r->Y, n0, n3, p))
        goto err;
    /* Y_r = n1 * (n2 - X_r) - n3 */

    ret = 1;

 err:
    BN_CTX_end(ctx);
    return ret;
}

int ec_GFp_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
{
    if (ec_GFp_simple_is_at_infinity(group, point) || BN_is_zero(&point->Y))
        /* point is its own inverse */
        return 1;

    return BN_usub(&point->Y, &group->field, &point->Y);
}

int ec_GFp_simple_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)
{
    return BN_is_zero(&point->Z);
}

int ec_GFp_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
                              BN_CTX *ctx)
{
    const BIGNUM *p;
    BIGNUM *rh, *tmp, *Z4, *Z6;
    int ret = -1;

    if (ec_GFp_simple_is_at_infinity(group, point))
        return 1;

    p = &group->field;

    if (ctx == NULL)
        return -1;

    BN_CTX_start(ctx);
    rh = BN_CTX_get(ctx);
    tmp = BN_CTX_get(ctx);
    Z4 = BN_CTX_get(ctx);
    Z6 = BN_CTX_get(ctx);
    if (Z6 == NULL)
        goto err;

    /*-
     * We have a curve defined by a Weierstrass equation
     *      y^2 = x^3 + a*x + b.
     * The point to consider is given in Jacobian projective coordinates
     * where  (X, Y, Z)  represents  (x, y) = (X/Z^2, Y/Z^3).
     * Substituting this and multiplying by  Z^6  transforms the above equation into
     *      Y^2 = X^3 + a*X*Z^4 + b*Z^6.
     * To test this, we add up the right-hand side in 'rh'.
     */

    /* rh := X^2 */
    if (!ec_GFp_mont_field_sqr(group, rh, &point->X, ctx))
        goto err;

    if (!point->Z_is_one) {
        if (!ec_GFp_mont_field_sqr(group, tmp, &point->Z, ctx))
            goto err;
        if (!ec_GFp_mont_field_sqr(group, Z4, tmp, ctx))
            goto err;
        if (!ec_GFp_mont_field_mul(group, Z6, Z4, tmp, ctx))
            goto err;

        /* rh := (rh + a*Z^4)*X */
        if (group->a_is_minus3) {
            if (!BN_mod_lshift1_quick(tmp, Z4, p))
                goto err;
            if (!BN_mod_add_quick(tmp, tmp, Z4, p))
                goto err;
            if (!BN_mod_sub_quick(rh, rh, tmp, p))
                goto err;
            if (!ec_GFp_mont_field_mul(group, rh, rh, &point->X, ctx))
                goto err;
        } else {
            if (!ec_GFp_mont_field_mul(group, tmp, Z4, &group->a, ctx))
                goto err;
            if (!BN_mod_add_quick(rh, rh, tmp, p))
                goto err;
            if (!ec_GFp_mont_field_mul(group, rh, rh, &point->X, ctx))
                goto err;
        }

        /* rh := rh + b*Z^6 */
        if (!ec_GFp_mont_field_mul(group, tmp, &group->b, Z6, ctx))
            goto err;
        if (!BN_mod_add_quick(rh, rh, tmp, p))
            goto err;
    } else {
        /* point->Z_is_one */

        /* rh := (rh + a)*X */
        if (!BN_mod_add_quick(rh, rh, &group->a, p))
            goto err;
        if (!ec_GFp_mont_field_mul(group, rh, rh, &point->X, ctx))
            goto err;
        /* rh := rh + b */
        if (!BN_mod_add_quick(rh, rh, &group->b, p))
            goto err;
    }

    /* 'lh' := Y^2 */
    if (!ec_GFp_mont_field_sqr(group, tmp, &point->Y, ctx))
        goto err;

    ret = (0 == BN_ucmp(tmp, rh));

 err:
    BN_CTX_end(ctx);
    return ret;
}

int ec_GFp_simple_points_make_affine(const EC_GROUP *group, SIZE_T num,
                                     EC_POINT **points, BN_CTX *ctx)
{
    BIGNUM *tmp, *tmp_Z;
    BIGNUM *prod_Z[256];
    SIZE_T i;
    int ret = 0;

    if (num == 0)
        return 1;
    else if (num > 256)
        return 0;
    BIGNUM prod_Z_st[256];
    if (ctx == NULL)
        return 0;

    BN_CTX_start(ctx);
    tmp = BN_CTX_get(ctx);
    tmp_Z = BN_CTX_get(ctx);
    if (tmp_Z == NULL)
        goto err;

    // printf("%s num %zd space %zd\n", __func__, num, sizeof(prod_Z_st));
    for (i = 0; i < num; i++) {
        prod_Z[i] = &prod_Z_st[i];
    }

    /*
     * Set each prod_Z[i] to the product of points[0]->Z .. points[i]->Z,
     * skipping any zero-valued inputs (pretend that they're 1).
     */

    if (!BN_is_zero(&points[0]->Z)) {
        if (!BN_copy(prod_Z[0], &points[0]->Z))
            goto err;
    } else {
        if (!ec_GFp_mont_field_set_to_one(group, prod_Z[0], ctx))
            goto err;
    }

    for (i = 1; i < num; i++) {
        if (!BN_is_zero(&points[i]->Z)) {
            if (!ec_GFp_mont_field_mul(group, prod_Z[i], prod_Z[i - 1], &points[i]->Z,
                                ctx))
                goto err;
        } else {
            if (!BN_copy(prod_Z[i], prod_Z[i - 1]))
                goto err;
        }
    }

    /*
     * Now use a single explicit inversion to replace every non-zero
     * points[i]->Z by its inverse.
     */

    if (!BN_mod_inverse(tmp, prod_Z[num - 1], &group->field, ctx)) {
        goto err;
    }
    {
        /*
         * In the Montgomery case, we just turned R*H (representing H) into
         * 1/(R*H), but we need R*(1/H) (representing 1/H); i.e. we need to
         * multiply by the Montgomery factor twice.
         */
        if (!ec_GFp_mont_field_encode(group, tmp, tmp, ctx))
            goto err;
        if (!ec_GFp_mont_field_encode(group, tmp, tmp, ctx))
            goto err;
    }

    for (i = num - 1; i > 0; --i) {
        /*
         * Loop invariant: tmp is the product of the inverses of points[0]->Z
         * .. points[i]->Z (zero-valued inputs skipped).
         */
        if (!BN_is_zero(&points[i]->Z)) {
            /*
             * Set tmp_Z to the inverse of points[i]->Z (as product of Z
             * inverses 0 .. i, Z values 0 .. i - 1).
             */
            if (!ec_GFp_mont_field_mul(group, tmp_Z, prod_Z[i - 1], tmp, ctx))
                goto err;
            /*
             * Update tmp to satisfy the loop invariant for i - 1.
             */
            if (!ec_GFp_mont_field_mul(group, tmp, tmp, &points[i]->Z, ctx))
                goto err;
            /* Replace points[i]->Z by its inverse. */
            if (!BN_copy(&points[i]->Z, tmp_Z))
                goto err;
        }
    }

    if (!BN_is_zero(&points[0]->Z)) {
        /* Replace points[0]->Z by its inverse. */
        if (!BN_copy(&points[0]->Z, tmp))
            goto err;
    }

    /* Finally, fix up the X and Y coordinates for all points. */

    for (i = 0; i < num; i++) {
        EC_POINT *p = points[i];

        if (!BN_is_zero(&p->Z)) {
            /* turn  (X, Y, 1/Z)  into  (X/Z^2, Y/Z^3, 1) */

            if (!ec_GFp_mont_field_sqr(group, tmp, &p->Z, ctx))
                goto err;
            if (!ec_GFp_mont_field_mul(group, &p->X, &p->X, tmp, ctx))
                goto err;

            if (!ec_GFp_mont_field_mul(group, tmp, tmp, &p->Z, ctx))
                goto err;
            if (!ec_GFp_mont_field_mul(group, &p->Y, &p->Y, tmp, ctx))
                goto err;

            if (!ec_GFp_mont_field_set_to_one(group, &p->Z, ctx))
                goto err;
            p->Z_is_one = 1;
        }
    }

    ret = 1;

 err:
    BN_CTX_end(ctx);
    return ret;
}

///////////////////////////////////////////////////////////////////////////////
int ec_GFp_mont_group_set_curve(EC_GROUP *group, const BIGNUM *p,
                                const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
    int ret = 0;

    if (ctx == NULL)
        return 0;

    BN_MONT_CTX_init(&group->mont_curve);
    if (!BN_MONT_CTX_set(&group->mont_curve, p, ctx)) {
        goto err;
    }
    if (!BN_to_montgomery(&group->one, BN_value_one(), &group->mont_curve, ctx))
        goto err;

    group->field_data1 = &group->mont_curve;
    group->field_data2 = &group->one; //BIGNUM

    ret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
 err:
    return ret;
}

int ec_GFp_mont_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
                          const BIGNUM *b, BN_CTX *ctx)
{
    if (group->field_data1 == NULL) {
        return 0;
    }

    return BN_mod_mul_montgomery(r, a, b, (BN_MONT_CTX *)group->field_data1, ctx);
}

int ec_GFp_mont_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
                          BN_CTX *ctx)
{
    if (group->field_data1 == NULL) {
        return 0;
    }

    return BN_mod_mul_montgomery(r, a, a, (BN_MONT_CTX *)group->field_data1, ctx);
}

int ec_GFp_mont_field_encode(const EC_GROUP *group, BIGNUM *r,
                             const BIGNUM *a, BN_CTX *ctx)
{
    if (group->field_data1 == NULL) {
        return 0;
    }

    return BN_to_montgomery(r, a, (BN_MONT_CTX *)group->field_data1, ctx);
}

int ec_GFp_mont_field_decode(const EC_GROUP *group, BIGNUM *r,
                             const BIGNUM *a, BN_CTX *ctx)
{
    if (group->field_data1 == NULL) {
        return 0;
    }

    return BN_from_montgomery(r, a, (BN_MONT_CTX *)group->field_data1, ctx);
}

int ec_GFp_mont_field_set_to_one(const EC_GROUP *group, BIGNUM *r,
                                 BN_CTX *ctx)
{
    if (group->field_data2 == NULL) {
        return 0;
    }

    if (!BN_copy(r, (const BIGNUM *)group->field_data2))
        return 0;
    return 1;
}

///////////////////////////////////////////////////////////////////////////////
/*
 * Determine the modified width-(w+1) Non-Adjacent Form (wNAF) of 'scalar'.
 * This is an array  r[]  of values that are either zero or odd with an
 * absolute value less than  2^w  satisfying
 *     scalar = \sum_j r[j]*2^j
 * where at most one of any  w+1  consecutive digits is non-zero
 * with the exception that the most significant digit may be only
 * w-1 zeros away from that next non-zero digit.
 */
signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, SIZE_T *ret_len, signed char* r)
{
    int window_val;
    int sign = 1;
    int bit, next_bit, mask;
    SIZE_T len = 0, j;

    if (BN_is_zero(scalar)) {
        r[0] = 0;
        *ret_len = 1;
        return r;
    }

    if (w <= 0 || w > 7) {      /* 'signed char' can represent integers with
                                 * absolute values less than 2^7 */
        goto err;
    }
    bit = 1 << w;               /* at most 128 */
    next_bit = bit << 1;        /* at most 256 */
    mask = next_bit - 1;        /* at most 255 */

    if (BN_is_negative(scalar)) {
        sign = -1;
    }

    len = BN_num_bits(scalar);
    if(len>256) {
        // printf("%s never here...\n", __func__);
        goto err;
    }
    // printf("%s %zd\n", __func__, len + 1);
    window_val = scalar->d[0] & mask;
    j = 0;
    while ((window_val != 0) || (j + w + 1 < len)) { /* if j+w+1 >= len,
                                                      * window_val will not
                                                      * increase */
        int digit = 0;

        /* 0 <= window_val <= 2^(w+1) */

        if (window_val & 1) {
            /* 0 < window_val < 2^(w+1) */

            if (window_val & bit) {
                digit = window_val - next_bit; /* -2^w < digit < 0 */

#if 1                           /* modified wNAF */
                if (j + w + 1 >= len) {
                    /*
                     * Special case for generating modified wNAFs:
                     * no new bits will be added into window_val,
                     * so using a positive digit here will decrease
                     * the total length of the representation
                     */

                    digit = window_val & (mask >> 1); /* 0 < digit < 2^w */
                }
#endif
            } else {
                digit = window_val; /* 0 < digit < 2^w */
            }

            if (digit <= -bit || digit >= bit || !(digit & 1)) {
                goto err;
            }

            window_val -= digit;

            /*
             * now window_val is 0 or 2^(w+1) in standard wNAF generation;
             * for modified window NAFs, it may also be 2^w
             */
            if (window_val != 0 && window_val != next_bit
                && window_val != bit) {
                goto err;
            }
        }

        r[j++] = sign * digit;

        window_val >>= 1;
        window_val += bit * BN_is_bit_set(scalar, j + w);

        if (window_val > next_bit) {
            goto err;
        }
    }

    if (j > len + 1) {
        goto err;
    }
    *ret_len = j;
    return r;

 err:
    return NULL;
}

///////////////////////////////////////////////////////////////////////////////

/*-
 * Compute
 *      \sum scalars[i]*points[i],
 * also including
 *      scalar*generator
 * in the addition if scalar != NULL
 */
int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                SIZE_T num, const EC_POINT *points[], const BIGNUM *scalars[],
                BN_CTX *ctx)
{
    SIZE_T totalnum;
    SIZE_T blocksize = 0, numblocks = 0; /* for wNAF splitting */
    SIZE_T pre_points_per_block = 0;
    SIZE_T i;
    int j;
    int k;
    int r_is_inverted = 0;
    int r_is_at_infinity = 1;
    SIZE_T wsize[256];       /* individual window sizes */
    signed char wNAF[32][8];  /* individual wNAFs */
    SIZE_T wNAF_len[256];
    SIZE_T max_len = 0;
    EC_POINT **val_sub[256]; /* pointers to sub-arrays of 'val' or
                                 * 'pre_comp->points' */
    const EC_PRE_COMP *pre_comp = &group->ec;
    int num_scalar = 0;         /* flag: will be set to 1 if 'scalar' must be
                                 * treated like other scalars, i.e.
                                 * precomputation is not available */
    int ret = 0;

    {
        {
            blocksize = pre_comp->blocksize;

            /*
             * determine maximum number of blocks that wNAF splitting may
             * yield (NB: maximum wNAF length is bit length plus one)
             */
            numblocks = (BN_num_bits(scalar) / blocksize) + 1;

            /*
             * we cannot use more blocks than we have precomputation for
             */
            if (numblocks > pre_comp->numblocks)
                numblocks = pre_comp->numblocks;

            pre_points_per_block = (SIZE_T)1 << (pre_comp->w - 1);

            /* check that pre_comp looks sane */
            if (pre_comp->num != (pre_comp->numblocks * pre_points_per_block)) {
                goto err;
            }
        }
    }

    totalnum = num + numblocks;

    // delete sth for precompute curve
    if (numblocks) {
        /* we go here iff scalar != NULL */

        if (pre_comp == NULL) {
            if (num_scalar != 1) {
                goto err;
            }
            /* we have already generated a wNAF for 'scalar' */
        } else {
            signed char tmp_wNAF_st[256], *tmp_wNAF = NULL;
            SIZE_T tmp_len = 0;

            if (num_scalar != 0) {
                goto err;
            }

            /*
             * use the window size for which we have precomputation
             */
            wsize[num] = pre_comp->w;
            tmp_wNAF = bn_compute_wNAF(scalar, wsize[num], &tmp_len, tmp_wNAF_st);
            if (!tmp_wNAF)
                goto err;
            // printf("tmp_len %zd max_len %zd\n", tmp_len, max_len);
            {
                /*
                 * don't include tmp_wNAF directly into wNAF array - use wNAF
                 * splitting and include the blocks
                 */

                signed char *pp;
                EC_POINT **tmp_points;

                if (tmp_len < numblocks * blocksize) {
                    /*
                     * possibly we can do with fewer blocks than estimated
                     */
                    numblocks = (tmp_len + blocksize - 1) / blocksize;
                    if (numblocks > pre_comp->numblocks) {
                        goto err;
                    }
                    totalnum = num + numblocks;
                }

                /* split wNAF in 'numblocks' parts */
                pp = tmp_wNAF;
                tmp_points = (EC_POINT **)pre_comp->points;

                for (i = num; i < totalnum; i++) {
                    if (i < totalnum - 1) {
                        wNAF_len[i] = blocksize;
                        if (tmp_len < blocksize) {
                            goto err;
                        }
                        tmp_len -= blocksize;
                    } else
                        /*
                         * last block gets whatever is left (this could be
                         * more or less than 'blocksize'!)
                         */
                        wNAF_len[i] = tmp_len;

                    if (wNAF[i] == NULL) {
                        goto err;
                    }
                    for (j = 0; j < wNAF_len[i]; j++)
                        wNAF[i][j] = pp[j];
                    // memcpy(wNAF[i], pp, wNAF_len[i]);
                    if (wNAF_len[i] > max_len)
                        max_len = wNAF_len[i];

                    if (*tmp_points == NULL) {
                        goto err;
                    }
                    val_sub[i] = tmp_points;
                    tmp_points += pre_points_per_block;
                    pp += blocksize;
                }
            }
        }
    }
    // delete sth for precompute curve
    r_is_at_infinity = 1;

    for (k = max_len - 1; k >= 0; k--) {
        if (!r_is_at_infinity) {
            if (!ec_GFp_simple_dbl(group, r, r, ctx))
                goto err;
        }

        for (i = 0; i < totalnum; i++) {
            if (wNAF_len[i] > (SIZE_T)k) {
                int digit = wNAF[i][k];
                int is_neg;

                if (digit) {
                    is_neg = digit < 0;

                    if (is_neg)
                        digit = -digit;

                    if (is_neg != r_is_inverted) {
                        if (!r_is_at_infinity) {
                            if (!ec_GFp_simple_invert(group, r, ctx))
                                goto err;
                        }
                        r_is_inverted = !r_is_inverted;
                    }

                    /* digit > 0 */

                    if (r_is_at_infinity) {
                        if (!EC_POINT_copy(r, val_sub[i][digit >> 1]))
                            goto err;
                        r_is_at_infinity = 0;
                    } else {
                        if (!ec_GFp_simple_add
                            (group, r, r, val_sub[i][digit >> 1], ctx))
                            goto err;
                    }
                }
            }
        }
    }

    if (r_is_at_infinity) {
        if (!ec_GFp_simple_point_set_to_infinity(group, r))
            goto err;
    } else {
        if (r_is_inverted)
            if (!ec_GFp_simple_invert(group, r, ctx))
                goto err;
    }

    ret = 1;

 err:
    return ret;
}

unsigned char coordinates_bin[] = {
  0x91, 0x16, 0x7a, 0x5e, 0xe1, 0xc1, 0x3b, 0x05, 0xd6, 0xa1, 0xed, 0x99,
  0xac, 0x24, 0xc3, 0xc3, 0x3e, 0x79, 0x81, 0xed, 0xdc, 0xa6, 0xc0, 0x50,
  0x61, 0x32, 0x89, 0x90, 0xf4, 0x18, 0x02, 0x9e, 0x63, 0xcd, 0x65, 0xd4,
  0x81, 0xd7, 0x35, 0xbd, 0x8d, 0x4c, 0xfb, 0x06, 0x6e, 0x2a, 0x48, 0xf8,
  0xc1, 0xf5, 0xe5, 0x78, 0x8d, 0x32, 0x95, 0xfa, 0xc1, 0x35, 0x4e, 0x59,
  0x3c, 0x2d, 0x0d, 0xdd, 0x30, 0x19, 0xfd, 0x6b, 0xfe, 0x88, 0x7c, 0x64,
  0x0a, 0x26, 0x5a, 0x30, 0x8c, 0xeb, 0x4a, 0x0a, 0x26, 0x76, 0x52, 0x89,
  0xdb, 0x4f, 0x0a, 0x0d, 0x1c, 0xda, 0x54, 0xfd, 0xab, 0x58, 0x9e, 0x4a,
  0x28, 0xad, 0x34, 0x78, 0x5b, 0xb3, 0xfb, 0xb4, 0xcc, 0x49, 0x6b, 0xfa,
  0x6d, 0xc1, 0x3c, 0x97, 0xf4, 0x0a, 0xa5, 0x2b, 0x87, 0xcb, 0xce, 0x60,
  0x0a, 0x10, 0xfb, 0xe9, 0x4b, 0x2f, 0xc1, 0x90, 0x0f, 0x44, 0x3e, 0xf3,
  0x63, 0xf8, 0x75, 0xb9, 0x7a, 0xd3, 0x54, 0xbf, 0x1e, 0xf5, 0xf4, 0xc5,
  0x15, 0xaa, 0x58, 0xf2, 0x21, 0xdf, 0xcc, 0x53, 0x9a, 0x57, 0x56, 0x33,
  0x6a, 0x9c, 0x81, 0x62, 0x7b, 0x41, 0x52, 0x76, 0x14, 0x2a, 0x67, 0x68,
  0xb1, 0x82, 0x6a, 0x4c, 0x36, 0x22, 0x58, 0xef, 0xb3, 0x0f, 0x4b, 0xbd,
  0xe3, 0x60, 0x7d, 0x18, 0x2e, 0x81, 0xd6, 0x8f, 0xd3, 0x45, 0x01, 0x33,
  0xbb, 0xf4, 0x92, 0xe0, 0xd9, 0xfb, 0xec, 0x28, 0x84, 0xee, 0x5b, 0x69,
  0xac, 0xfe, 0x18, 0xc5, 0x0b, 0x89, 0x41, 0x93, 0x07, 0x13, 0x25, 0x20,
  0xaa, 0x35, 0x31, 0xc7, 0x81, 0xf0, 0x67, 0x84, 0x2b, 0xa0, 0x5a, 0x8f,
  0x3b, 0x84, 0xd7, 0x77, 0x96, 0xc9, 0xb9, 0x92, 0x2b, 0xd9, 0x9b, 0xaf,
  0x0e, 0x44, 0x9a, 0x2e, 0x75, 0x7a, 0x01, 0xb8, 0x31, 0x3a, 0x35, 0xc1,
  0xe5, 0xf6, 0x18, 0x6d, 0x77, 0xd8, 0x87, 0x40, 0x46, 0x95, 0x22, 0xc8,
  0x39, 0x25, 0xbf, 0x83, 0xb4, 0x86, 0x69, 0xb4, 0x8e, 0x5e, 0x04, 0x95,
  0xab, 0x21, 0xaf, 0x8f, 0x98, 0xe7, 0x95, 0xc3, 0x30, 0xfb, 0xde, 0x86,
  0x82, 0x2a, 0x6c, 0x24, 0x32, 0x69, 0x7f, 0x4c, 0x5d, 0xc1, 0x11, 0x65,
  0x53, 0xa6, 0xe9, 0x69, 0x63, 0xc5, 0x63, 0xa8, 0x3a, 0xff, 0x44, 0x28,
  0x8f, 0xbf, 0x8b, 0x5b, 0x98, 0x7b, 0x04, 0xce, 0x48, 0x3d, 0xa1, 0x68,
  0xe0, 0xd8, 0x71, 0xc8, 0xd9, 0x0c, 0x19, 0xfd, 0x8a, 0x50, 0x92, 0x67,
  0x75, 0x57, 0xc8, 0xc7, 0xc6, 0xaf, 0xfc, 0x01, 0x2b, 0x25, 0x2a, 0xd0,
  0x34, 0x21, 0xe1, 0x15, 0x52, 0x83, 0x98, 0xa7, 0x98, 0x64, 0x1e, 0xc2,
  0x9b, 0xfe, 0xa2, 0xdb, 0x9f, 0x2c, 0x58, 0x7d, 0x5d, 0xd8, 0x40, 0x21,
  0x15, 0xb7, 0x06, 0x1e, 0x72, 0xd6, 0xf9, 0xb3, 0xc1, 0x07, 0x29, 0xbf,
  0x3c, 0x80, 0xc9, 0xd0, 0x10, 0xa7, 0x3e, 0x5c, 0x66, 0x7b, 0xa9, 0x1d,
  0xe1, 0xbc, 0x2b, 0x2e, 0x7d, 0xa2, 0xbd, 0xfd, 0x89, 0xc4, 0x69, 0x41,
  0x34, 0xe5, 0x1c, 0x6a, 0x80, 0x00, 0xfe, 0x4e, 0x45, 0xfa, 0x50, 0x8a,
  0x85, 0x18, 0x92, 0x60, 0x16, 0x7e, 0xe1, 0x1b, 0x26, 0xec, 0x55, 0xf9,
  0xae, 0xf0, 0x9e, 0xb4, 0x3e, 0xa3, 0x50, 0x52, 0x4f, 0xad, 0xeb, 0xbe,
  0xc7, 0xf5, 0xc6, 0x4d, 0x0d, 0xf8, 0x94, 0x11, 0x46, 0x0e, 0xfe, 0xf1,
  0x25, 0x86, 0x69, 0x11, 0xcf, 0xdd, 0xf2, 0x21, 0x9c, 0x14, 0xe3, 0x8a,
  0xbb, 0xb2, 0xce, 0x1f, 0xf3, 0x48, 0x93, 0x43, 0xdd, 0xe9, 0x7d, 0x4d,
  0x2c, 0x5c, 0x1e, 0x9e, 0x78, 0x78, 0xb7, 0x81, 0xdf, 0x91, 0x5a, 0xe2,
  0x36, 0x88, 0x59, 0x47, 0xd9, 0xbe, 0x66, 0xa8, 0xcd, 0xd2, 0x74, 0xa1,
  0xf7, 0x13, 0xf3, 0x0e, 0x73, 0xae, 0x83, 0x26, 0x0e, 0x14, 0x31, 0xa0,
  0xd6, 0x35, 0xa5, 0x84, 0x98, 0xe7, 0x95, 0x65, 0x84, 0x72, 0x6c, 0xe7,
  0xb2, 0x2b, 0x90, 0x89, 0xc0, 0x57, 0x30, 0x9c, 0xe9, 0x73, 0x0a, 0xaa,
  0xfd, 0x12, 0x01, 0x34, 0xa3, 0x16, 0xfa, 0x44, 0x23, 0x3b, 0x3c, 0x6d,
  0x46, 0xe5, 0xeb, 0xb1, 0x91, 0x24, 0xb6, 0x84, 0x64, 0x19, 0x8d, 0xdf,
  0x03, 0x6a, 0xb1, 0xae, 0xbd, 0x38, 0x70, 0x23, 0xe8, 0x34, 0xff, 0xa6,
  0xb0, 0x45, 0xcc, 0xcb, 0x83, 0x66, 0xb5, 0x8a, 0xda, 0x8c, 0xb8, 0xab,
  0x01, 0x5a, 0x99, 0xb5, 0xc0, 0xba, 0xe0, 0xad, 0xb9, 0x64, 0x8a, 0x36,
  0x63, 0x77, 0x8b, 0xfc, 0x3d, 0xfd, 0xc2, 0x28, 0x78, 0xb5, 0x22, 0x3f,
  0x33, 0x2e, 0xa7, 0x2d, 0x75, 0x3c, 0xf9, 0x06, 0x44, 0x79, 0x46, 0x8e,
  0x41, 0xe7, 0x1f, 0xc8, 0xc5, 0xe0, 0x0e, 0x5f, 0x74, 0xef, 0x8e, 0xf4,
  0x41, 0x64, 0xce, 0xbd, 0x33, 0x28, 0xa5, 0x1c, 0xee, 0x69, 0x56, 0x3d,
  0xb9, 0x6b, 0xd2, 0x98, 0xfa, 0xc3, 0x1d, 0x00, 0x9d, 0x2f, 0x05, 0x46,
  0xaa, 0xc3, 0xa6, 0x55, 0xfe, 0xfc, 0x54, 0xb5, 0x57, 0x7d, 0xae, 0x35,
  0x83, 0x3a, 0x54, 0x43, 0x6e, 0x42, 0x3d, 0xa6, 0x45, 0xf2, 0x9a, 0x84,
  0x40, 0x47, 0xcc, 0xb6, 0x65, 0x7f, 0x4b, 0xa5, 0xa9, 0x98, 0x01, 0x0b,
  0x5e, 0x19, 0x09, 0x8e, 0x43, 0x19, 0x5f, 0x4e, 0x3e, 0x6c, 0xf6, 0x33,
  0x80, 0x4b, 0x30, 0xd1, 0xa8, 0x75, 0xad, 0x01, 0xd9, 0x47, 0x9c, 0x4a,
  0x20, 0x08, 0x65, 0x3e, 0xc7, 0xe1, 0x13, 0x95, 0x62, 0xe6, 0x44, 0x75,
  0xad, 0x1c, 0xac, 0x22, 0xb2, 0xef, 0x49, 0x56, 0xac, 0xd3, 0x0b, 0xd1,
  0x02, 0x67, 0x57, 0x59, 0xc2, 0x78, 0x45, 0x8d, 0x74, 0xc4, 0x5d, 0xbe,
  0xf7, 0xb8, 0x41, 0x0b, 0x58, 0xb3, 0xef, 0x6e, 0xb6, 0xb0, 0x6e, 0x46,
  0x02, 0x2b, 0xc0, 0xf0, 0x1c, 0xdb, 0x20, 0x3d, 0x64, 0xe9, 0xc2, 0x41,
  0xda, 0x31, 0xde, 0x06, 0xbd, 0x83, 0xe2, 0x0b, 0xa7, 0x2e, 0x97, 0x4c,
  0x26, 0xc7, 0xf2, 0x44, 0x76, 0xa1, 0x64, 0xbe, 0x6a, 0x00, 0x9d, 0xeb,
  0xfb, 0x3e, 0x5a, 0x1c, 0xb9, 0xcf, 0x98, 0xb1, 0x12, 0x43, 0x02, 0x6d,
  0xa1, 0x50, 0x4f, 0x91, 0xb1, 0x68, 0xa4, 0x84, 0x5e, 0xec, 0x4f, 0xcb,
  0x55, 0xc0, 0x60, 0x1f, 0xdc, 0xf3, 0x20, 0x03, 0x90, 0xbb, 0x14, 0x10,
  0x00, 0x31, 0x6d, 0x22, 0x79, 0xd3, 0xd8, 0xdc, 0x44, 0xef, 0x5d, 0xd8,
  0x34, 0x19, 0x86, 0x7f, 0x78, 0x72, 0x29, 0xcc, 0xb8, 0xa2, 0x33, 0xc3,
  0xc9, 0x18, 0x48, 0xac, 0xbb, 0x22, 0xe5, 0x70, 0xa3, 0x1a, 0xbf, 0x17,
  0xfc, 0x44, 0xe7, 0x60, 0x76, 0x8c, 0x86, 0x58, 0x0e, 0xd6, 0x60, 0x5c,
  0x62, 0xad, 0x01, 0x25, 0x83, 0x5d, 0x22, 0x64, 0x91, 0x91, 0x0c, 0x3a,
  0x7e, 0xd1, 0x25, 0xcf, 0x46, 0xa2, 0x10, 0x33, 0x57, 0xf0, 0x0a, 0x7d,
  0x4a, 0xef, 0xda, 0x2d, 0x2a, 0x06, 0xc2, 0x42, 0x8c, 0xad, 0x8f, 0x87,
  0x5e, 0xce, 0xc6, 0xee, 0xf0, 0x53, 0x07, 0xa3, 0xa7, 0x49, 0x3b, 0x8b,
  0xad, 0xf5, 0xb4, 0xdb, 0xd2, 0x4e, 0x02, 0x0b, 0x15, 0xed, 0x1b, 0x93,
  0x55, 0x3e, 0xee, 0xc1, 0x0b, 0x7f, 0x0e, 0x4a, 0x54, 0x11, 0x65, 0xd2,
  0x2a, 0xd7, 0x99, 0x1f, 0x75, 0x79, 0xe9, 0x73, 0x7b, 0x36, 0x65, 0xd7,
  0x6c, 0xe6, 0x98, 0x9d, 0x82, 0xab, 0x62, 0xbb, 0x8b, 0xbc, 0x6a, 0xff,
  0xc1, 0xc0, 0x65, 0x0c, 0x8a, 0x7b, 0x24, 0x58, 0x55, 0x77, 0x69, 0x51,
  0xb2, 0x20, 0xdc, 0x06, 0xf8, 0xc3, 0xaf, 0x86, 0x2b, 0xf0, 0x0f, 0xdc,
  0xb2, 0x96, 0xa0, 0x38, 0x0a, 0x18, 0xda, 0x53, 0x70, 0x12, 0x87, 0xaa,
  0x7e, 0x9e, 0x85, 0x10, 0x77, 0xc5, 0xba, 0xbc, 0x80, 0x24, 0x52, 0xee,
  0x48, 0x81, 0x64, 0x0c, 0x6e, 0x38, 0x79, 0xa2, 0x83, 0x04, 0x2b, 0xa7,
  0x16, 0x40, 0x79, 0xc9, 0xec, 0x25, 0x04, 0x55, 0x11, 0xc0, 0x92, 0x89,
  0xad, 0x69, 0xf7, 0xc9, 0x50, 0x16, 0x88, 0xc6, 0x15, 0x80, 0x0c, 0xdb,
  0xe0, 0x33, 0x82, 0x89, 0x02, 0xda, 0x35, 0x2c, 0xb7, 0x4b, 0xe7, 0xe9,
  0x7a, 0x77, 0x59, 0xa6, 0x70, 0x88, 0xf3, 0x60, 0xfe, 0xb5, 0x63, 0xbe,
  0x34, 0xc1, 0x65, 0x78, 0x8c, 0x12, 0xff, 0x18, 0x9d, 0x51, 0xa8, 0x5b,
  0xac, 0x43, 0x7f, 0x45, 0x77, 0x38, 0x28, 0xbf, 0x8a, 0xe8, 0x2a, 0x1c,
  0xc2, 0x16, 0xcf, 0x37, 0x2b, 0xa4, 0x6a, 0x66, 0xb2, 0xe3, 0x7f, 0x7c,
  0x03, 0x3c, 0x18, 0x6e, 0x3e, 0x49, 0x53, 0xdb, 0xcd, 0xc6, 0xeb, 0x5a,
  0x0c, 0xda, 0x87, 0x33, 0x9d, 0x93, 0x53, 0xb6, 0xc6, 0x70, 0x69, 0x66,
  0xb4, 0xd3, 0xcd, 0x58, 0x30, 0x04, 0x85, 0x69, 0xc5, 0xe7, 0xa6, 0xfa,
  0x45, 0xaf, 0x4e, 0x6d, 0x54, 0x08, 0x54, 0x71, 0xb1, 0xc0, 0x02, 0x7b,
  0x9e, 0xfe, 0xe7, 0x04, 0x7e, 0x17, 0x54, 0xb8, 0xea, 0x3c, 0x80, 0x99,
  0xf9, 0xff, 0xcf, 0x90, 0x3a, 0x1d, 0xb9, 0x15, 0x17, 0x98, 0x2a, 0x8c,
  0xd0, 0xb6, 0xaf, 0x13, 0x84, 0x9f, 0x3f, 0x23, 0xd2, 0xc2, 0x00, 0x14,
  0xf3, 0xae, 0x8e, 0x79, 0x1a, 0xa4, 0x4c, 0xe9, 0xc5, 0xa5, 0x22, 0x5a,
  0x80, 0x14, 0x35, 0x7e, 0x0c, 0xab, 0xcc, 0xfd, 0x1d, 0xc3, 0x5d, 0x34,
  0x38, 0x50, 0xcc, 0x05, 0xd2, 0x02, 0x85, 0x3b, 0x60, 0xaa, 0x5c, 0x14,
  0xbf, 0x1f, 0xba, 0x37, 0xb1, 0xd0, 0xf4, 0x6a, 0x1d, 0x62, 0x5b, 0xa1,
  0xc9, 0xe5, 0xda, 0x54, 0xcf, 0x3f, 0x91, 0xb3, 0xc9, 0x53, 0x84, 0xb1,
  0xa3, 0xce, 0xf9, 0x20, 0x3a, 0x84, 0x44, 0xb4, 0xa6, 0x31, 0xd5, 0x53,
  0xb6, 0x30, 0x01, 0xaf, 0x22, 0x09, 0x2b, 0x39, 0xbe, 0xb1, 0x21, 0x60,
  0x10, 0x87, 0x65, 0xb3, 0xc5, 0xcf, 0xf0, 0x77, 0x76, 0x0e, 0xe8, 0x46,
  0x02, 0x28, 0x34, 0x6f, 0xaf, 0x48, 0xf8, 0x6b, 0x3b, 0xa7, 0x38, 0xcb,
  0x22, 0x80, 0xff, 0x0c, 0x7c, 0xa3, 0xf6, 0x04, 0xe6, 0xcb, 0xfb, 0x54,
  0x60, 0xd3, 0x38, 0xa3, 0x93, 0x40, 0xca, 0xc4, 0x0a, 0xf3, 0xd4, 0x3a,
  0xcc, 0x26, 0xb8, 0xa9, 0xa3, 0x53, 0x1d, 0x3a, 0x4d, 0x84, 0x25, 0xa8,
  0x3b, 0x8a, 0x01, 0xb5, 0x2d, 0x4c, 0x4e, 0xee, 0x0f, 0xa0, 0x89, 0xaf,
  0x13, 0x55, 0xc4, 0x12, 0x4c, 0x75, 0x6c, 0x70, 0x7f, 0xb6, 0x56, 0x25,
  0xa8, 0x24, 0x29, 0x95, 0xaa, 0x86, 0x3f, 0x01, 0xec, 0x49, 0xa0, 0xc8,
  0xd5, 0x11, 0xa7, 0x97, 0x92, 0xc0, 0xf8, 0x58, 0x6e, 0xeb, 0xe1, 0x1b,
  0x7e, 0xbd, 0x9e, 0xea, 0xf2, 0xd8, 0x52, 0x99, 0xbe, 0x9e, 0x11, 0x9c,
  0xd0, 0x57, 0xa4, 0x7b, 0xdb, 0x5b, 0xd5, 0xb6, 0x39, 0x89, 0x56, 0xa8,
  0x06, 0x65, 0x09, 0x20, 0x29, 0x0c, 0xed, 0x58, 0x83, 0x05, 0x62, 0x4e,
  0xaa, 0xdb, 0x3d, 0xae, 0xaa, 0xea, 0x2e, 0x53, 0xe4, 0x6b, 0x90, 0xd1,
  0xdf, 0x3e, 0x29, 0x68, 0x72, 0xf7, 0xe7, 0xcd, 0x05, 0x36, 0x39, 0x15,
  0x47, 0x83, 0x09, 0x5c, 0x7c, 0x5f, 0xc0, 0x39, 0xd2, 0x64, 0xd6, 0xec,
  0x8b, 0x05, 0xa5, 0x53, 0xc5, 0xbb, 0x48, 0xdc, 0x51, 0xfa, 0x7d, 0x6b,
  0x7f, 0x1b, 0x9b, 0x18, 0xa3, 0xa2, 0x4b, 0x5c, 0xf0, 0xc7, 0x3b, 0xbb,
  0xc5, 0x45, 0x44, 0x39, 0xc6, 0xaa, 0xb9, 0x6e, 0x95, 0xbf, 0x66, 0x47,
  0x38, 0xe0, 0x2e, 0xb6, 0x85, 0x3b, 0x9b, 0xab, 0xdf, 0x5d, 0xa3, 0x93,
  0xb1, 0x49, 0xf5, 0x64, 0x12, 0x3c, 0xaa, 0xf2, 0xe9, 0x37, 0x1f, 0x83,
  0xbb, 0x21, 0xb7, 0x64, 0x60, 0x31, 0xa5, 0xea, 0xe3, 0xab, 0xed, 0x6a,
  0xd3, 0xdd, 0xb9, 0x45, 0x2c, 0x21, 0x47, 0x4c, 0x26, 0xbf, 0xac, 0xb3,
  0xf0, 0xc2, 0x47, 0x83, 0xf3, 0x57, 0x99, 0x9b, 0xad, 0xfe, 0x0c, 0x1a,
  0xd9, 0x8e, 0x9b, 0x6f, 0x88, 0x2c, 0x33, 0x71, 0x85, 0x2e, 0xb6, 0xf5,
  0x1a, 0xac, 0x2f, 0x08, 0x81, 0x30, 0x6b, 0x71, 0x6d, 0xb3, 0xb6, 0x8b,
  0x8a, 0xfc, 0x2a, 0x09, 0x1b, 0xe1, 0xe8, 0xd7, 0xfb, 0x01, 0x61, 0x31,
  0x19, 0xff, 0x36, 0x0f, 0xd6, 0xd7, 0x2c, 0x0a, 0x0c, 0x0f, 0xe3, 0x85,
  0x34, 0x5c, 0xcd, 0xef, 0x6a, 0x65, 0xfd, 0xa8, 0x4e, 0x1d, 0x5d, 0x9a,
  0x3a, 0x83, 0x9a, 0xa5, 0xab, 0x80, 0xa2, 0x0e, 0xd7, 0xb8, 0xb4, 0xe7,
  0xe5, 0x1c, 0xc6, 0x7e, 0x25, 0xbe, 0xc2, 0x66, 0x05, 0x25, 0x9b, 0xf1,
  0xe2, 0xf2, 0x7e, 0x91, 0x02, 0x5b, 0x45, 0xe1, 0xad, 0x7a, 0xbe, 0x5a,
  0x81, 0x22, 0x94, 0x1a, 0x35, 0x25, 0xe3, 0x10, 0x50, 0xd4, 0x59, 0xea,
  0x5d, 0xb7, 0xdd, 0x71, 0x0c, 0x06, 0x5c, 0xfa, 0xbf, 0x7e, 0x9c, 0x55,
  0x50, 0xb6, 0x6f, 0xec, 0x4a, 0x75, 0xfa, 0xb5, 0x9c, 0xc1, 0x6d, 0xbc,
  0xa6, 0xd7, 0x67, 0xca, 0x8f, 0xfd, 0x71, 0xb1, 0x06, 0x6c, 0x37, 0x65,
  0xef, 0xcc, 0x1c, 0x24, 0xc7, 0xae, 0xba, 0x80, 0x12, 0x2d, 0x92, 0xfa,
  0x2e, 0x0e, 0x29, 0x3c, 0xbe, 0x10, 0x50, 0x17, 0xfc, 0x71, 0x77, 0x62,
  0x40, 0xd2, 0x88, 0x0f, 0x26, 0x20, 0x15, 0x7e, 0x78, 0xd6, 0x48, 0xf0,
  0xc6, 0xf0, 0xa0, 0x06, 0x8a, 0xe6, 0x6f, 0x00, 0x18, 0xfc, 0xb8, 0xd2,
  0xc9, 0xa9, 0xca, 0x15, 0x83, 0xfa, 0x0a, 0x23, 0xdf, 0xfc, 0x1c, 0x55,
  0x5e, 0x4f, 0xa7, 0x00, 0x2d, 0x5c, 0xd4, 0xec, 0xb3, 0x20, 0xf2, 0x14,
  0x85, 0x41, 0x16, 0xf4, 0xea, 0xfe, 0xea, 0x88, 0xc7, 0x4b, 0xa6, 0xeb,
  0x32, 0xdb, 0x31, 0x40, 0x2b, 0xc0, 0x30, 0xfb, 0x95, 0x72, 0x72, 0xbe,
  0xd6, 0xeb, 0xa1, 0x7d, 0x9d, 0xa9, 0x32, 0x6c, 0xe3, 0x01, 0x8c, 0x30,
  0x99, 0x9b, 0x97, 0x39, 0x14, 0x3c, 0xfa, 0x5f, 0x28, 0xda, 0x03, 0xf2,
  0xfd, 0x8d, 0x02, 0x13, 0x45, 0x90, 0x47, 0x88, 0x19, 0x08, 0xe5, 0x16,
  0x5e, 0xdc, 0x82, 0xc4, 0xee, 0x7d, 0x52, 0x90, 0x4a, 0x17, 0x60, 0xcd,
  0x8c, 0xbb, 0xc0, 0x3a, 0x84, 0x45, 0xd9, 0x6d, 0x0c, 0xca, 0x3a, 0x4f,
  0xae, 0x4d, 0xa5, 0xb3, 0x91, 0x12, 0x79, 0xd8, 0x71, 0x5c, 0x8b, 0x1a,
  0xc5, 0x87, 0x18, 0xa2, 0x45, 0xa3, 0xd9, 0xe0, 0xb9, 0x77, 0x3d, 0x44,
  0x2a, 0x03, 0xf5, 0xec, 0x97, 0x1b, 0xff, 0x69, 0x94, 0x93, 0x94, 0xfb,
  0x58, 0xd4, 0xbd, 0x3c, 0xc0, 0x20, 0xad, 0x25, 0xe8, 0x5f, 0xc4, 0xcb,
  0xa3, 0xf1, 0x18, 0x9e, 0xb4, 0x67, 0xe3, 0x4d, 0xd3, 0xd7, 0x0c, 0xde,
  0x40, 0xfa, 0x86, 0x40, 0x7e, 0x3e, 0xfa, 0x98, 0xae, 0x24, 0x5e, 0x10,
  0x1b, 0x59, 0xdc, 0xe0, 0x23, 0x99, 0xd2, 0xac, 0x4f, 0x36, 0x80, 0x6f,
  0xca, 0x79, 0xcd, 0xa6, 0x93, 0x34, 0x31, 0x1e, 0x50, 0xfd, 0x7a, 0x16,
  0x6d, 0x40, 0x12, 0x3c, 0x74, 0x41, 0xd9, 0x27, 0xba, 0x41, 0xde, 0xd8,
  0xf9, 0xa5, 0x36, 0x6b, 0x90, 0xb2, 0x64, 0x21, 0xc4, 0x77, 0x6c, 0xb4,
  0xcc, 0xda, 0x43, 0x98, 0x78, 0x58, 0x53, 0xe1, 0xe1, 0xca, 0x0a, 0x24,
  0xb0, 0x03, 0x1f, 0xb1, 0x08, 0x2b, 0x04, 0xf9, 0xfe, 0xb6, 0x4b, 0x5e,
  0x02, 0x7b, 0x3c, 0x06, 0x43, 0x20, 0x8c, 0x51, 0x8d, 0xa8, 0xdc, 0xd9,
  0x3e, 0x12, 0x32, 0xa3, 0x01, 0x9e, 0x8e, 0x2b, 0x0e, 0x4c, 0x04, 0x14,
  0x1d, 0x54, 0xb0, 0x41, 0x3d, 0x57, 0x4a, 0xa4, 0xd0, 0xa3, 0x77, 0x4a,
  0x70, 0x16, 0xda, 0x7c, 0xca, 0x95, 0x49, 0xef, 0x60, 0x59, 0xf0, 0x79,
  0x88, 0xc4, 0x72, 0x14, 0x96, 0x0e, 0x2d, 0x22, 0xec, 0xb8, 0xf9, 0x2d,
  0x0c, 0xf4, 0xef, 0xe5, 0xbf, 0x16, 0xc5, 0xf1, 0x71, 0xd1, 0x44, 0xa5,
  0xb7, 0xc2, 0x0c, 0xc2, 0x0a, 0xfe, 0xdf, 0x2b, 0x2d, 0x74, 0x4d, 0xef,
  0xa3, 0xfe, 0xee, 0xc1, 0xd5, 0x1c, 0x95, 0xf6, 0x1d, 0x00, 0x1c, 0xab,
  0x3f, 0x2f, 0x33, 0xfa, 0xdf, 0xa6, 0x12, 0x56, 0x8b, 0xf1, 0xab, 0x6c,
  0x54, 0x2a, 0xf4, 0x2d, 0x69, 0x55, 0xbb, 0x69, 0x9f, 0x96, 0x2e, 0xc5,
  0xb5, 0x59, 0xe3, 0x4d, 0x67, 0x4d, 0x10, 0xcf, 0xdf, 0x74, 0x7f, 0x44,
  0x87, 0x4d, 0x0e, 0x57, 0xb4, 0x2e, 0xb5, 0x1c, 0xb4, 0x23, 0x7b, 0xe0,
  0xf5, 0x08, 0x92, 0x78, 0xdf, 0xd7, 0xf3, 0x9b, 0x32, 0x14, 0x01, 0x95,
  0x73, 0xd1, 0x04, 0x9e, 0x35, 0xb1, 0xba, 0xdb, 0xcd, 0x70, 0xc0, 0x3e,
  0x3b, 0x57, 0xc9, 0x21, 0xa1, 0xcc, 0x5c, 0x2f, 0x0e, 0x71, 0x12, 0x49,
  0xe3, 0xcc, 0x6c, 0x78, 0xa0, 0xa3, 0x0f, 0xbb, 0x57, 0x3c, 0x9a, 0xaf,
  0xc8, 0x25, 0x8f, 0xf8, 0xaf, 0xa4, 0x5b, 0x10, 0xf2, 0x87, 0x2b, 0x3a,
  0xbb, 0x46, 0xe3, 0xc6, 0x94, 0xe9, 0x8c, 0x48, 0x43, 0xa5, 0xfe, 0xbb,
  0x88, 0x2b, 0x28, 0x6a, 0x93, 0x84, 0xdc, 0x1e, 0x21, 0x30, 0xcf, 0xa7,
  0xfa, 0x30, 0x6a, 0x44, 0x2e, 0x30, 0x66, 0x2c, 0x3c, 0x70, 0x81, 0x20,
  0xf1, 0x56, 0x6d, 0x63, 0x9f, 0x1c, 0x4c, 0x91, 0x05, 0x60, 0x01, 0xc9,
  0x5b, 0x26, 0x14, 0x29, 0x0d, 0xaf, 0x31, 0x99, 0x0e, 0x2e, 0xeb, 0x53,
  0xa3, 0x55, 0xd4, 0x89, 0x0b, 0xfd, 0xe0, 0xe6, 0xd5, 0x3c, 0x9e, 0x66,
  0x9c, 0xca, 0x33, 0x98, 0x68, 0x6c, 0x1a, 0x8e, 0x4f, 0x57, 0xf7, 0x72,
  0xf8, 0x9b, 0x3b, 0xae, 0x5b, 0x35, 0x20, 0x5f, 0x8d, 0xcf, 0xb3, 0xbc,
  0x1f, 0xcb, 0x39, 0xc9, 0x37, 0x06, 0xfe, 0x93, 0xe5, 0xd1, 0xec, 0x7a,
  0x5b, 0x26, 0x19, 0xfb, 0xd4, 0x80, 0x9d, 0x96, 0xf6, 0xe2, 0x88, 0x21,
  0x2c, 0x5a, 0x7e, 0xe6, 0x1b, 0x5b, 0x73, 0x31, 0xcd, 0x72, 0x47, 0xea,
  0x79, 0x97, 0xe8, 0x14, 0xbb, 0x64, 0xbf, 0xaf, 0x11, 0x69, 0xbb, 0xa9,
  0x94, 0xc8, 0x2f, 0xbb, 0xe4, 0x5d, 0xa1, 0x30, 0xa5, 0x62, 0x38, 0xeb,
  0x05, 0x81, 0xeb, 0xc6, 0x8d, 0xeb, 0x86, 0x25, 0xfe, 0x16, 0xdc, 0x93,
  0x98, 0x21, 0xce, 0xc3, 0xaa, 0xf5, 0x9d, 0x68, 0x92, 0xbc, 0x52, 0x1f,
  0x13, 0xcb, 0x48, 0x9c, 0x88, 0x88, 0x85, 0xd0, 0xd0, 0x63, 0xd1, 0x3e,
  0x3d, 0xc4, 0x93, 0xf5, 0x0d, 0xd7, 0x3a, 0xbb, 0x92, 0x03, 0x6c, 0x4c,
  0x37, 0x2c, 0xc7, 0xee, 0x8a, 0xb3, 0xfa, 0x21, 0xe2, 0x56, 0x05, 0x14,
  0x5d, 0xf6, 0x19, 0x8a, 0x1f, 0x8a, 0x75, 0x06, 0x29, 0x2a, 0x4d, 0xd4,
  0x92, 0xfe, 0x23, 0xdd, 0x44, 0xa4, 0xb4, 0x26, 0xaa, 0x09, 0xc4, 0x63,
  0x7b, 0x05, 0x24, 0xa0, 0xcc, 0x7d, 0x06, 0xfd, 0xb4, 0x29, 0xa5, 0x85,
  0x3f, 0xfe, 0xb8, 0x26, 0x59, 0xc8, 0x13, 0x6b, 0x0f, 0xab, 0xf3, 0x92,
  0x45, 0x1d, 0xbd, 0x18, 0x67, 0x20, 0x5b, 0xcc, 0xc3, 0x98, 0x8f, 0x3a,
  0xa6, 0xb8, 0xe7, 0x93, 0x9e, 0x75, 0xa9, 0xe0, 0xa1, 0x55, 0x7e, 0xa3,
  0x7c, 0x85, 0xe8, 0x12, 0xd4, 0x2f, 0x96, 0xb2, 0xc0, 0xe0, 0xd7, 0x6d,
  0x3c, 0x6b, 0xd3, 0x3b, 0xe4, 0x3a, 0xcc, 0x00, 0xf4, 0x65, 0x45, 0x94,
  0x63, 0x92, 0xdf, 0x92, 0x28, 0xe4, 0x4b, 0xc2, 0x0a, 0xb5, 0x69, 0xd0,
  0x3d, 0xb9, 0xc4, 0xc4, 0xa2, 0xaf, 0x28, 0x12, 0x72, 0xb2, 0x07, 0x51,
  0xaf, 0x4e, 0x2a, 0x40, 0x3f, 0x31, 0xb1, 0x2c, 0x4f, 0x62, 0xbe, 0x64,
  0xcf, 0x07, 0x52, 0x25, 0xcc, 0xd0, 0x54, 0x13, 0xf9, 0x48, 0xda, 0x80,
  0xed, 0x9b, 0x0f, 0x4c, 0xb5, 0xb3, 0x83, 0xc6, 0x15, 0x0b, 0x0f, 0xcd,
  0xe6, 0x31, 0xc2, 0x49, 0x94, 0x93, 0xad, 0x61, 0x53, 0x35, 0xdd, 0x1e,
  0xde, 0xac, 0x14, 0x0e, 0x42, 0x3d, 0x53, 0x69, 0x40, 0x0b, 0xc6, 0x90,
  0x23, 0xb2, 0x1f, 0xc8, 0x36, 0x8c, 0x17, 0xf6, 0xaf, 0xfe, 0x71, 0x79,
  0x26, 0x64, 0xd6, 0x51, 0x57, 0x35, 0x34, 0xe1, 0x02, 0x99, 0xaa, 0x97,
  0x72, 0xfd, 0xb5, 0x51, 0xcf, 0xc3, 0xaf, 0xa9, 0x67, 0x53, 0x9f, 0xcb,
  0x03, 0xcd, 0xcc, 0x63, 0xc0, 0x19, 0x91, 0x6c, 0xba, 0x46, 0x1d, 0x74,
  0x1b, 0xec, 0x4f, 0x0f, 0x31, 0x7f, 0x57, 0x86, 0x8d, 0xf4, 0x39, 0x4f,
  0x40, 0x3d, 0x6c, 0x62, 0xe6, 0x60, 0xfa, 0x10, 0xf5, 0xec, 0xcc, 0xf0,
  0x98, 0xc2, 0xa3, 0x48, 0x9b, 0x51, 0x05, 0xc0, 0x62, 0x41, 0x27, 0x22,
  0x2c, 0xf0, 0x93, 0x9b, 0x9d, 0xea, 0xab, 0x67, 0x03, 0x6c, 0x29, 0xa0,
  0x5e, 0x38, 0x57, 0x7b, 0x9e, 0xc7, 0xf1, 0xff, 0x67, 0x05, 0xfe, 0xf2,
  0x00, 0x3d, 0xeb, 0xd6, 0x53, 0x7a, 0x87, 0x5b, 0xde, 0xd8, 0x5a, 0x98,
  0xa2, 0x29, 0x6f, 0xfb, 0x71, 0x4a, 0xdd, 0x6b, 0x30, 0x69, 0xa0, 0x86,
  0x56, 0x70, 0x6b, 0x8d, 0x85, 0x3a, 0xf6, 0xf4, 0x7b, 0x73, 0x7a, 0x3d,
  0xd5, 0x0d, 0xcf, 0xb8, 0xf0, 0x32, 0x26, 0x34, 0x53, 0x30, 0x76, 0xae,
  0x36, 0x30, 0xab, 0x58, 0xe9, 0xb3, 0xcf, 0xc3, 0xaf, 0xb8, 0xce, 0xc5,
  0xa5, 0xb5, 0xf3, 0x61, 0x21, 0x30, 0x61, 0x0e, 0x61, 0x48, 0x7a, 0x21,
  0x0f, 0x4c, 0x8a, 0x66, 0x30, 0x19, 0xbf, 0xda, 0x74, 0x55, 0x4a, 0x48,
  0x27, 0x03, 0x62, 0xce, 0xfa, 0x45, 0x82, 0xdc, 0x59, 0x2a, 0x0f, 0x38,
  0x7c, 0x0f, 0xef, 0xaf, 0x24, 0xb6, 0x25, 0xa2, 0xe2, 0x06, 0x95, 0xf0,
  0x85, 0x98, 0x2d, 0x79, 0xc3, 0x14, 0x6a, 0x9e, 0x08, 0xe7, 0x90, 0xf4,
  0x7f, 0x23, 0x4b, 0x60, 0x4c, 0xcb, 0x3a, 0xfb, 0x0a, 0xa0, 0x6e, 0xef,
  0x52, 0xc9, 0x87, 0x29, 0xc5, 0xd5, 0xb6, 0x83, 0x8b, 0x3b, 0x09, 0x65,
  0xff, 0x75, 0xec, 0x27, 0xd6, 0xc6, 0xdf, 0xb2, 0xf1, 0x8f, 0x3e, 0x5e,
  0x48, 0x9f, 0xa9, 0xb7, 0x5d, 0xf3, 0xd6, 0xff, 0xc1, 0x02, 0x60, 0x50,
  0x61, 0xcc, 0x2c, 0x63, 0x22, 0x90, 0x6c, 0x59, 0x4f, 0x7d, 0x94, 0x8d,
  0xfc, 0x76, 0xe4, 0xcb, 0x83, 0x80, 0x5f, 0xee, 0x3a, 0x27, 0xe3, 0x95,
  0x1c, 0x6f, 0x06, 0xd5, 0x8b, 0x2f, 0x9a, 0xad, 0x1f, 0xf0, 0x94, 0x4e,
  0xc6, 0x14, 0x72, 0x34, 0x89, 0xdb, 0x14, 0x07, 0x49, 0xed, 0x58, 0x9b,
  0x7e, 0xaa, 0xd0, 0x14, 0x1d, 0xd7, 0xf9, 0x41, 0xf6, 0x00, 0x23, 0xe9,
  0xef, 0xea, 0x05, 0x7b, 0xd3, 0x28, 0x66, 0xd0, 0x5d, 0x51, 0xb3, 0x19,
  0x1c, 0x63, 0x01, 0x98, 0x30, 0x61, 0xb8, 0x59, 0xdd, 0x12, 0x8e, 0x16,
  0x05, 0xef, 0x7b, 0xf5, 0x67, 0xd1, 0x88, 0xed, 0x73, 0x84, 0xab, 0x11,
  0x46, 0xd9, 0x97, 0x8f, 0x46, 0x4d, 0xa5, 0x60, 0x70, 0xbc, 0x61, 0xf2,
  0x20, 0x3b, 0x48, 0x44, 0xf6, 0x4f, 0x38, 0x18, 0x6b, 0xed, 0xf8, 0x76,
  0x0b, 0xe8, 0x45, 0x38, 0x51, 0x45, 0x19, 0x23, 0x10, 0xc6, 0xa9, 0xb8,
  0x1f, 0x0e, 0x3c, 0x8a, 0x44, 0x7f, 0xe0, 0xb9, 0x82, 0xcc, 0x6c, 0xf0,
  0xdf, 0x20, 0xbf, 0x2c, 0x65, 0x4f, 0xb6, 0x30, 0xde, 0xd7, 0x3b, 0x3c,
  0x19, 0x48, 0x3c, 0x37, 0x71, 0x49, 0xcd, 0x72, 0xe9, 0x06, 0x08, 0xf1,
  0xa7, 0xa4, 0x08, 0x02, 0xf7, 0xc2, 0x1a, 0x91, 0xee, 0x29, 0x4c, 0x18,
  0x72, 0xaa, 0xe6, 0x45, 0xb9, 0xe1, 0x19, 0xdc, 0x2e, 0x4c, 0x65, 0xd4,
  0x46, 0xaf, 0x8c, 0xa8, 0x18, 0x87, 0x39, 0x4e, 0x7f, 0xe1, 0x25, 0x41,
  0x84, 0x87, 0xeb, 0x90, 0x68, 0x75, 0x5c, 0xf3, 0x4e, 0xf4, 0x4f, 0x58,
  0x8e, 0x42, 0x17, 0x32, 0x3d, 0x6d, 0x00, 0xd4, 0xf9, 0x25, 0x4b, 0x96,
  0x84, 0xa7, 0xee, 0xc4, 0x8c, 0xe4, 0x57, 0x3e, 0x95, 0x8e, 0x00, 0x94,
  0x1e, 0xc6, 0xad, 0x73, 0x62, 0xb7, 0x42, 0x52, 0x60, 0x5f, 0x29, 0xf0,
  0xa7, 0x3f, 0x67, 0x16, 0xbf, 0x62, 0x45, 0x2f, 0x51, 0xcb, 0x7e, 0x5c,
  0x1e, 0x0f, 0xbf, 0x60, 0x32, 0xb3, 0xcf, 0xbf, 0xfc, 0x91, 0x88, 0x21,
  0xb9, 0xfa, 0xde, 0x95, 0x29, 0xa4, 0x52, 0xd6, 0xe5, 0x4c, 0x3b, 0x56,
  0x61, 0x37, 0x8a, 0xc8, 0x67, 0x52, 0x5d, 0x10, 0xc5, 0x84, 0x1f, 0x61,
  0xf2, 0xf1, 0x9d, 0x25, 0x9e, 0x88, 0xb0, 0xf1, 0x0f, 0x5e, 0x1e, 0x18,
  0xcd, 0xa0, 0x44, 0x78, 0xcd, 0xe4, 0x1b, 0x90, 0x31, 0xb5, 0xf8, 0x24,
  0x92, 0xd4, 0x3e, 0x32, 0x43, 0x37, 0x1b, 0xd1, 0x32, 0x7a, 0x41, 0xaa,
  0x7a, 0x0a, 0x74, 0x5a, 0x1e, 0xfb, 0x06, 0x59, 0x4d, 0x6c, 0x09, 0xd7,
  0xac, 0xc9, 0xf6, 0xec, 0x1f, 0xb7, 0xc8, 0xee, 0x0c, 0x4c, 0xfd, 0xb2,
  0x4e, 0xf5, 0x51, 0x8b, 0x6d, 0xb2, 0xc1, 0x86, 0x24, 0x78, 0x53, 0x14,
  0xca, 0xe5, 0x58, 0x37, 0x63, 0xc5, 0xb7, 0x7c, 0x14, 0x7d, 0xd0, 0x6e,
  0xeb, 0x31, 0x4e, 0x79, 0xdb, 0xdf, 0xe4, 0x1c, 0xb5, 0x9b, 0x26, 0x8a,
  0xf3, 0xd8, 0x47, 0x2a, 0xab, 0x10, 0x9e, 0xf7, 0x55, 0x80, 0xdb, 0xb6,
  0x21, 0xa4, 0xb3, 0x42, 0x68, 0xf3, 0x29, 0x34, 0xea, 0x98, 0xbe, 0xee,
  0xcf, 0x4b, 0x71, 0xc8, 0xa1, 0xba, 0x03, 0x22, 0x0c, 0x8b, 0xd8, 0x3c,
  0x8b, 0x1c, 0x89, 0x52, 0xca, 0x74, 0xd0, 0x5b, 0x8c, 0x2b, 0xc4, 0x7e,
  0xf4, 0x5f, 0x79, 0x07, 0x7a, 0x9f, 0x1f, 0xa2, 0x5b, 0x63, 0x38, 0x62,
  0x5b, 0xf2, 0xe3, 0x3c, 0xd1, 0x56, 0x5a, 0x78, 0x99, 0x41, 0x05, 0x38,
  0x3d, 0x7e, 0x0b, 0xe5, 0x7b, 0xe8, 0x3f, 0x44, 0x99, 0xb9, 0xb5, 0x64,
  0xb0, 0xe1, 0x86, 0x7d, 0x89, 0x50, 0x9b, 0x25, 0x9b, 0x1d, 0xdf, 0x12,
  0xfa, 0x31, 0xb2, 0x73, 0xec, 0x04, 0x2c, 0x99, 0xda, 0x61, 0x4f, 0x09,
  0x9a, 0x93, 0xe3, 0x93, 0x88, 0xcf, 0x2d, 0x70, 0x11, 0xd8, 0xf2, 0xcc,
  0xb1, 0x1d, 0xe3, 0xfd, 0xb0, 0xd1, 0xe8, 0x52, 0x7d, 0x1f, 0xf0, 0xf1,
  0x69, 0x14, 0xda, 0x62, 0x3b, 0xf9, 0x2e, 0xee, 0x1e, 0x3a, 0xc8, 0x24,
  0x02, 0xf7, 0xcb, 0x57, 0x9f, 0x30, 0x70, 0x63, 0xc4, 0x04, 0x57, 0x3b,
  0x5b, 0x03, 0x2c, 0xa2, 0x0a, 0xf4, 0xe5, 0x3e, 0x02, 0x63, 0xd5, 0x97,
  0x2c, 0xf6, 0x8e, 0x7b, 0x70, 0xc7, 0x46, 0xf3, 0x3f, 0x16, 0x74, 0xcc,
  0x00, 0x82, 0x3c, 0x4b, 0xa8, 0xa1, 0xf2, 0x29, 0x9f, 0x34, 0x26, 0x14,
  0x60, 0xac, 0x4c, 0x03, 0xf0, 0xa3, 0x9e, 0xa0, 0x4c, 0xf2, 0xd7, 0xe4,
  0xb2, 0x19, 0x02, 0xd5, 0x64, 0xfa, 0x60, 0xaa, 0xe0, 0xea, 0x86, 0x6b,
  0x32, 0xad, 0xa3, 0x85, 0x15, 0xc6, 0x52, 0x29, 0xb5, 0xbf, 0x8f, 0xde,
  0x23, 0x9b, 0x6b, 0xf1, 0x6d, 0xd3, 0x99, 0x88, 0x02, 0x70, 0xd0, 0xd6,
  0x6f, 0x87, 0xfb, 0x2f, 0xc5, 0xe5, 0xf3, 0x33, 0x49, 0xe3, 0x84, 0x27,
  0x96, 0x58, 0x52, 0x39, 0x75, 0x31, 0xbe, 0x15, 0x53, 0x17, 0x57, 0x1c,
  0xa3, 0x40, 0x24, 0x78, 0xfa, 0x67, 0x36, 0x20, 0xc0, 0x6c, 0x6e, 0x85,
  0x84, 0xc3, 0xe3, 0xc7, 0xb6, 0x2e, 0x22, 0x95, 0xa3, 0x61, 0x2f, 0xfd,
  0xd1, 0xae, 0xf6, 0x34, 0xdc, 0xe8, 0xc1, 0x4e, 0x3a, 0x0d, 0xb8, 0x02,
  0x73, 0x80, 0x72, 0x6f, 0x9f, 0x5a, 0xd9, 0x9c, 0xad, 0xd0, 0x99, 0x1a,
  0x59, 0xe2, 0x22, 0x11, 0x75, 0x3d, 0xbe, 0x73, 0xb7, 0x20, 0xa7, 0x8f,
  0x1f, 0x8a, 0x4a, 0x91, 0x5b, 0xf2, 0x05, 0xe5, 0x2b, 0x7b, 0x51, 0x40,
  0x96, 0x83, 0xd6, 0x10, 0x37, 0xff, 0xe3, 0x48, 0x68, 0xe7, 0x09, 0x8a,
  0x5a, 0xc8, 0x19, 0xcd, 0x37, 0xf0, 0x76, 0x1c, 0x7d, 0xfb, 0x4f, 0x1c,
  0x71, 0x68, 0x86, 0xab, 0x31, 0x7b, 0xbd, 0xaa, 0x66, 0x6a, 0x59, 0x2d,
  0x91, 0xaa, 0xe0, 0x24, 0x56, 0x02, 0xbd, 0x16, 0x23, 0x78, 0xbc, 0x27,
  0x32, 0x03, 0x72, 0xa1, 0x7f, 0x34, 0xc5, 0x17, 0x9a, 0xac, 0x62, 0x3c,
  0x9e, 0xc4, 0x73, 0x14, 0x8d, 0xa3, 0x58, 0x85, 0x7d, 0x72, 0x4c, 0xb6,
  0xf2, 0xc4, 0xb0, 0xb2, 0x7d, 0xe1, 0xd7, 0x01, 0xce, 0x55, 0xfe, 0x68,
  0xe3, 0x04, 0x51, 0x03, 0xda, 0xb0, 0x1c, 0x68, 0x5b, 0x04, 0xdd, 0x19,
  0x08, 0x61, 0x89, 0xc1, 0xe6, 0x79, 0x63, 0x14, 0x56, 0x17, 0x52, 0x63,
  0xfa, 0xf6, 0x04, 0xd1, 0xbd, 0xda, 0x27, 0x20, 0x14, 0x2b, 0xcb, 0x30,
  0x85, 0xe7, 0x9a, 0xc9, 0x32, 0x8b, 0x58, 0x7b, 0xaf, 0x17, 0x96, 0x29,
  0x5e, 0x0a, 0x63, 0x19, 0xf6, 0x16, 0x51, 0x3b, 0xe2, 0x81, 0xac, 0xfb,
  0xce, 0x54, 0xe4, 0xb0, 0xba, 0x8e, 0xd3, 0xc1, 0x93, 0x71, 0x1d, 0x49,
  0xba, 0xde, 0xc9, 0x6f, 0x8f, 0xd8, 0x34, 0x17, 0x5a, 0x32, 0x38, 0x66,
  0xf1, 0x58, 0x0e, 0xc9, 0x9a, 0x78, 0x6c, 0x91, 0x02, 0xfe, 0x77, 0x2d,
  0x5a, 0xb3, 0xd8, 0x9e, 0x80, 0x7a, 0x39, 0x8e, 0xfe, 0x1a, 0x1c, 0x63,
  0x2a, 0x5f, 0x29, 0x8d, 0x28, 0xde, 0x3c, 0xe5, 0xbf, 0x10, 0xe0, 0x00,
  0xb8, 0xb0, 0xde, 0x24, 0x20, 0x20, 0xc3, 0x4a, 0x6b, 0x9b, 0x4a, 0x30,
  0x6f, 0x2b, 0x4d, 0x95, 0xd8, 0x5b, 0xd0, 0xb7, 0x0f, 0x22, 0x21, 0x6a,
  0x15, 0xf3, 0x5b, 0xda, 0xac, 0xaf, 0xdb, 0x0f, 0xf2, 0x64, 0x58, 0x25,
  0xe7, 0xe4, 0x99, 0x22, 0xb1, 0xf8, 0x10, 0xbf, 0x32, 0x74, 0x7d, 0xb3,
  0x42, 0xc0, 0x57, 0x47, 0x94, 0xcd, 0x65, 0x96, 0x34, 0x86, 0xeb, 0x84,
  0x26, 0x63, 0x9f, 0xf6, 0xb9, 0x1e, 0x09, 0x0d, 0x2f, 0x20, 0x3d, 0xb8,
  0xbe, 0xdc, 0x9e, 0xcd, 0x7e, 0x3a, 0x27, 0xb1, 0xfa, 0x70, 0xcd, 0x9f,
  0x5c, 0x32, 0x7b, 0x18, 0x93, 0xed, 0x70, 0x2a, 0xb4, 0xad, 0x71, 0x26,
  0x12, 0xd6, 0xdc, 0x4d, 0xbd, 0x1d, 0xdf, 0x67, 0xf2, 0x22, 0x47, 0x6c,
  0xb0, 0x60, 0x61, 0xe1, 0x2c, 0xee, 0xd4, 0xfb, 0x9b, 0xbd, 0x01, 0x4a,
  0x6f, 0x10, 0xfc, 0xc7, 0x98, 0x19, 0x7c, 0x90, 0x21, 0x3a, 0x5d, 0x61,
  0xdc, 0xa7, 0x50, 0xbd, 0xc0, 0xc4, 0xf4, 0x15, 0x14, 0xed, 0xdd, 0xdb,
  0x42, 0x7c, 0x50, 0xa3, 0x38, 0x84, 0xa5, 0xb2, 0xd1, 0x76, 0x77, 0x39,
  0xe1, 0x79, 0x12, 0x88, 0x76, 0xee, 0xd4, 0x6a, 0xac, 0xe2, 0xa9, 0x77,
  0x78, 0x3e, 0x43, 0xc5, 0xe6, 0x0b, 0xf9, 0xc7, 0xf2, 0xb1, 0x7a, 0x99,
  0xcb, 0xf6, 0x95, 0x55, 0x0d, 0xcb, 0x78, 0xd5, 0x50, 0xb1, 0xcb, 0x44,
  0x4e, 0xcd, 0xb4, 0x7a, 0xbe, 0xee, 0xd5, 0xac, 0x1c, 0x9b, 0x1f, 0xcc,
  0xa4, 0xbd, 0x37, 0xf5, 0x76, 0x46, 0xfb, 0x1c, 0xc6, 0x27, 0x15, 0x6b,
  0x0e, 0x3d, 0xaf, 0xf3, 0x6d, 0x77, 0xf2, 0x11, 0x5a, 0x76, 0xa5, 0x6b,
  0xa6, 0x56, 0x79, 0x7e, 0xcc, 0xbf, 0x29, 0xc6, 0x0d, 0x3d, 0x30, 0x8a,
  0xc6, 0x62, 0xee, 0x38, 0xf8, 0x18, 0x6f, 0xc5, 0xe4, 0x8c, 0x49, 0xbe,
  0x38, 0x89, 0x95, 0x1a, 0x2f, 0x5f, 0xed, 0x51, 0x5f, 0xd7, 0xe2, 0x86,
  0xa8, 0xcd, 0x3e, 0x5a, 0x30, 0x27, 0x87, 0xf8, 0x52, 0xaa, 0x29, 0x3e,
  0xcd, 0x0e, 0x04, 0x98, 0xbc, 0x80, 0xec, 0xb0, 0x5c, 0x10, 0x1f, 0x9e,
  0x59, 0x0d, 0xff, 0xb3, 0x4b, 0x33, 0xe0, 0x20, 0xba, 0xd8, 0x30, 0xd2,
  0x4b, 0x09, 0x69, 0x71, 0xfd, 0xe2, 0x32, 0x79, 0xdc, 0x03, 0xa0, 0x38,
  0x89, 0x13, 0xb1, 0x28, 0xcf, 0x5c, 0xeb, 0xe0, 0xbe, 0x0e, 0xe3, 0x77,
  0xbf, 0xd6, 0x4c, 0xed, 0x22, 0x0f, 0x8f, 0xc8, 0x0b, 0xdf, 0xb7, 0x03,
  0xae, 0x37, 0xf8, 0x0a, 0x78, 0xfb, 0x4c, 0xbc, 0x81, 0x91, 0x66, 0xa2,
  0xbe, 0x76, 0x24, 0x3b, 0x04, 0xe4, 0xe9, 0xa0, 0xe5, 0x5f, 0x34, 0xc8,
  0x83, 0xdc, 0x54, 0x47, 0xee, 0x0d, 0x44, 0x40, 0xdc, 0x03, 0x53, 0xc9,
  0xce, 0x64, 0xf2, 0x91, 0x50, 0xae, 0x9d, 0x30, 0x26, 0x62, 0xbb, 0x71,
  0x62, 0xaf, 0x41, 0x56, 0xf8, 0x69, 0x28, 0x8e, 0xc2, 0x17, 0xcd, 0xa8,
  0x81, 0xec, 0x09, 0x4d, 0x01, 0x09, 0x8f, 0x51, 0x3c, 0xc8, 0x3d, 0xd6,
  0xcf, 0xf8, 0x63, 0xc0, 0xb7, 0x76, 0x22, 0x96, 0x69, 0x82, 0x21, 0x5b,
  0x58, 0x8f, 0x58, 0xb5, 0xeb, 0xbe, 0x94, 0x9f, 0x2c, 0x39, 0x5d, 0x97,
  0x81, 0x76, 0x31, 0x6f, 0x94, 0x74, 0x3b, 0xa8, 0xfa, 0xdc, 0x1e, 0xab,
  0xe4, 0xe5, 0x2a, 0x9c, 0x64, 0x55, 0x95, 0x7d, 0x21, 0x4d, 0x69, 0xaa,
  0xbe, 0x04, 0x32, 0xd0, 0x89, 0x1e, 0x5e, 0xcd, 0xf7, 0x8c, 0x69, 0xb1,
  0x58, 0xde, 0x6f, 0x09, 0xdd, 0xa3, 0x5e, 0xc4, 0x83, 0x44, 0x66, 0x45,
  0x78, 0xf0, 0xf8, 0x58, 0xaa, 0xcf, 0xe2, 0xd3, 0x8f, 0xc2, 0xed, 0x93,
  0x5c, 0x9b, 0xc1, 0x03, 0xc9, 0x59, 0x87, 0xed, 0x22, 0x6b, 0x62, 0x1e,
  0x8d, 0x30, 0x3a, 0x7e, 0x6e, 0x78, 0x06, 0x3d, 0x48, 0x7d, 0x55, 0x75,
  0xff, 0x4a, 0x4b, 0xa9, 0x91, 0xc1, 0x3d, 0x67, 0xf7, 0xf1, 0x33, 0x17,
  0x35, 0x44, 0x92, 0xe2, 0xf9, 0xc1, 0xaa, 0xab, 0xcf, 0xa6, 0xaa, 0xc3,
  0x77, 0x69, 0x24, 0x7c, 0xe4, 0xc6, 0x04, 0x6d, 0xb2, 0x61, 0x72, 0x71,
  0x11, 0xd1, 0x32, 0x3b, 0x81, 0xec, 0x38, 0x53, 0x3d, 0x28, 0x8d, 0x4c,
  0x2a, 0xdf, 0x53, 0xed, 0xe6, 0x0f, 0xf4, 0xd9, 0x3e, 0x78, 0xcd, 0x8c,
  0xf2, 0x5b, 0x8f, 0x8d, 0x4b, 0xd6, 0x5a, 0xfd, 0xe9, 0x1b, 0xef, 0xb6,
  0xcd, 0x73, 0x20, 0x92, 0x15, 0xe1, 0x43, 0x46, 0x1b, 0x52, 0x0f, 0xcc,
  0x8d, 0x0d, 0xd4, 0x01, 0x1f, 0x8e, 0xec, 0x02, 0xff, 0x1f, 0x2a, 0xad,
  0xc6, 0x49, 0x75, 0xfa, 0x65, 0x47, 0x14, 0x73, 0xbb, 0xe3, 0x3d, 0x81,
  0xb0, 0x8c, 0x2c, 0x8c, 0x11, 0x9f, 0x6d, 0x6e, 0x1b, 0x2a, 0xf1, 0x5f,
  0x35, 0x79, 0xd4, 0x9c, 0x74, 0x23, 0xe0, 0xf5, 0x61, 0x64, 0x78, 0xd8,
  0x8f, 0x87, 0x8a, 0x76, 0xb3, 0x8b, 0x73, 0x2f, 0x52, 0x5f, 0x78, 0xf2,
  0x92, 0x7a, 0x8b, 0x10, 0x0b, 0x57, 0x10, 0x8f, 0xde, 0xc8, 0x5d, 0xb7,
  0x7a, 0x95, 0x33, 0x98, 0x87, 0xdd, 0xf0, 0xec, 0x8c, 0x15, 0x23, 0x54,
  0xd5, 0x0a, 0x08, 0xda, 0x40, 0x4b, 0xe2, 0x27, 0xfa, 0x86, 0xe3, 0x76,
  0xca, 0xdd, 0xfa, 0x11, 0x9b, 0xef, 0xef, 0xef, 0x50, 0x26, 0x92, 0x27,
  0x7e, 0x69, 0x60, 0x84, 0xeb, 0x30, 0x6d, 0x56, 0xe4, 0x0a, 0x23, 0x10,
  0x29, 0x69, 0x6a, 0x08, 0xb8, 0x91, 0xb7, 0x07, 0x04, 0x10, 0x6b, 0x98,
  0x28, 0xcc, 0xb2, 0xce, 0xfb, 0xac, 0x86, 0xb7, 0x2b, 0x46, 0x6a, 0xe2,
  0x15, 0x14, 0x5a, 0x20, 0x92, 0x6b, 0xe9, 0x8a, 0xff, 0xa5, 0xdb, 0x7b,
  0x10, 0xc2, 0xed, 0x0f, 0x0a, 0xef, 0x7d, 0xcd, 0xda, 0xea, 0x21, 0x8d,
  0x20, 0x43, 0xca, 0xa1, 0x12, 0x10, 0xfe, 0xd0, 0x63, 0x6d, 0x9e, 0x11,
  0xb6, 0x74, 0x73, 0x2a, 0x70, 0x78, 0x37, 0x0e, 0xd7, 0x0d, 0xec, 0xc3,
  0x71, 0xf1, 0xf8, 0xda, 0x8c, 0xf9, 0x56, 0x60, 0x07, 0x14, 0xd4, 0xac,
  0xf6, 0x72, 0x33, 0xc6, 0xba, 0x4e, 0x46, 0x51, 0xd8, 0x37, 0x1e, 0xa9,
  0x76, 0x7e, 0xb1, 0x10, 0xa6, 0x15, 0x06, 0xa8, 0x49, 0x3d, 0xfb, 0x56,
  0xc8, 0x48, 0xff, 0x35, 0xde, 0x87, 0x95, 0x1e, 0x42, 0x70, 0x41, 0x6d,
  0x4c, 0xcc, 0x77, 0x3b, 0xb8, 0x15, 0x96, 0x7a, 0x5b, 0x0e, 0x6b, 0x2a,
  0x0f, 0x46, 0x72, 0x75, 0xae, 0xec, 0x5d, 0x6f, 0x35, 0x89, 0x53, 0xe5,
  0x1b, 0xa2, 0x3f, 0xaa, 0xcd, 0xfc, 0xfa, 0x67, 0xdf, 0xd6, 0x58, 0x6e,
  0x1a, 0xbb, 0x11, 0xef, 0x19, 0xbf, 0x80, 0x98, 0xa5, 0xcd, 0x21, 0x80,
  0x12, 0x0d, 0xfd, 0x73, 0xdd, 0x92, 0x4b, 0xbc, 0x68, 0x39, 0xcc, 0x04,
  0xb0, 0x1b, 0xf1, 0x33, 0x01, 0x2b, 0x89, 0xb4, 0x9f, 0xe9, 0x69, 0x3d,
  0x55, 0x79, 0x7d, 0xad, 0xe4, 0xe2, 0x51, 0xf4, 0x29, 0xd5, 0x34, 0xef,
  0x25, 0x78, 0x3c, 0xe3, 0x3e, 0x52, 0xcc, 0xf1, 0x5d, 0xee, 0xb2, 0xeb,
  0x0d, 0x1b, 0x96, 0xaa, 0xe3, 0x62, 0x7a, 0xb9, 0x71, 0xd9, 0x5a, 0x9e,
  0x38, 0xcb, 0xcd, 0x30, 0xc3, 0x93, 0xeb, 0x26, 0x23, 0x99, 0x13, 0x18,
  0x77, 0x21, 0xca, 0x8e, 0x6a, 0x17, 0x3d, 0x69, 0xc6, 0xab, 0x99, 0x35,
  0x55, 0x70, 0xbe, 0xfa, 0x75, 0xb8, 0x2b, 0x41, 0x44, 0xa0, 0x6e, 0xc3,
  0x13, 0x4b, 0x18, 0x2c, 0x49, 0x46, 0x94, 0xde, 0xea, 0x98, 0xad, 0xfb,
  0x26, 0xa4, 0x5c, 0x3e, 0xa7, 0xb8, 0x2f, 0x5c, 0x93, 0x10, 0x7f, 0x38,
  0xe6, 0x23, 0xa5, 0xc2, 0x83, 0x1e, 0x56, 0x68, 0x7c, 0x7b, 0xe9, 0x05,
  0xa6, 0xfa, 0xd2, 0x5f, 0x91, 0x4f, 0x87, 0xc4, 0x81, 0x9f, 0x68, 0x08,
  0x12, 0x9f, 0x95, 0x2e, 0x98, 0x4f, 0x51, 0x11, 0x55, 0x07, 0xb4, 0x01,
  0xeb, 0x2d, 0x4d, 0x92, 0x9f, 0xcd, 0xa5, 0x2c, 0xf1, 0xba, 0x03, 0x09,
  0x12, 0xd3, 0x96, 0x94, 0xf4, 0x87, 0x03, 0xad, 0xcd, 0xee, 0x6f, 0x8d,
  0x96, 0xf2, 0x1a, 0x33, 0x16, 0x80, 0xbc, 0xbc, 0x71, 0x85, 0xab, 0x4f,
  0x2f, 0x9c, 0x5f, 0x35, 0x55, 0x7b, 0x5e, 0x3f, 0x6b, 0x2e, 0x07, 0x7d,
  0xe3, 0xaa, 0x26, 0xae, 0xf6, 0xba, 0xb9, 0xec, 0xdb, 0x5c, 0x6a, 0x9c,
  0xde, 0x31, 0x62, 0x26, 0x8b, 0xca, 0x94, 0xc9, 0xf8, 0x6b, 0x8b, 0x75,
  0x63, 0x59, 0xd1, 0x95, 0x85, 0x32, 0xa9, 0x68, 0x94, 0x23, 0x7b, 0xa2,
  0x5d, 0x39, 0x73, 0x1d, 0xba, 0x2e, 0x77, 0x4e, 0xa2, 0x9b, 0x24, 0x77,
  0x25, 0x06, 0x6c, 0x6c, 0x06, 0x53, 0x5f, 0xc9, 0x6d, 0xbf, 0x60, 0x82,
  0x48, 0xaf, 0x43, 0x57, 0xdf, 0x30, 0x0c, 0x59, 0xa2, 0xfa, 0x0c, 0x26,
  0xa5, 0x5d, 0x5f, 0x23, 0xa1, 0x8f, 0x23, 0xf7, 0xe0, 0xc0, 0x44, 0xda,
  0x7f, 0x5a, 0xa0, 0x15, 0x44, 0x6c, 0xd4, 0x6b, 0xd2, 0x9e, 0xb8, 0x3e,
  0x2c, 0x1a, 0x22, 0x9e, 0xe5, 0xaa, 0xa9, 0x80, 0x87, 0x77, 0x03, 0xa8,
  0x13, 0xa4, 0x75, 0x53, 0x01, 0xdb, 0x73, 0x1a, 0xfc, 0xe9, 0x4c, 0xeb,
  0x77, 0xc7, 0x2d, 0x10, 0xb5, 0x86, 0x2c, 0x51, 0xd7, 0x1e, 0x58, 0xc1,
  0xb6, 0xb7, 0x0f, 0x51, 0x08, 0x44, 0xd8, 0xe8, 0xc6, 0x10, 0xae, 0x2b,
  0xbe, 0x21, 0xb1, 0x0f, 0x8c, 0xa7, 0xd2, 0xfa, 0x10, 0xf0, 0xf4, 0x29,
  0x12, 0x98, 0x5b, 0x32, 0x0e, 0x9d, 0xe4, 0x10, 0x69, 0x68, 0xdd, 0xb9,
  0x64, 0x96, 0xd6, 0x68, 0xb8, 0xb5, 0xf2, 0x6b, 0xe8, 0xb3, 0xb3, 0xdf,
  0x79, 0xa5, 0x41, 0x86, 0x45, 0xf4, 0x4b, 0xd5, 0xc3, 0x44, 0x41, 0xf3,
  0x58, 0xa0, 0x86, 0x94, 0xd5, 0x71, 0x07, 0xd5, 0x04, 0xee, 0x9e, 0xba,
  0xb1, 0x0b, 0x24, 0xdd, 0x6f, 0xbe, 0x56, 0x19, 0x88, 0x5a, 0x07, 0x45,
  0x58, 0x5d, 0x07, 0x40, 0x7d, 0x69, 0xe4, 0xad, 0x83, 0x48, 0xca, 0x15,
  0x58, 0x7f, 0xef, 0xfa, 0x6e, 0x1d, 0x07, 0x8f, 0x48, 0x36, 0x21, 0xd2,
  0x78, 0x2f, 0xa5, 0x2b, 0xfc, 0xe3, 0x36, 0xd0, 0xac, 0xf4, 0xac, 0xdc,
  0x3c, 0x51, 0xc6, 0x05, 0x5c, 0x27, 0x07, 0x5c, 0x0f, 0x4c, 0x12, 0xd7,
  0xb4, 0x81, 0x53, 0xcd, 0x75, 0xeb, 0x99, 0x47, 0x01, 0xd1, 0x79, 0x15,
  0x8d, 0x56, 0xbd, 0xfd, 0x77, 0x0e, 0x4d, 0x11, 0x1e, 0xf3, 0x6d, 0xd2,
  0xa0, 0xdb, 0xc3, 0x81, 0x9e, 0xc6, 0x46, 0x98, 0x94, 0x23, 0x46, 0x5f,
  0x7f, 0x55, 0x41, 0x82, 0x44, 0xa6, 0x35, 0x91, 0xa6, 0xa7, 0x04, 0xf1,
  0x08, 0x17, 0xea, 0xf7, 0x0f, 0xe2, 0xd6, 0xfc, 0xc1, 0xd1, 0x7a, 0x54,
  0xfd, 0xe9, 0x83, 0x90, 0x1b, 0xc2, 0x01, 0x5b, 0x68, 0x3b, 0x14, 0x13,
  0xa6, 0xcc, 0x7a, 0x98, 0x22, 0x69, 0xa5, 0x14, 0x27, 0x59, 0xc7, 0x6b,
  0x37, 0x9d, 0x1f, 0x57, 0x19, 0xcf, 0xc8, 0x82, 0x1b, 0x96, 0x67, 0x2b,
  0x28, 0x31, 0x69, 0xe6, 0x0e, 0x66, 0xd4, 0x95, 0x1e, 0xac, 0x35, 0x87,
  0xc4, 0x59, 0x1c, 0xfd, 0xd2, 0x94, 0x19, 0x75, 0x7b, 0xf2, 0xb0, 0xbe,
  0xc4, 0x3b, 0x11, 0x78, 0x1b, 0xf4, 0xbe, 0x62, 0x1f, 0x0f, 0x57, 0xc5,
  0x28, 0x9a, 0x09, 0x7b, 0x3d, 0x7e, 0xf8, 0x5b, 0xcf, 0x63, 0xc4, 0x13,
  0x2f, 0xf3, 0x39, 0xa4, 0x31, 0xfe, 0x14, 0x6f, 0xae, 0xa8, 0xd0, 0x55,
  0x6b, 0x1f, 0xb1, 0x04, 0xfa, 0x71, 0xc3, 0xfd, 0x6b, 0x1c, 0x24, 0x3b,
  0x1f, 0x3f, 0xff, 0x4f, 0xca, 0xe1, 0x16, 0x51, 0x43, 0x3e, 0xea, 0x4d,
  0x6f, 0xea, 0x66, 0xe8, 0x82, 0xf2, 0xf8, 0x3b, 0x5b, 0xda, 0x11, 0x60,
  0xb5, 0xc6, 0x85, 0x50, 0xb0, 0xca, 0xb5, 0x32, 0x46, 0x94, 0x2a, 0xb3,
  0xd5, 0xd4, 0x1a, 0xde, 0x54, 0xfb, 0xef, 0x46, 0x7a, 0x9b, 0x93, 0xea,
  0x9a, 0x2c, 0x1a, 0x63, 0x10, 0x7e, 0x57, 0xbe, 0xb9, 0xce, 0xa6, 0x7e,
  0x70, 0x36, 0xb2, 0x6c, 0x3b, 0x4e, 0xec, 0x75, 0x2f, 0xb9, 0x40, 0x74,
  0x33, 0x78, 0xe2, 0x2b, 0x7c, 0x6f, 0xc5, 0xea, 0x5d, 0x61, 0x72, 0xd8,
  0xc2, 0x9d, 0x0e, 0x9f, 0x96, 0xca, 0xb2, 0xb3, 0x48, 0xff, 0x8a, 0x9c,
  0x37, 0x84, 0x30, 0xc6, 0x38, 0xf3, 0x2d, 0x77, 0x66, 0x2f, 0x8c, 0x56,
  0x89, 0x6b, 0xa1, 0x1c, 0x4d, 0xad, 0x57, 0x0d, 0x3a, 0xa0, 0x10, 0x03,
  0x1b, 0xbd, 0x66, 0x16, 0xa0, 0x6b, 0x3d, 0xa4, 0x23, 0xf3, 0x90, 0x7e,
  0x74, 0x7d, 0xda, 0x93, 0x15, 0x89, 0xab, 0x7b, 0x23, 0x38, 0x29, 0x91,
  0x89, 0xa5, 0x28, 0x02, 0x92, 0xb7, 0xd1, 0xaf, 0xde, 0x1c, 0x29, 0x48,
  0x2a, 0xc1, 0x4a, 0xf0, 0xf2, 0xfd, 0x6d, 0x23, 0xcd, 0x7b, 0x68, 0xc2,
  0x33, 0x05, 0x3b, 0xed, 0xaa, 0xaa, 0x98, 0x94, 0x77, 0x5c, 0x2d, 0xe0,
  0x65, 0xb5, 0x05, 0x83, 0x26, 0x41, 0x8d, 0x0a, 0x72, 0x98, 0x95, 0x96,
  0xf1, 0x67, 0xd7, 0xfa, 0xda, 0x1a, 0xbe, 0xb6, 0x5c, 0x43, 0x86, 0xba,
  0x16, 0x5a, 0x04, 0xa6, 0x26, 0x7c, 0xd4, 0x9d, 0x11, 0x6f, 0x7a, 0x45,
  0xad, 0xcd, 0xbf, 0xae, 0x1a, 0xd4, 0xe2, 0xbd, 0x3d, 0xf3, 0xd1, 0xaf,
  0x7b, 0x43, 0x22, 0x14, 0xdc, 0x2c, 0x73, 0x3c, 0x49, 0xcc, 0x22, 0xb3,
  0x4b, 0x7e, 0x45, 0x39, 0xab, 0x1c, 0xd0, 0x0e, 0x2e, 0x90, 0xea, 0x1f,
  0x0f, 0xba, 0xdf, 0xa8, 0x2c, 0xb5, 0xb3, 0xb9, 0x6d, 0x3c, 0x83, 0x26,
  0x5e, 0x0d, 0xd3, 0x78, 0xee, 0x20, 0xb1, 0xba, 0xfb, 0xb3, 0xad, 0x4e,
  0xb3, 0xdf, 0x67, 0x7c, 0x58, 0x4d, 0xdf, 0xe5, 0x34, 0x8c, 0x66, 0x66,
  0xff, 0x47, 0xbf, 0x28, 0x8a, 0x72, 0xae, 0x88, 0xc3, 0xc7, 0xae, 0x6f,
  0xd2, 0x9f, 0x48, 0xd9, 0xca, 0x0e, 0xd5, 0x0c, 0xf1, 0xed, 0xd6, 0x2f,
  0x91, 0xcb, 0x84, 0x4d, 0xbe, 0x62, 0xd6, 0xa5, 0xce, 0xa9, 0x12, 0xc1,
  0x0d, 0xa6, 0xbe, 0x30, 0x71, 0x4b, 0xc7, 0xdb, 0x88, 0xd9, 0x8b, 0xc8,
  0x27, 0x11, 0x37, 0xe9, 0x36, 0x73, 0x1f, 0xdf, 0xcc, 0xc3, 0xbb, 0xb6,
  0xfc, 0x4f, 0x35, 0x77, 0xc6, 0xb5, 0x80, 0x42, 0xa5, 0xdf, 0xef, 0xde,
  0xf6, 0xe8, 0xa9, 0xee, 0xd3, 0x71, 0xc3, 0xf4, 0x8d, 0xc1, 0x8a, 0xaa,
  0xe4, 0xfd, 0xd3, 0x96, 0x64, 0x21, 0x01, 0xa8, 0xb0, 0xb5, 0xcb, 0x38,
  0xca, 0x2b, 0x32, 0x29, 0x23, 0x2d, 0x61, 0xe0, 0x9e, 0xa4, 0x51, 0x33,
  0xb4, 0x8c, 0x5f, 0xb2, 0x9f, 0x58, 0x3e, 0x4a, 0xde, 0xdf, 0xdd, 0x55,
  0xd5, 0x5a, 0x81, 0xa3, 0x62, 0x16, 0x8f, 0x09, 0xab, 0xeb, 0x79, 0x8d,
  0xa3, 0xdb, 0xaf, 0x4d, 0x3e, 0x66, 0xb3, 0xfd, 0x07, 0xff, 0x06, 0x06,
  0x58, 0x0d, 0x6f, 0x5a, 0x39, 0x4d, 0x77, 0x86, 0x11, 0x08, 0x52, 0xe0,
  0x94, 0x1f, 0x15, 0xa0, 0x84, 0xce, 0x2b, 0x4d, 0xf4, 0xe1, 0x7b, 0xcb,
  0xf4, 0xbf, 0x67, 0x15, 0x0a, 0xa0, 0xe4, 0x8c, 0x4e, 0x00, 0xe4, 0x85,
  0x3c, 0xae, 0x87, 0x84, 0x74, 0xb5, 0x56, 0x33, 0x42, 0x2e, 0x2d, 0x07,
  0xb5, 0x32, 0x9b, 0xa2, 0xd7, 0xa4, 0x0a, 0xc4, 0xef, 0x38, 0x84, 0x76,
  0x7c, 0x5c, 0x4f, 0x58, 0x2c, 0x5b, 0xdb, 0x6a, 0x83, 0x0a, 0xe3, 0x32,
  0x74, 0xee, 0x16, 0xef, 0xc9, 0xef, 0x0b, 0xbc, 0x9f, 0xb8, 0x5a, 0x3b,
  0x64, 0xc8, 0xbb, 0x16, 0xe7, 0x12, 0xc0, 0x86, 0x6b, 0xa2, 0x5c, 0x7f,
  0xd3, 0xe8, 0x71, 0x9d, 0x1f, 0x38, 0xf3, 0xc8, 0x62, 0x54, 0xb5, 0xbd,
  0x75, 0x89, 0x2a, 0xab, 0x39, 0x13, 0xe3, 0xcc, 0x92, 0x2d, 0x56, 0x1d,
  0x97, 0x32, 0x38, 0x3d, 0x8d, 0x01, 0x64, 0x94, 0xf1, 0x03, 0x06, 0x3a,
  0x45, 0xde, 0xda, 0x92, 0x71, 0xd0, 0x65, 0x68, 0xfb, 0xd7, 0x51, 0x3b,
  0xce, 0x0e, 0x67, 0x6b, 0x56, 0xf6, 0xad, 0x64, 0x6f, 0xf4, 0xd2, 0x4d,
  0x2d, 0x5f, 0x40, 0xda, 0x35, 0x7a, 0x8e, 0xd6, 0xae, 0xd1, 0xff, 0xe4,
  0x7e, 0x73, 0xb1, 0xd6, 0x4f, 0x1d, 0xae, 0x95, 0xdd, 0xd9, 0xe5, 0xaa,
  0x52, 0x17, 0x74, 0xf4, 0x2c, 0x5d, 0x26, 0x8c, 0xe4, 0xad, 0xa1, 0xec,
  0x5e, 0xd7, 0x45, 0x4c, 0x52, 0x29, 0x6f, 0x2f, 0x1c, 0x3a, 0x22, 0xbb,
  0x7b, 0x86, 0x92, 0x7e, 0x53, 0xfd, 0xb7, 0x72, 0xaf, 0xdf, 0xd7, 0xfc,
  0xc4, 0xf4, 0x77, 0x4b, 0x87, 0xa3, 0x8a, 0x8a, 0xa6, 0x5c, 0xf6, 0x03,
  0x6a, 0xbc, 0x36, 0xa5, 0xf2, 0x84, 0x12, 0x73, 0xb2, 0xe0, 0x25, 0x73,
  0x3f, 0xb9, 0x36, 0x3d, 0xbe, 0x41, 0x99, 0x57, 0xfa, 0x6e, 0x40, 0x15,
  0x78, 0xa7, 0xbc, 0xda, 0x27, 0x63, 0x29, 0x23, 0x5f, 0xa3, 0xb3, 0xf7,
  0x48, 0x74, 0x62, 0x28, 0x5f, 0xae, 0x8d, 0x1b, 0x73, 0xf4, 0xe6, 0x59,
  0x71, 0xa3, 0x26, 0xa6, 0x73, 0xfc, 0x21, 0x3a, 0x5b, 0xf8, 0xaa, 0xb6,
  0x6a, 0xe9, 0x71, 0xcf, 0x42, 0xe6, 0xb8, 0x5e, 0x43, 0x14, 0x24, 0x2f,
  0x26, 0xdc, 0xe8, 0x65, 0x39, 0x7e, 0x93, 0xa1, 0xdd, 0x94, 0xf0, 0x7d,
  0x7b, 0x94, 0x18, 0x6f, 0x48, 0x85, 0x05, 0x32, 0x99, 0x77, 0xb7, 0xa7,
  0x4a, 0xf2, 0x46, 0x31, 0xd9, 0x7f, 0x31, 0xb0, 0xfe, 0x78, 0xe7, 0xde,
  0xc0, 0x14, 0xb7, 0x0e, 0xdf, 0x26, 0x01, 0xb2, 0xb0, 0x05, 0xef, 0x79,
  0x21, 0xc7, 0xb4, 0x2b, 0xbf, 0xb2, 0x4d, 0xc6, 0xaf, 0x0f, 0x0e, 0x5e,
  0x20, 0x14, 0xcc, 0x43, 0xe5, 0x6b, 0x88, 0x4e, 0xa8, 0xb8, 0x95, 0x23,
  0xa0, 0xf0, 0x21, 0x7d, 0xdb, 0x34, 0x19, 0x8d, 0x9a, 0x1d, 0xa7, 0xd3,
  0x45, 0x99, 0xb8, 0x94, 0x1a, 0xbd, 0x31, 0xf0, 0x81, 0x79, 0x27, 0x7a,
  0x72, 0xb6, 0x7a, 0x53, 0x89, 0xd3, 0x8a, 0x9a, 0x99, 0xfd, 0x2d, 0xeb,
  0xf1, 0xb8, 0x17, 0x10, 0x28, 0x7f, 0x4a, 0xe0, 0x6f, 0xb9, 0x4f, 0x88,
  0x49, 0xef, 0xd4, 0xee, 0x88, 0x96, 0x68, 0x68, 0x78, 0xc0, 0x76, 0x23,
  0x80, 0x16, 0x7a, 0x63, 0x4e, 0xb1, 0x0c, 0x9c, 0x84, 0x7d, 0x15, 0x73,
  0x9e, 0x2d, 0x51, 0xce, 0xce, 0x21, 0xd1, 0xfa, 0x90, 0x47, 0xd3, 0xc6,
  0x68, 0xa2, 0xca, 0xcc, 0xfa, 0xfd, 0x63, 0x6e, 0x04, 0xa0, 0x47, 0xda,
  0x68, 0x62, 0xb7, 0xc2, 0x7f, 0x46, 0x06, 0x2a, 0x69, 0x7d, 0x1c, 0x83,
  0xee, 0x87, 0x8f, 0x2c, 0xdc, 0x40, 0x1c, 0xe6, 0xbe, 0xb3, 0x6d, 0x94,
  0xa7, 0xaf, 0xbc, 0xff, 0xa5, 0xb9, 0x7c, 0x09, 0xf6, 0x80, 0x91, 0xcd,
  0x82, 0x1b, 0x58, 0x3d, 0xc1, 0xdb, 0x1f, 0xe7, 0xe4, 0xf3, 0x73, 0x0e,
  0xc5, 0x99, 0xb8, 0x22, 0xe0, 0xb1, 0x29, 0xdf, 0x9f, 0xa4, 0x1f, 0xa4,
  0xd3, 0x0f, 0x62, 0x20, 0xdd, 0x75, 0xc3, 0x96, 0xc2, 0x0a, 0x69, 0x4b,
  0xe7, 0x24, 0x74, 0xcf, 0x2e, 0x71, 0xe9, 0x72, 0x9e, 0xf4, 0x51, 0xb2,
  0xc8, 0x52, 0xd0, 0x33, 0xbe, 0x35, 0xb0, 0x09, 0xd6, 0x30, 0x10, 0xc8,
  0x58, 0x5d, 0x54, 0xb4, 0xd0, 0xca, 0xff, 0xaa, 0xa5, 0x1b, 0x5a, 0x25,
  0x40, 0xce, 0xa9, 0xdd, 0xaa, 0xa0, 0x5d, 0x08, 0x48, 0xd3, 0xf1, 0x4f,
  0xe3, 0x98, 0x9f, 0xf4, 0xe3, 0x6c, 0xcc, 0xc2, 0x08, 0x10, 0x59, 0xff,
  0x9e, 0x45, 0x97, 0x01, 0xff, 0x86, 0xf1, 0x0c, 0xd5, 0x08, 0xe5, 0x0e,
  0xf3, 0xdf, 0x42, 0x5c, 0x29, 0xb8, 0xf6, 0xd7, 0x62, 0x48, 0x91, 0xdf,
  0x06, 0x91, 0x21, 0x69, 0x4b, 0x14, 0xf2, 0x1d, 0xed, 0x87, 0x1a, 0xf8,
  0x0f, 0x1f, 0x97, 0xff, 0x72, 0x1b, 0x4f, 0xc2, 0x87, 0x24, 0x79, 0x2d,
  0xc5, 0x0e, 0xdd, 0x16, 0x42, 0x72, 0x99, 0x0f, 0x61, 0x19, 0x1f, 0xf5,
  0xde, 0x35, 0x73, 0x04, 0x20, 0x4d, 0x9d, 0xc1, 0xd3, 0xa0, 0xbf, 0x19,
  0xc1, 0xf6, 0xd5, 0x56, 0xac, 0x60, 0x54, 0x53, 0x2f, 0x9c, 0x17, 0x80,
  0xb8, 0x45, 0x6a, 0xb9, 0x84, 0x12, 0x22, 0x71, 0x16, 0xb4, 0x39, 0x4f,
  0xcf, 0x72, 0xa3, 0x85, 0x49, 0x04, 0xc1, 0xb9, 0x6b, 0xba, 0x85, 0xe9,
  0x90, 0x8f, 0x6e, 0x9b, 0x4e, 0xa3, 0x0a, 0xf7, 0x43, 0x0f, 0xf6, 0x37,
  0x91, 0x00, 0xb3, 0x03, 0xd1, 0xef, 0x56, 0x50, 0xc0, 0x1a, 0xd4, 0x38,
  0x35, 0x31, 0xc9, 0xdd, 0xed, 0x5f, 0x8c, 0xab, 0x12, 0xb8, 0x5e, 0x32,
  0xe1, 0xa2, 0x9f, 0x4a, 0x82, 0x94, 0x63, 0xbf, 0xa7, 0x1d, 0x7e, 0x00,
  0x09, 0xbb, 0xe6, 0x3e, 0x88, 0x1d, 0x27, 0xf1, 0x71, 0x9f, 0xc6, 0x8c,
  0x22, 0x03, 0xa2, 0x13, 0xdb, 0x7e, 0xcc, 0x41, 0x23, 0xc5, 0xa9, 0x98,
  0x0a, 0x6f, 0x43, 0x27, 0x9f, 0x58, 0xc0, 0x7e, 0x54, 0x96, 0xfe, 0x0f,
  0x2a, 0x17, 0x37, 0x47, 0xcd, 0x53, 0xa4, 0x50, 0x99, 0x33, 0x37, 0x40,
  0xac, 0x0a, 0xbe, 0x3e, 0xbf, 0x1d, 0x09, 0x2e, 0x9d, 0xbd, 0xf6, 0xd2,
  0xa9, 0x34, 0xde, 0x8e, 0xcb, 0xa9, 0x26, 0xd3, 0x6b, 0x58, 0x76, 0x93,
  0x5b, 0x6f, 0xa2, 0x5f, 0x11, 0xf9, 0xb0, 0x8d, 0xb7, 0x50, 0x23, 0xb3,
  0xc3, 0x47, 0xd0, 0xde, 0x88, 0x50, 0x5f, 0x19, 0x83, 0x87, 0x48, 0x04,
  0x3b, 0xea, 0xe1, 0x5f, 0xa3, 0x0c, 0x24, 0xa6, 0x93, 0x8f, 0xc4, 0x72,
  0x3a, 0xe0, 0x34, 0xbe, 0xc4, 0x16, 0x6f, 0x96, 0xce, 0x08, 0x37, 0x25,
  0x58, 0x7a, 0x11, 0x24, 0x48, 0xf1, 0xe7, 0xf8, 0xc1, 0xa6, 0x2e, 0xb1,
  0x2d, 0x4a, 0x2e, 0xa3, 0xa0, 0x09, 0xbd, 0x16, 0x40, 0x37, 0x2d, 0x2d,
  0x49, 0x19, 0xaf, 0xfe, 0x2d, 0x16, 0xb3, 0x2f, 0xd3, 0x08, 0x15, 0xc3,
  0xe8, 0xb3, 0x81, 0xe5, 0xfe, 0x39, 0xe6, 0xff, 0x7c, 0xa5, 0xc1, 0x56,
  0x05, 0x7b, 0x93, 0xe9, 0xe8, 0x74, 0x26, 0x1b, 0xe7, 0xeb, 0xad, 0xd3,
  0xef, 0x4f, 0xf6, 0xea, 0x05, 0xff, 0x8b, 0x45, 0x0e, 0xc5, 0x7e, 0x59,
  0x16, 0x1a, 0x23, 0x47, 0x2b, 0x2d, 0x2a, 0x55, 0xb3, 0x53, 0xd1, 0x37,
  0x0a, 0x82, 0xd1, 0x27, 0xdf, 0x32, 0xd4, 0x62, 0x4f, 0x1a, 0xef, 0x69,
  0x4d, 0x4c, 0xac, 0xc0, 0x66, 0xc1, 0x83, 0x47, 0x0f, 0x7a, 0x0d, 0xba,
  0x9e, 0xcf, 0xec, 0x50, 0x05, 0x96, 0x71, 0x8f, 0xc2, 0xb0, 0x40, 0x0a,
  0xc4, 0x0a, 0x9d, 0x45, 0x69, 0xa0, 0xe4, 0xf0, 0x0a, 0x9c, 0x04, 0x49,
  0xd5, 0x55, 0x75, 0x51, 0xb1, 0x7a, 0xe0, 0x01, 0xb8, 0x10, 0x59, 0xad,
  0xd5, 0x43, 0x02, 0x27, 0x1f, 0x58, 0x26, 0x84, 0x84, 0x90, 0xbf, 0xdd,
  0xb7, 0x4c, 0x5d, 0x65, 0x59, 0x37, 0x44, 0x77, 0xe5, 0x6e, 0xcf, 0x59,
  0x5b, 0xa0, 0x20, 0xf9, 0xac, 0x4e, 0x4b, 0xa0, 0x2e, 0x46, 0xce, 0x9a,
  0xab, 0x72, 0xff, 0xb5, 0xaa, 0x7f, 0x70, 0xc1, 0xe0, 0x34, 0x34, 0xe2,
  0x4a, 0x6d, 0xb7, 0xec, 0x6e, 0xd5, 0x05, 0xfa, 0x08, 0x0e, 0xbf, 0xbb,
  0x64, 0xbe, 0x92, 0x9f, 0x6d, 0xe3, 0x15, 0x24, 0xd9, 0x4b, 0xea, 0x76,
  0x5f, 0xe2, 0x35, 0xa8, 0x48, 0xd9, 0x53, 0x22, 0xb6, 0xce, 0x09, 0xc5,
  0x96, 0xfc, 0x0c, 0xc0, 0x5d, 0x52, 0xa6, 0xa6, 0xf2, 0x3b, 0xa6, 0xa0,
  0x96, 0x51, 0x26, 0x6d, 0x21, 0x00, 0x6e, 0xba, 0xd0, 0x2e, 0xfc, 0xc6,
  0x03, 0xf8, 0x6e, 0x40, 0xb5, 0xe3, 0x8a, 0x68, 0x50, 0x5f, 0xf5, 0xc0,
  0xed, 0xb4, 0xcb, 0x05, 0xbb, 0x3b, 0x0e, 0x61, 0x1e, 0xc9, 0x1b, 0x81,
  0x2e, 0xdf, 0xfd, 0x4c, 0x5c, 0xba, 0x6e, 0xb6, 0xd9, 0x4c, 0x9d, 0x50,
  0x95, 0x1a, 0xde, 0xf3, 0x37, 0x77, 0x56, 0x65, 0x2e, 0x50, 0x28, 0x30,
  0xa6, 0x60, 0x6d, 0x25, 0xa1, 0xf9, 0xbf, 0x8d, 0xfc, 0xa9, 0x78, 0xda,
  0x83, 0x4e, 0x05, 0xa5, 0x15, 0xde, 0x74, 0x37, 0xb5, 0x88, 0x21, 0x61,
  0x07, 0x3f, 0x47, 0xe3, 0x3b, 0x64, 0xc7, 0x7b, 0x62, 0x97, 0xdf, 0x14,
  0xa2, 0x14, 0xd1, 0xb8, 0x9c, 0x0e, 0x8b, 0x07, 0xe3, 0x7b, 0xee, 0xd7,
  0xf0, 0xa3, 0x84, 0xa1, 0x71, 0x36, 0xe1, 0xf9, 0x4d, 0xe6, 0xeb, 0xa4,
  0x45, 0x14, 0x75, 0x7f, 0xc8, 0x0e, 0x32, 0xfd, 0x01, 0x61, 0xf3, 0x24,
  0x4c, 0x95, 0xe3, 0x3f, 0x2c, 0x44, 0xee, 0x7c, 0x25, 0xc7, 0x32, 0xd0,
  0x14, 0xff, 0xb4, 0x1a, 0xaa, 0xf6, 0xb3, 0x50, 0x46, 0x47, 0xe2, 0x62,
  0x92, 0x46, 0x41, 0x0f, 0xa6, 0xc3, 0x8e, 0x89, 0xa3, 0xa8, 0x29, 0x9b,
  0xa3, 0x49, 0xbf, 0x83, 0x65, 0xaa, 0x18, 0x4a, 0xec, 0xa3, 0x3e, 0xf3,
  0x5a, 0xb0, 0x4b, 0x8f, 0x20, 0x70, 0x8e, 0xc4, 0x62, 0xe9, 0x64, 0xb4,
  0x26, 0xa6, 0x3e, 0xf4, 0x61, 0x5c, 0x47, 0xea, 0x73, 0x36, 0xe7, 0x33,
  0x1e, 0x97, 0x0f, 0x4b, 0x8c, 0x84, 0x3b, 0xd0, 0x8d, 0x57, 0x4b, 0x27,
  0xf0, 0x36, 0xba, 0xe7, 0x5d, 0x30, 0x3f, 0x16, 0x02, 0x84, 0x2c, 0x53,
  0x4a, 0xcd, 0xdd, 0x3c, 0x74, 0x03, 0x4a, 0x1c, 0x36, 0xe2, 0x05, 0x09,
  0x34, 0xd4, 0xb5, 0x08, 0x1f, 0xc9, 0xf8, 0x90, 0x1c, 0x93, 0xa4, 0xe5,
  0xc8, 0xdd, 0x54, 0x12, 0xcb, 0x6c, 0xd3, 0x30, 0x2a, 0xd2, 0x91, 0xd8,
  0x09, 0x71, 0x3a, 0x3e, 0x82, 0x63, 0xe8, 0x88, 0xa6, 0x4a, 0x8f, 0xcc,
  0xa5, 0x8f, 0x0c, 0x73, 0x74, 0x60, 0x03, 0xba, 0x7a, 0x1e, 0x67, 0xf4,
  0xf1, 0x3d, 0x1d, 0xdf, 0x9a, 0xd2, 0xcb, 0xd7, 0xab, 0x6c, 0xf0, 0xb4,
  0x93, 0xd7, 0xe7, 0xdf, 0xb0, 0x71, 0x7d, 0x78, 0x7d, 0x2e, 0xd0, 0xab,
  0x3a, 0x55, 0x37, 0x01, 0x93, 0x12, 0x57, 0x66, 0x6a, 0xe8, 0x1a, 0x76,
  0x53, 0x5c, 0xbe, 0x37, 0xbe, 0x24, 0x52, 0xf7, 0xc6, 0x82, 0x9b, 0xfb,
  0xac, 0x2d, 0xdd, 0xd1, 0xa3, 0x76, 0x5b, 0xce, 0x63, 0xdf, 0xe9, 0x54,
  0xc4, 0xd7, 0xc5, 0x36, 0x58, 0xe5, 0x21, 0x51, 0x9f, 0x08, 0x40, 0x7a,
  0x66, 0x1f, 0xbd, 0xab, 0x41, 0xb1, 0x37, 0xff, 0x4b, 0x2f, 0x35, 0xcd,
  0x49, 0x3c, 0x69, 0x14, 0x18, 0x83, 0x8c, 0x0a, 0x9b, 0xa2, 0x94, 0x22,
  0xbf, 0x04, 0xc9, 0x30, 0x97, 0x39, 0x3f, 0x65, 0xdc, 0x6e, 0x44, 0x87,
  0xc1, 0x83, 0xc1, 0x2e, 0x38, 0x34, 0xd1, 0xa8, 0xcc, 0x64, 0x52, 0x05,
  0x20, 0x93, 0x19, 0xbf, 0xc5, 0xe8, 0x66, 0x72, 0x8d, 0x8a, 0xf3, 0xf6,
  0x46, 0x66, 0xeb, 0xd3, 0xb8, 0x25, 0x74, 0xdb, 0x23, 0x91, 0xe7, 0xae,
  0xa8, 0x9b, 0xdc, 0x85, 0xa0, 0x2f, 0x4c, 0x41, 0xe3, 0x9e, 0x83, 0x61,
  0x3b, 0xca, 0xb0, 0xbc, 0x6a, 0xca, 0x64, 0x9e, 0x53, 0x3d, 0x73, 0xda,
  0x49, 0xeb, 0x0f, 0x40, 0xa8, 0x3f, 0xfb, 0x0f, 0x79, 0x97, 0x20, 0xc0,
  0xb8, 0x32, 0x59, 0xfb, 0xb1, 0xa2, 0xd2, 0x6d, 0x3a, 0x1e, 0xb2, 0xff,
  0x40, 0xb4, 0xb7, 0xd7, 0xb5, 0x31, 0x03, 0x22, 0xcf, 0x70, 0x7c, 0x76,
  0xe7, 0xb2, 0x53, 0xb1, 0x43, 0x19, 0x75, 0x6d, 0x50, 0x6e, 0x6d, 0x20,
  0x2f, 0x2d, 0x71, 0xa9, 0x44, 0x73, 0xe8, 0x20, 0xe9, 0x27, 0x17, 0x15,
  0xee, 0xcb, 0x19, 0x28, 0x0b, 0xed, 0xb3, 0x26, 0x0c, 0x69, 0x22, 0x68,
  0x22, 0x9c, 0xb8, 0x1e, 0xb5, 0xf8, 0x7b, 0x34, 0xc0, 0x13, 0x18, 0xbf,
  0xcd, 0xaa, 0x87, 0x3d, 0x8e, 0x2a, 0x3a, 0xd1, 0x82, 0x77, 0x60, 0x41,
  0x4c, 0xb1, 0xfb, 0xc3, 0x87, 0x94, 0xe1, 0xa6, 0xd8, 0x2b, 0x13, 0xe5,
  0x43, 0x6e, 0xab, 0x75, 0xce, 0xe8, 0xfd, 0xf2, 0xb2, 0x97, 0x6a, 0x53,
  0x05, 0x41, 0x53, 0x13, 0xb0, 0x72, 0x40, 0x16, 0xa5, 0x30, 0x89, 0xf5,
  0xdc, 0x07, 0x18, 0x93, 0x29, 0x97, 0x1b, 0x3e, 0x67, 0xe3, 0x08, 0x9d,
  0x7f, 0xf9, 0x24, 0x84, 0x48, 0x08, 0x72, 0xec, 0xa0, 0x47, 0x40, 0x46,
  0xe5, 0xc2, 0xc6, 0xff, 0x04, 0x8c, 0x83, 0x55, 0xfd, 0xb1, 0x03, 0xb2,
  0x86, 0x1f, 0x5f, 0x92, 0x26, 0x7e, 0x98, 0x18, 0x58, 0x44, 0xde, 0x79,
  0xf6, 0x17, 0xd9, 0x4e, 0x5f, 0x2e, 0x0a, 0x09, 0x38, 0x57, 0xdb, 0x2b,
  0x5a, 0x63, 0xe8, 0xad, 0x7e, 0xae, 0xf6, 0x62, 0x66, 0x21, 0xdd, 0x5c,
  0x76, 0x21, 0x6e, 0x56, 0x4f, 0x40, 0x3b, 0x64, 0x0e, 0xc2, 0xad, 0x13,
  0x20, 0x58, 0x29, 0xb0, 0xb9, 0xac, 0x28, 0xfd, 0x0a, 0x32, 0x07, 0xcb,
  0x1e, 0x90, 0xb3, 0xa2, 0xbe, 0x05, 0x4a, 0x54, 0xe1, 0x20, 0x8a, 0x1a,
  0x08, 0xee, 0xc1, 0xd8, 0x16, 0xac, 0x3c, 0x6c, 0x96, 0x48, 0x52, 0x3c,
  0x9e, 0x0c, 0xc8, 0x36, 0x4b, 0x06, 0xac, 0x54, 0x6e, 0x5a, 0xd1, 0x0b,
  0xa1, 0x43, 0x42, 0x64, 0x13, 0xc4, 0x37, 0x2b, 0xbf, 0x3a, 0x41, 0x79,
  0x21, 0x7c, 0x0e, 0x02, 0x79, 0xb7, 0xba, 0x49, 0x54, 0xff, 0x88, 0x44,
  0x4f, 0xe6, 0xf4, 0xe6, 0xf3, 0x03, 0xed, 0x94, 0x17, 0x46, 0x8e, 0x18,
  0x2c, 0x59, 0xb3, 0x00, 0x05, 0xda, 0x0e, 0x84, 0x7c, 0x3d, 0xd2, 0x84,
  0x85, 0xfe, 0x6e, 0xf1, 0xc8, 0x42, 0x65, 0x40, 0x62, 0xbd, 0x8f, 0xf2,
  0xf2, 0x8e, 0x85, 0x31, 0x61, 0x24, 0xa7, 0x9e, 0xc6, 0x4f, 0x29, 0xd5,
  0x4c, 0xcc, 0x7f, 0x38, 0x5d, 0x65, 0x5f, 0xf4, 0x30, 0xc7, 0xc5, 0xf4,
  0x41, 0xb6, 0xcf, 0x7c, 0x90, 0xf1, 0x7c, 0xba, 0xc5, 0xcc, 0x1b, 0xf1,
  0x43, 0xd5, 0x0a, 0x0b, 0x35, 0xfe, 0x2b, 0xb2, 0xcb, 0x9a, 0x40, 0xa4,
  0x86, 0x10, 0x02, 0x7f, 0x5d, 0x7a, 0x33, 0xb0, 0x1e, 0xfa, 0x8d, 0x51,
  0x67, 0xbf, 0x1e, 0x98, 0x31, 0xca, 0x3e, 0xe2, 0x21, 0xcc, 0x60, 0x84,
  0x95, 0x2a, 0xab, 0x02, 0x4b, 0xda, 0xcd, 0x55, 0x60, 0x7b, 0x71, 0x06,
  0x78, 0x9e, 0x3c, 0x85, 0x9a, 0xb0, 0x3e, 0x73, 0xe1, 0x94, 0xc6, 0x42,
  0xef, 0x5d, 0x05, 0x2d, 0x6c, 0x4b, 0x6f, 0xe2, 0xed, 0x04, 0x98, 0x4f,
  0x22, 0x87, 0x26, 0x30, 0xcb, 0xc5, 0xef, 0x3b, 0xea, 0xd9, 0x30, 0xf8,
  0xd3, 0x14, 0x9b, 0x2b, 0x1c, 0x6b, 0x93, 0xf9, 0x0a, 0xde, 0x03, 0xaf,
  0xe9, 0xdc, 0xfe, 0x7c, 0xf9, 0xb7, 0xb7, 0xa5, 0x11, 0xdd, 0x77, 0xaf,
  0x50, 0x3e, 0xac, 0x24, 0x30, 0xdd, 0x7c, 0x2b, 0xda, 0x73, 0x8c, 0xf5,
  0x1e, 0xaf, 0xe3, 0x7b, 0xa4, 0x7c, 0xc7, 0x1b, 0x0e, 0x27, 0xf1, 0x10,
  0xae, 0xf3, 0x22, 0xbf, 0x9f, 0xb6, 0x40, 0x68, 0x99, 0x3a, 0xb4, 0x03,
  0x03, 0x0a, 0x33, 0xf3, 0x48, 0x9b, 0xd3, 0x4a, 0xf4, 0x79, 0xe3, 0xb5,
  0xf4, 0x49, 0x39, 0xe4, 0x3f, 0x27, 0xf9, 0x65, 0xfb, 0x74, 0x09, 0x3f,
  0x17, 0x61, 0x4d, 0xc6, 0xb2, 0xe1, 0xac, 0x32, 0xb2, 0x67, 0x6c, 0xa3,
  0x46, 0xa6, 0x09, 0x11, 0x2d, 0xa3, 0x2c, 0x0a, 0xc9, 0xce, 0xac, 0xfe,
  0xac, 0xa3, 0xac, 0xd2, 0x0d, 0x06, 0x1b, 0x41, 0xab, 0x9a, 0xa6, 0x2e,
  0xd6, 0x0a, 0x55, 0xba, 0x3f, 0xf5, 0xc5, 0x6f, 0x46, 0x56, 0xa4, 0x02,
  0xc9, 0x22, 0x42, 0x2b, 0x4a, 0x7a, 0xca, 0x52, 0x4b, 0x7d, 0x92, 0x43,
  0xc5, 0xa9, 0x3e, 0x5d, 0xad, 0xa2, 0xc1, 0xfc, 0xf9, 0x26, 0x91, 0xa0,
  0xed, 0x5b, 0x64, 0x87, 0x48, 0xf9, 0x3f, 0xc3, 0xf4, 0xf9, 0x66, 0xda,
  0x56, 0xe9, 0x6b, 0x9b, 0xe9, 0x1c, 0xe7, 0x4b, 0xe8, 0xc6, 0xe8, 0x93,
  0xa3, 0x88, 0x48, 0x1a, 0x98, 0xf9, 0xea, 0xd2, 0x25, 0x10, 0x96, 0x38,
  0x81, 0x0a, 0xba, 0x93, 0xd7, 0xc5, 0x59, 0x8b, 0x9c, 0xf2, 0xec, 0xcd,
  0xcd, 0x90, 0xde, 0x33, 0x0b, 0x19, 0xe4, 0xa6, 0x7d, 0x3e, 0xe9, 0xd1,
  0x4d, 0x27, 0x34, 0x4a, 0x6c, 0x03, 0xc7, 0x47, 0xd3, 0xa2, 0x43, 0x10,
  0x0c, 0x62, 0xc0, 0x41, 0x08, 0x06, 0xaf, 0x6f, 0xe3, 0xff, 0x3b, 0x08,
  0x11, 0xca, 0x1e, 0x49, 0xe4, 0x37, 0x66, 0xed, 0xb7, 0x34, 0x99, 0x81,
  0xa8, 0x6e, 0xe5, 0x01, 0x67, 0x3a, 0x9d, 0x1f, 0xfd, 0xa6, 0x36, 0xa9,
  0xb6, 0x0e, 0x26, 0x72, 0xa0, 0x58, 0xab, 0xaa, 0x2a, 0xf5, 0x8e, 0x9e,
  0x9c, 0x3a, 0x83, 0x3b, 0xb5, 0xf1, 0x1b, 0x26, 0x9e, 0x5f, 0x24, 0x00,
  0xc6, 0x84, 0x50, 0xcb, 0x4b, 0xc7, 0xdc, 0xcb, 0x99, 0x5c, 0xb0, 0x42,
  0xe6, 0x9f, 0x4a, 0x0b, 0x0d, 0x90, 0xa0, 0x40, 0x70, 0x0b, 0x87, 0x39,
  0x5b, 0x09, 0xb2, 0x76, 0x24, 0x34, 0xbf, 0x38, 0xe8, 0x91, 0xbf, 0x8c,
  0x75, 0xb0, 0x80, 0xc0, 0x07, 0xd4, 0x1d, 0x3b, 0x97, 0x57, 0xcc, 0x8b,
  0x59, 0x4c, 0xea, 0xac, 0x81, 0xa3, 0xcb, 0x0e, 0xf1, 0xdd, 0x23, 0xf7,
  0x3b, 0xf9, 0x4c, 0x65, 0xee, 0x5f, 0x52, 0x6d, 0x12, 0xac, 0x8d, 0xf5,
  0xa2, 0xde, 0xfd, 0x67, 0x41, 0xe8, 0xab, 0xa6, 0xf2, 0xc0, 0x40, 0x2e,
  0xcd, 0xe3, 0xf8, 0x45, 0xfb, 0x5d, 0x32, 0x98, 0x57, 0xbd, 0x23, 0x0c,
  0x9e, 0xb0, 0x08, 0x1d, 0xfc, 0x56, 0x03, 0xd5, 0xc9, 0xe6, 0x50, 0x40,
  0x56, 0x8b, 0x4c, 0x56, 0x68, 0x00, 0xf6, 0x96, 0x51, 0x9b, 0x4c, 0x35,
  0x2b, 0xf7, 0x13, 0x0e, 0x91, 0x54, 0xd3, 0x77, 0x7b, 0x9f, 0x56, 0x1a,
  0x8a, 0x91, 0x4b, 0x50, 0x63, 0x56, 0xcf, 0x46, 0x8c, 0x16, 0x67, 0x47,
  0x1f, 0xff, 0x9e, 0x3d, 0x40, 0x56, 0x2e, 0x5f, 0x78, 0x1a, 0x12, 0xf6,
  0xe2, 0x11, 0xce, 0x1e, 0x30, 0x70, 0x6e, 0x00, 0x6d, 0x98, 0xa3, 0x31,
  0x93, 0x13, 0xef, 0x5a, 0xbe, 0xef, 0xc1, 0x82, 0x75, 0xda, 0x56, 0xc7,
  0x2a, 0x16, 0x4f, 0x75, 0x07, 0x9e, 0x9f, 0xa7, 0x31, 0xa2, 0xa0, 0xa4,
  0xd7, 0x59, 0x54, 0x9d, 0xd3, 0x34, 0x1d, 0x80, 0x1a, 0x43, 0xbe, 0xe6,
  0x2e, 0x2c, 0xf4, 0x04, 0xa6, 0x53, 0x73, 0xf7, 0xaa, 0x26, 0x46, 0x6a,
  0x44, 0x26, 0x59, 0x77, 0x98, 0x41, 0x11, 0x80, 0x0a, 0xa3, 0x65, 0xb6,
  0xbd, 0xe1, 0x30, 0xad, 0x7c, 0xde, 0x2c, 0x3e, 0xb7, 0x0f, 0x91, 0xc2,
  0x9d, 0x71, 0x4c, 0x9f, 0x82, 0x32, 0xd4, 0x77, 0x00, 0xeb, 0x68, 0x46,
  0xdb, 0xea, 0xb7, 0x06, 0x77, 0x5d, 0x5a, 0x98, 0x58, 0xbf, 0x21, 0xd9,
  0x44, 0x18, 0xcc, 0x07, 0xd4, 0x80, 0xd2, 0x22, 0x86, 0x51, 0xed, 0x57,
  0xff, 0x0c, 0xd4, 0x3a, 0x90, 0x2b, 0xc6, 0x0b, 0x19, 0xe8, 0x44, 0x4a,
  0xe6, 0xd0, 0xa8, 0xce, 0xe9, 0x87, 0x1f, 0x0c, 0x1c, 0x59, 0xb6, 0x28,
  0x23, 0xae, 0xf1, 0xf7, 0xdb, 0x77, 0xb5, 0x7b, 0x1a, 0x0a, 0x00, 0x4d,
  0x91, 0xfe, 0xf3, 0x36, 0x7b, 0x65, 0xee, 0x55, 0x14, 0xae, 0xbb, 0x35,
  0x0b, 0x6d, 0xa2, 0xb6, 0x2b, 0x4c, 0xdb, 0xd7, 0x37, 0xff, 0x1c, 0xbb,
  0xe2, 0xf6, 0x4a, 0x94, 0xcf, 0x4e, 0x30, 0xb6, 0x52, 0xcc, 0xa3, 0x8a,
  0x4f, 0xde, 0x31, 0xf1, 0xa7, 0x9c, 0x8c, 0x89, 0x3e, 0xc8, 0x8d, 0x18,
  0x2a, 0x36, 0x2d, 0x71, 0xf4, 0x5a, 0x5b, 0xd6, 0xb7, 0xd8, 0xc7, 0xc5,
  0x6c, 0x09, 0xfc, 0x91, 0xb3, 0xba, 0xa4, 0x75, 0x0a, 0xd7, 0xbe, 0x70,
  0xed, 0xc4, 0x4d, 0x04, 0x79, 0x4c, 0xb3, 0xab, 0x2e, 0xfe, 0xca, 0x03,
  0x83, 0xa0, 0xee, 0xb3, 0xba, 0xe3, 0x28, 0xf5, 0xb3, 0xc5, 0x01, 0xc7,
  0x4c, 0xaf, 0x2c, 0xd1, 0x0a, 0x64, 0x9c, 0x31, 0x36, 0xe3, 0x08, 0xc3,
  0x8c, 0xf3, 0xe5, 0xa6, 0x94, 0x54, 0x5c, 0x8a, 0x42, 0x12, 0xad, 0x65,
  0xc7, 0x38, 0x92, 0xb0, 0x86, 0xf0, 0x5a, 0xe8, 0x13, 0xc9, 0xe0, 0x64,
  0x59, 0xa9, 0x6c, 0x4d, 0x17, 0x13, 0x23, 0x51, 0x5f, 0x3f, 0x0d, 0x6a,
  0x96, 0x2c, 0xa1, 0xda, 0xa7, 0xc9, 0x15, 0xcd, 0xb0, 0xe1, 0xe1, 0xd0,
  0xb3, 0xac, 0x89, 0x4b, 0x06, 0x84, 0x56, 0x98, 0xf2, 0xec, 0x1c, 0xa9,
  0x05, 0x91, 0xb0, 0x91, 0x3d, 0xc4, 0x98, 0x4c, 0xee, 0x84, 0xdb, 0xac,
  0xbb, 0xda, 0x7a, 0xe0, 0xf1, 0x96, 0x13, 0xf3, 0x9b, 0x34, 0x7e, 0x02,
  0xc3, 0x7a, 0x9b, 0x47, 0xd7, 0xa1, 0xbd, 0x35, 0xc3, 0xd0, 0x52, 0xe5,
  0x22, 0x75, 0x54, 0x20, 0x17, 0xb2, 0x48, 0xd3, 0x00, 0xf4, 0x65, 0xe5,
  0x79, 0x90, 0x13, 0xad, 0x86, 0x74, 0xf8, 0xd7, 0x5f, 0x09, 0x27, 0xc2,
  0xff, 0x67, 0x94, 0x51, 0x60, 0x3b, 0xe2, 0x1d, 0x3a, 0x85, 0xf2, 0xe5,
  0x77, 0x19, 0x47, 0x4b, 0xbe, 0x41, 0x7c, 0x3a, 0x21, 0x53, 0x58, 0x37,
  0x16, 0x44, 0xf2, 0xe1, 0xc7, 0x16, 0xc3, 0x70, 0xd2, 0x46, 0x42, 0x42,
  0xd6, 0x13, 0xfb, 0xb4, 0x34, 0x48, 0x5e, 0x31, 0x41, 0xa3, 0x4a, 0xa6,
  0x1c, 0x28, 0x1f, 0xf3, 0xdb, 0x94, 0x90, 0xad, 0x98, 0xa6, 0x7a, 0xf1,
  0x10, 0x85, 0x55, 0x24, 0xf5, 0x0e, 0x68, 0x28, 0x31, 0xbf, 0xb1, 0x58,
  0x20, 0x45, 0xd2, 0xbe, 0x4d, 0x7c, 0x4e, 0x6d, 0x27, 0xb6, 0x29, 0xbb,
  0xef, 0xee, 0x86, 0x0c, 0x21, 0xb4, 0x95, 0x4c, 0xbe, 0x1d, 0x2e, 0xc3,
  0xa0, 0x98, 0xb3, 0xbf, 0xe0, 0x64, 0x2d, 0x18, 0xf9, 0x06, 0x6d, 0x73,
  0x9b, 0x30, 0xc9, 0xf2, 0x85, 0x7e, 0x03, 0x56, 0x4d, 0x97, 0x75, 0x91,
  0xce, 0x24, 0x7c, 0x73, 0x4a, 0x80, 0x16, 0x8e, 0x7f, 0xe7, 0x7e, 0xb0,
  0xcd, 0x8f, 0x1e, 0x03, 0x8e, 0x8b, 0x81, 0xb0, 0x52, 0x79, 0x2b, 0x85,
  0xe3, 0xa0, 0x5d, 0xd3, 0xd3, 0x0b, 0x8a, 0x97, 0x3c, 0xe4, 0x91, 0x91,
  0xf5, 0x92, 0x8e, 0x0c, 0x9b, 0xd1, 0xfd, 0xc0, 0x01, 0x2c, 0x69, 0x94,
  0x44, 0xbb, 0x5a, 0x79, 0xb1, 0x51, 0x7a, 0xa0, 0x3d, 0x6e, 0x99, 0x64,
  0x41, 0x21, 0x48, 0xd9, 0x6c, 0xa0, 0x54, 0x85, 0x93, 0x17, 0x59, 0xe8,
  0xed, 0x59, 0xa2, 0x8d, 0x0d, 0xa0, 0x89, 0x16, 0x1d, 0x3d, 0x69, 0xc3,
  0x33, 0x1c, 0x02, 0xe5, 0x6b, 0xf7, 0x0c, 0x63, 0x27, 0x71, 0x26, 0xd8,
  0xdc, 0x56, 0x14, 0x56, 0x6f, 0xae, 0x8b, 0x37, 0x15, 0x5d, 0x00, 0xb6,
  0x00, 0xe1, 0x5d, 0x0a, 0x16, 0x85, 0xe4, 0x60, 0xcc, 0x56, 0x08, 0x25,
  0xff, 0xb0, 0x13, 0x7e, 0x9a, 0x80, 0x14, 0x57, 0xc4, 0x01, 0xf9, 0x26,
  0xb7, 0xe0, 0xd1, 0x35, 0x96, 0x6c, 0x20, 0x60, 0xc9, 0xb7, 0xda, 0x4e,
  0x51, 0x5f, 0x39, 0xb7, 0xca, 0x83, 0x50, 0x77, 0x35, 0xbf, 0x6b, 0x66,
  0xbc, 0x55, 0x23, 0x69, 0x7c, 0x01, 0x8a, 0xfb, 0x2d, 0xc3, 0x76, 0x39,
  0x57, 0x54, 0xd2, 0x19, 0x76, 0x53, 0x90, 0xf6, 0x23, 0x69, 0xce, 0x91,
  0x24, 0x83, 0x44, 0x81, 0xab, 0xe4, 0x7f, 0xb7, 0xac, 0xe5, 0x78, 0x40,
  0x93, 0x57, 0xcb, 0xf2, 0x8f, 0x87, 0xf5, 0x97, 0x27, 0xcf, 0x66, 0xc5,
  0x61, 0xb8, 0x3e, 0x43, 0x61, 0xd4, 0xb0, 0xa6, 0x06, 0x58, 0x78, 0x89,
  0xa6, 0x2d, 0x35, 0x01, 0xa4, 0xc9, 0x4f, 0x19, 0xe2, 0x02, 0xd8, 0x09,
  0x9a, 0x7b, 0xab, 0xeb, 0xb5, 0xc0, 0xfd, 0x45, 0x42, 0x49, 0xea, 0x37,
  0x3f, 0xe4, 0x90, 0x96, 0x41, 0x5b, 0x72, 0x92, 0x3c, 0xcf, 0xb0, 0x23,
  0x8e, 0x10, 0x66, 0x52, 0x14, 0xde, 0x12, 0x2b, 0xde, 0xf5, 0xb2, 0x53,
  0x01, 0xb1, 0xb7, 0xb3, 0x5b, 0xc5, 0x28, 0xea, 0x89, 0xfe, 0x7b, 0x9c,
  0x8c, 0x6c, 0x48, 0xbe, 0xf9, 0xfe, 0x5e, 0x6e, 0x82, 0xb2, 0x6c, 0x97,
  0x6e, 0x19, 0x8c, 0x8b, 0xcc, 0xc4, 0x9c, 0x8d, 0x55, 0x50, 0x99, 0x28,
  0xaf, 0x72, 0xe5, 0x15, 0xf9, 0x0b, 0x05, 0x91, 0x89, 0x7c, 0x26, 0xd6,
  0x67, 0x77, 0xbf, 0xb8, 0x1f, 0xf2, 0x2b, 0x9a, 0x48, 0xd3, 0x83, 0x29,
  0x63, 0x5d, 0x7a, 0x41, 0xf1, 0x09, 0x31, 0xdd, 0x3b, 0x1e, 0xa3, 0xf7,
  0xca, 0x9e, 0x4a, 0x3b, 0x72, 0xa6, 0x12, 0xac, 0xbf, 0x8d, 0xd2, 0xf3,
  0xeb, 0xe3, 0xc8, 0x7f, 0x58, 0xcd, 0xb0, 0xf5, 0x33, 0x3b, 0x56, 0x4c,
  0x4d, 0x4d, 0xde, 0xba, 0xca, 0xa3, 0x3a, 0x5b, 0x9d, 0xee, 0x2c, 0x7c,
  0xe1, 0xf3, 0x03, 0xad, 0x7a, 0xab, 0x5f, 0x9d, 0x65, 0xc7, 0x61, 0x16,
  0x8d, 0x2a, 0x6b, 0xab, 0x00, 0x49, 0x32, 0x89, 0x0a, 0x2f, 0xf3, 0xf0,
  0x64, 0x2a, 0xe2, 0x99, 0x1c, 0x0c, 0x19, 0xcf, 0xa1, 0x68, 0xbe, 0xb2,
  0x55, 0xd1, 0x97, 0x01, 0x23, 0xa9, 0xd3, 0x8b, 0xb5, 0x7e, 0xe0, 0xa8,
  0xe3, 0x14, 0x8b, 0xd8, 0x84, 0x1c, 0x7b, 0x8c, 0xcd, 0x61, 0xd8, 0x67,
  0x79, 0x26, 0x06, 0x40, 0x71, 0x0c, 0x8c, 0x10, 0x79, 0x2b, 0x46, 0xbd,
  0xf6, 0x5d, 0x68, 0xb8, 0x21, 0xc8, 0x60, 0x57, 0x24, 0x88, 0x6a, 0x7c,
  0x69, 0xa9, 0x7d, 0xcb, 0x27, 0xef, 0x92, 0x36, 0x4c, 0xcc, 0xc8, 0x8e,
  0xff, 0x42, 0xda, 0xff, 0x49, 0xc9, 0xf7, 0x10, 0xb7, 0xa3, 0xa6, 0xae,
  0x33, 0xa8, 0x1b, 0xb9, 0x58, 0x29, 0xeb, 0x07, 0xe7, 0x65, 0x45, 0xcf,
  0xee, 0x03, 0x15, 0x87, 0x9c, 0x34, 0x97, 0x1b, 0x72, 0x2e, 0x00, 0x50,
  0xa0, 0x29, 0xb0, 0xbd, 0x63, 0x65, 0x64, 0xcb, 0x42, 0x8b, 0x1f, 0x12,
  0x81, 0x5f, 0xe3, 0xe2, 0xce, 0x70, 0xf3, 0x24, 0x89, 0x4e, 0xae, 0x85,
  0xbf, 0xfb, 0x95, 0x1b, 0xc1, 0x69, 0xe2, 0x3a, 0xc3, 0xdd, 0x4f, 0xa0,
  0xfb, 0xe0, 0x0c, 0x08, 0x8c, 0xa0, 0x58, 0x5f, 0xe4, 0x59, 0xec, 0xff,
  0x18, 0x0b, 0x0d, 0xe6, 0x30, 0x5b, 0x74, 0x79, 0xd0, 0x05, 0x8f, 0xfa,
  0xe8, 0xb4, 0x57, 0x44, 0x23, 0x97, 0x08, 0x84, 0xd7, 0xed, 0x37, 0x9c,
  0x32, 0x8e, 0xd1, 0xe0, 0xbb, 0xc2, 0x58, 0xc3, 0x1d, 0x96, 0xfe, 0x58,
  0x65, 0xd9, 0x00, 0x9a, 0x44, 0x02, 0x6f, 0x6e, 0xfc, 0xd8, 0x4e, 0xf4,
  0xb2, 0xf8, 0xd7, 0xdf, 0xbc, 0xa4, 0x62, 0xbd, 0x2d, 0x20, 0x90, 0xb8,
  0xac, 0x7a, 0x52, 0xd8, 0x25, 0x4a, 0xd2, 0x4f, 0x46, 0x01, 0x0e, 0x8c,
  0x48, 0x79, 0x0a, 0xac, 0x47, 0xf7, 0xd4, 0x8c, 0xce, 0x9d, 0x89, 0x13,
  0x01, 0x70, 0xf7, 0xd1, 0x4d, 0x7e, 0x09, 0xa0, 0x0e, 0x42, 0x05, 0xe3,
  0x7a, 0x9b, 0x88, 0xdc, 0x30, 0x17, 0x55, 0xb0, 0x7e, 0xc8, 0xe0, 0x74,
  0x35, 0xdb, 0x2f, 0x52, 0xbb, 0xbd, 0x0a, 0x85, 0x28, 0xf1, 0x62, 0x33,
  0x3c, 0xe5, 0x35, 0xe9, 0xdc, 0x41, 0xd9, 0x26, 0xa4, 0x5a, 0x47, 0x1d,
  0x71, 0xab, 0xc5, 0xc0, 0xe0, 0xb7, 0x7e, 0xbf, 0xf5, 0x64, 0x49, 0x58,
  0x47, 0xb3, 0x42, 0x80, 0xc2, 0xb2, 0x4a, 0x8e, 0x89, 0xd3, 0x37, 0xb8,
  0x7b, 0xe9, 0x43, 0x46, 0x12, 0xb3, 0x1f, 0x5f, 0x3c, 0x0e, 0x5b, 0xf4,
  0xea, 0xec, 0x85, 0x59, 0xcb, 0x97, 0xfe, 0x9d, 0x39, 0x9d, 0x28, 0x53,
  0x9a, 0x41, 0x07, 0x8a, 0x46, 0x0e, 0xc5, 0x6d, 0x52, 0xf0, 0x2c, 0x69,
  0xab, 0xe0, 0xdc, 0x49, 0x9a, 0x39, 0x08, 0xc7, 0x23, 0xa9, 0x77, 0x5d,
  0x82, 0x3a, 0x2e, 0xc2, 0x14, 0x4a, 0x0b, 0x1a, 0x56, 0x3c, 0x02, 0x16,
  0x08, 0xed, 0xb0, 0x02, 0x24, 0x4f, 0xf3, 0xb9, 0xff, 0xc1, 0xc2, 0xeb,
  0xd5, 0xc4, 0x83, 0x48, 0x9e, 0xac, 0xff, 0x4a, 0x45, 0xcf, 0x52, 0x72,
  0xf5, 0x23, 0x92, 0x2c, 0x63, 0xd9, 0xbf, 0x55, 0x46, 0x54, 0x05, 0xdd,
  0xc2, 0xa9, 0x8c, 0xec, 0x20, 0xab, 0x13, 0x33, 0xc1, 0xdc, 0xcb, 0x63,
  0x50, 0xfe, 0xe2, 0x4a, 0x88, 0xfa, 0xf8, 0x81, 0x4b, 0x11, 0x39, 0xed,
  0x0b, 0x89, 0x8e, 0x2d, 0xa0, 0x37, 0x41, 0xfc, 0x86, 0x3c, 0x3e, 0x64,
  0x5d, 0x05, 0x12, 0x6d, 0x9b, 0x50, 0x5c, 0x29, 0x30, 0xb9, 0xe5, 0x49,
  0xb8, 0x17, 0x60, 0x35, 0x06, 0xd9, 0xb5, 0x30, 0xd4, 0x45, 0xbf, 0x06,
  0xed, 0x0f, 0x12, 0x12, 0x9d, 0x86, 0xc3, 0x87, 0xb9, 0x4f, 0x28, 0x68,
  0xb4, 0x60, 0xc6, 0xfb, 0xd0, 0x60, 0xed, 0x8c, 0x60, 0xa4, 0xfc, 0x81,
  0x79, 0x3d, 0x3f, 0x81, 0x0a, 0x9e, 0xd5, 0x80, 0xb2, 0x36, 0x4b, 0x69,
  0x23, 0xd6, 0xc1, 0xc6, 0xdc, 0x4d, 0x02, 0x73, 0x72, 0xb3, 0x31, 0xe3,
  0xd8, 0x9a, 0xb0, 0xed, 0x06, 0x7c, 0x4b, 0x17, 0xac, 0xae, 0x81, 0x9c,
  0xcb, 0xc5, 0xdc, 0x2b, 0x1c, 0xb0, 0x5a, 0x79, 0x3e, 0xe0, 0xaa, 0x6c,
  0x4a, 0x23, 0x5a, 0xe9, 0x7d, 0xa6, 0xc8, 0x5c, 0x63, 0x95, 0x20, 0xf1,
  0x5f, 0x2d, 0x28, 0x5c, 0x7d, 0x64, 0x3c, 0x5e, 0x99, 0x1c, 0x62, 0xf1,
  0x04, 0x9a, 0x10, 0xf4, 0xfc, 0xe4, 0x90, 0x56, 0x66, 0xe5, 0xaf, 0xaf,
  0xc1, 0xdd, 0x29, 0xd7, 0x17, 0xec, 0x9f, 0x0a, 0x32, 0x5e, 0xc2, 0xa0,
  0x77, 0x18, 0x73, 0x63, 0x4b, 0x26, 0x96, 0x07, 0x49, 0x1d, 0xcc, 0x6d,
  0x75, 0x33, 0xab, 0xdc, 0x47, 0x52, 0x64, 0x89, 0x98, 0xbb, 0x15, 0xec,
  0xfe, 0x73, 0xe6, 0x99, 0x32, 0x69, 0x1f, 0x11, 0x2d, 0xb1, 0xa5, 0x79,
  0x0b, 0x6b, 0x89, 0x63, 0x05, 0x31, 0xb5, 0xba, 0x1c, 0x10, 0x5b, 0x4a,
  0xc2, 0x5a, 0x94, 0x48, 0x76, 0x6f, 0xaa, 0x19, 0x7e, 0x9a, 0xb8, 0x65,
  0xde, 0x41, 0x77, 0xdc, 0x05, 0x87, 0xbd, 0xe0, 0x6c, 0xe5, 0x7d, 0x2c,
  0x0e, 0xb3, 0xf3, 0xe1, 0xfc, 0x26, 0x17, 0x1a, 0xdd, 0x66, 0x59, 0x6b,
  0x59, 0xef, 0x34, 0xb4, 0xc2, 0x2e, 0xb7, 0xff, 0xe3, 0x28, 0x04, 0xf3,
  0x50, 0xcd, 0x41, 0x90, 0xb6, 0x99, 0xbd, 0xb3, 0x08, 0x0c, 0xbc, 0x46,
  0xef, 0xde, 0x86, 0x94, 0x1f, 0x55, 0xb8, 0x74, 0x22, 0xf0, 0xf7, 0xeb,
  0x6e, 0xbf, 0x95, 0xff, 0xf7, 0xa8, 0xdd, 0x46, 0x52, 0x09, 0x1b, 0x34,
  0xe4, 0x2b, 0x4c, 0x89, 0x84, 0xc4, 0x9d, 0x4d, 0x62, 0xa7, 0x43, 0x00,
  0x76, 0x7e, 0x22, 0x48, 0x9b, 0xc6, 0xf0, 0x6a, 0xc5, 0x5c, 0x08, 0x28,
  0xd5, 0x1f, 0x12, 0xe4, 0x1f, 0xc5, 0x39, 0xeb, 0xd9, 0xb9, 0x09, 0x87,
  0xde, 0x42, 0xae, 0x0a, 0x36, 0xdb, 0x01, 0xcb, 0x69, 0xe9, 0x00, 0xec,
  0x2f, 0xfb, 0xb9, 0x65, 0x40, 0xa8, 0x29, 0x5b, 0x40, 0x9b, 0x53, 0xe4,
  0x90, 0x8c, 0x51, 0x7f, 0x0f, 0x8e, 0xab, 0x84, 0xd2, 0x39, 0xf3, 0x08,
  0x52, 0x6b, 0x69, 0x5c, 0x77, 0x36, 0xca, 0xe3, 0x6a, 0x95, 0x20, 0xb3,
  0x83, 0x8c, 0x4a, 0xb9, 0xc0, 0xd1, 0xf7, 0x92, 0x3e, 0x12, 0x3e, 0xc7,
  0x0e, 0x88, 0x55, 0x79, 0xf3, 0xcc, 0x94, 0x36, 0xa9, 0x1f, 0x10, 0x76,
  0xa7, 0xa4, 0x67, 0xb8, 0x93, 0x78, 0x1b, 0xca, 0xd1, 0x69, 0xe4, 0xb4,
  0xf5, 0x0d, 0xb9, 0x05, 0x63, 0x1c, 0x3a, 0x36, 0x1c, 0xae, 0x4c, 0x3a,
  0x47, 0x1a, 0x02, 0xac, 0x6a, 0x61, 0x58, 0x8c, 0xe3, 0x48, 0x2d, 0x72,
  0x3e, 0x1e, 0x22, 0x97, 0x48, 0x3a, 0x7b, 0xa1, 0xf3, 0xbc, 0xcd, 0x8d,
  0xbf, 0x69, 0x0e, 0x7e, 0xf0, 0x47, 0xfc, 0xdf, 0xa6, 0x37, 0xb0, 0x3d,
  0x0c, 0x83, 0xd5, 0x2b, 0x95, 0x7a, 0x4e, 0x72, 0x43, 0x03, 0xfa, 0xec,
  0x5b, 0x9c, 0x2e, 0x23, 0x66, 0xf6, 0x33, 0x42, 0xe6, 0xf5, 0x5f, 0x90,
  0x63, 0x72, 0xc5, 0x12, 0x02, 0x68, 0x9c, 0xf2, 0x85, 0xe2, 0x77, 0x10,
  0x75, 0x0e, 0x94, 0x4e, 0x8f, 0xec, 0xb2, 0x86, 0xc2, 0x3e, 0x71, 0xf3,
  0x38, 0x52, 0x9e, 0xd4, 0x43, 0xf2, 0x92, 0x6c, 0x22, 0xc3, 0x55, 0x9e,
  0x96, 0x15, 0xcf, 0xe5, 0x26, 0x0f, 0x58, 0x24, 0x53, 0xd0, 0xc1, 0x86,
  0xc4, 0x46, 0x49, 0x1f, 0x89, 0x0f, 0xb8, 0x8e, 0xeb, 0x82, 0xf4, 0x68,
  0x54, 0xd4, 0xf5, 0x98, 0x3a, 0xc0, 0x8d, 0x4e, 0xb8, 0x4f, 0xdb, 0xd0,
  0x36, 0x28, 0x74, 0x60, 0x2b, 0x54, 0x0b, 0x55, 0xf9, 0xc0, 0xd5, 0x50,
  0xac, 0x59, 0x90, 0xd8, 0x9c, 0x4e, 0x53, 0xbb, 0x94, 0x0e, 0xd8, 0x49,
  0x86, 0xc5, 0x6b, 0x6e, 0x11, 0x3e, 0x16, 0xab, 0x20, 0xb4, 0x2d, 0x19,
  0x3a, 0xf8, 0xc5, 0x84, 0xfb, 0xb3, 0xfc, 0x7d, 0x84, 0xfd, 0xf3, 0xa4,
  0x84, 0xe7, 0xae, 0x94, 0x2c, 0x8f, 0xdb, 0xf0, 0x9a, 0xdd, 0x91, 0xc9,
  0xbd, 0xdc, 0x1a, 0xca, 0xc2, 0x48, 0xa3, 0x72, 0x3e, 0x4c, 0x34, 0x13,
  0x56, 0x2b, 0x60, 0x78, 0x21, 0x9b, 0xd1, 0x9d, 0xec, 0x15, 0x9f, 0x23,
  0x90, 0x88, 0xf5, 0x0f, 0xf1, 0x32, 0x5f, 0xd0, 0xc0, 0xac, 0xa9, 0x51,
  0xd5, 0x5b, 0x38, 0x55, 0xba, 0xf5, 0x40, 0x6f, 0x92, 0x64, 0xf0, 0xda,
  0x83, 0xd2, 0x10, 0xf2, 0xf2, 0xa9, 0x17, 0x09, 0xe3, 0xcf, 0x86, 0x1c,
  0xb3, 0x04, 0x7f, 0xc5, 0x61, 0x7a, 0x48, 0x8b, 0x84, 0x3c, 0x73, 0xee,
  0x37, 0xd4, 0x47, 0x1c, 0x11, 0xcf, 0x4c, 0x2e, 0x24, 0x42, 0x4a, 0x48,
  0x70, 0xfd, 0x33, 0x65, 0x62, 0x44, 0xce, 0xf0, 0x11, 0x5f, 0xbd, 0x06,
  0x53, 0xd9, 0x40, 0x4b, 0x74, 0x78, 0x7a, 0x36, 0x26, 0x67, 0x91, 0x48,
  0x84, 0x44, 0x44, 0x21, 0x1c, 0x3a, 0x60, 0xf7, 0x07, 0x98, 0x71, 0x98,
  0xb8, 0xd1, 0x25, 0x9d, 0xb2, 0x8f, 0xe4, 0x77, 0x4c, 0x3a, 0x81, 0x6c,
  0xf0, 0x7a, 0x61, 0x33, 0x60, 0xd4, 0x26, 0xc0, 0x6d, 0x25, 0xfb, 0xfe,
  0xa6, 0x2e, 0x08, 0x42, 0xd9, 0x6b, 0xc0, 0x30, 0x09, 0x80, 0x2a, 0x03,
  0x85, 0xbe, 0x8d, 0xae, 0x4d, 0xba, 0x88, 0x4a, 0xd0, 0xb1, 0xf7, 0x41,
  0x41, 0xa2, 0xad, 0x58, 0x04, 0x8c, 0x21, 0xb1, 0x50, 0x04, 0x48, 0x88,
  0x08, 0x02, 0xdc, 0xbf, 0x70, 0xcc, 0xed, 0xa6, 0xbc, 0x5b, 0xba, 0x23,
  0xf5, 0x95, 0x61, 0x7f, 0xb2, 0x75, 0x39, 0x94, 0x4e, 0x80, 0x37, 0x3d,
  0x66, 0xab, 0x4b, 0x14, 0xe7, 0x35, 0xca, 0xfe, 0x14, 0xf0, 0xc0, 0x25,
  0x21, 0x75, 0x03, 0xb1, 0xab, 0xde, 0xb3, 0xca, 0xd1, 0xb1, 0xa5, 0x90,
  0x7e, 0x18, 0x13, 0x74, 0xdb, 0x55, 0x24, 0x73, 0x3b, 0xf5, 0xba, 0x1c,
  0xc6, 0x04, 0x01, 0x60, 0x8d, 0xb1, 0xc0, 0x1d, 0xa7, 0x6f, 0x7b, 0xbd,
  0xb4, 0x5c, 0x07, 0x1d, 0xed, 0xc2, 0xf3, 0xcb, 0x84, 0xaf, 0x9f, 0xbb,
  0xa9, 0x6f, 0x56, 0x5a, 0x3a, 0x49, 0xb4, 0xae, 0x18, 0x63, 0xc1, 0xb5,
  0xc7, 0xc5, 0xa5, 0xc8, 0x55, 0x5c, 0xda, 0xdc, 0x6a, 0xcf, 0xf4, 0xf7,
  0xe9, 0x69, 0x21, 0x34, 0x50, 0x8e, 0x79, 0x4a, 0x49, 0x14, 0x5b, 0x55,
  0x2f, 0x3e, 0x9a, 0x9e, 0xa8, 0x4e, 0xe5, 0x0f, 0xcd, 0x32, 0x14, 0x71,
  0xba, 0x72, 0xa0, 0x02, 0x87, 0xdd, 0x59, 0x0c, 0x85, 0x8d, 0xfd, 0xea,
  0x60, 0x4d, 0xc5, 0xd0, 0x07, 0xc4, 0x18, 0xf3, 0x50, 0x4e, 0x5b, 0xce,
  0x43, 0x13, 0x89, 0x08, 0xb4, 0xee, 0x7c, 0x75, 0x1e, 0xfc, 0x09, 0xfc,
  0xd1, 0xa7, 0x5f, 0x0f, 0xa5, 0xed, 0x8d, 0x90, 0x66, 0xbe, 0x5a, 0x8a,
  0xf2, 0x81, 0x97, 0xac, 0x69, 0x18, 0x73, 0x92, 0xf4, 0xce, 0x3a, 0xdf,
  0x82, 0xbd, 0x14, 0xe1, 0xf2, 0x45, 0xdd, 0x64, 0xcc, 0xe9, 0xa9, 0xac,
  0x79, 0xa8, 0xa4, 0xec, 0x2d, 0x4c, 0xd1, 0x70, 0xc3, 0xe5, 0x9e, 0xd0,
  0x2c, 0xd1, 0xe3, 0x35, 0x7b, 0xe5, 0xe8, 0xda, 0x26, 0xd6, 0x43, 0x23,
  0xed, 0x3c, 0x06, 0x5b, 0x1a, 0x50, 0x17, 0xbb, 0xe6, 0x40, 0x0b, 0xc7,
  0xc2, 0x44, 0x4f, 0xf4, 0xdd, 0xed, 0xe4, 0xbe, 0x5c, 0xb2, 0xb9, 0x72,
  0xbd, 0xe3, 0x72, 0x43, 0x4a, 0xba, 0x37, 0xe1, 0xa8, 0x39, 0x09, 0x20,
  0xb0, 0x2b, 0x73, 0x41, 0xf8, 0xb3, 0x26, 0xcd, 0x35, 0xe7, 0x8b, 0x41,
  0x1d, 0xea, 0xb0, 0x29, 0x51, 0x8b, 0xe4, 0x8d, 0x8a, 0xb8, 0x66, 0xcc,
  0xc8, 0x47, 0xf9, 0x32, 0x2c, 0x13, 0x30, 0xe9, 0x93, 0xa9, 0x9a, 0xf4,
  0xd5, 0x34, 0x0f, 0x8a, 0x38, 0x9b, 0x72, 0x41, 0xb4, 0x56, 0x5f, 0xb9,
  0x46, 0x6d, 0x7c, 0xab, 0xb8, 0x1a, 0xc6, 0x3e, 0xf9, 0xc5, 0x51, 0x97,
  0x53, 0x51, 0x86, 0x84, 0x14, 0xf1, 0x06, 0x1e, 0xf4, 0x45, 0x59, 0xa6,
  0xcd, 0xc1, 0x0e, 0x2c, 0xfe, 0x9b, 0x81, 0xf1, 0xe7, 0x57, 0xc1, 0x84,
  0x6f, 0x11, 0x60, 0xcf, 0xc7, 0xe5, 0xfb, 0x45, 0x38, 0xc1, 0xbb, 0x4e,
  0xb5, 0x9f, 0xe0, 0xbf, 0xfe, 0x06, 0x6d, 0xed, 0x65, 0x67, 0x07, 0xb0,
  0x3e, 0xf9, 0xc5, 0xcc, 0x11, 0x81, 0xe2, 0x61, 0x18, 0xf5, 0xae, 0x97,
  0xcc, 0x25, 0xe9, 0xf4, 0x4a, 0xe4, 0xbd, 0x14, 0xa7, 0x7d, 0x2d, 0x9f,
  0x50, 0x12, 0xff, 0xbf, 0x6f, 0xcc, 0x23, 0x13, 0x35, 0xdb, 0xb9, 0xcb,
  0xbc, 0x5a, 0x62, 0x84, 0x6a, 0x43, 0x64, 0x76, 0xeb, 0xfe, 0x95, 0x3c,
  0xdb, 0x4a, 0x6e, 0x61, 0x9d, 0xcb, 0xc5, 0x0b, 0xee, 0x30, 0x77, 0xc4,
  0x7d, 0x71, 0x6a, 0x5f, 0xff, 0x08, 0x53, 0x22, 0xd1, 0x7f, 0xcf, 0xc4,
  0x1a, 0x5e, 0x40, 0xc6, 0x4d, 0x42, 0x46, 0x62, 0xd1, 0x2d, 0x06, 0x08,
  0x59, 0x2c, 0x6b, 0x06, 0x6a, 0x65, 0xe2, 0x9c, 0x10, 0xef, 0x5e, 0x6b,
  0x41, 0xc2, 0xc0, 0xcd, 0x75, 0x47, 0x4c, 0xb6, 0xbe, 0x4f, 0x27, 0x82,
  0x25, 0xa5, 0x38, 0x0f, 0x35, 0x18, 0x49, 0xce, 0xc6, 0x8b, 0xa4, 0xf8,
  0xe6, 0xa4, 0xff, 0x3a, 0x52, 0x69, 0x7b, 0xcc, 0x11, 0x99, 0xf8, 0x02,
  0xf5, 0x28, 0x09, 0x49, 0xb1, 0xa7, 0x14, 0xfe, 0x4c, 0xc4, 0x87, 0x73,
  0x96, 0x94, 0xcc, 0xc4, 0x09, 0x77, 0x14, 0x50, 0xc4, 0x90, 0x7b, 0x19,
  0x6a, 0x2b, 0xc7, 0x07, 0x36, 0x49, 0x11, 0xfb, 0xaa, 0xa6, 0x15, 0x88,
  0x95, 0x7c, 0x94, 0xfa, 0xe3, 0x9b, 0xfe, 0x3e, 0x0f, 0xbf, 0x97, 0x51,
  0xb7, 0x11, 0xdc, 0xbf, 0xce, 0xd0, 0xd4, 0x1e, 0x6e, 0x89, 0x21, 0x0c,
  0x6f, 0x30, 0x31, 0xf1, 0x9d, 0xb6, 0x21, 0x6e, 0x50, 0xc8, 0x78, 0xac,
  0x60, 0x77, 0xab, 0x26, 0xd6, 0xda, 0x50, 0x95, 0x8e, 0xcc, 0x90, 0x1b,
  0xa0, 0x64, 0x11, 0x65, 0x6e, 0x79, 0x3e, 0x5c, 0xe6, 0x77, 0x3d, 0x5e,
  0xdf, 0xb5, 0x72, 0x7d, 0x29, 0x23, 0xb8, 0xcb, 0x44, 0x29, 0x9f, 0x88,
  0x9b, 0xae, 0xd7, 0xb0, 0x1a, 0xd5, 0xb0, 0x3c, 0x96, 0x41, 0xb6, 0xa2,
  0x81, 0x40, 0xe4, 0xe0, 0xd6, 0x3e, 0x2e, 0x1f, 0x00, 0x66, 0x9b, 0x0c,
  0x6b, 0x12, 0x7d, 0x9d, 0x6e, 0x84, 0x48, 0xc9, 0xc8, 0x2c, 0x48, 0xd5,
  0x52, 0x93, 0x67, 0x2b, 0x64, 0x86, 0x5e, 0x5b, 0x70, 0x51, 0x14, 0x0a,
  0x00, 0x87, 0xed, 0xb3, 0xfa, 0x91, 0x2a, 0x0a, 0x5d, 0x8b, 0xbe, 0xc9,
  0x15, 0xff, 0x5f, 0xc9, 0x8f, 0xed, 0x2f, 0x1f, 0xf1, 0x43, 0x91, 0xfa,
  0x6b, 0x05, 0xc2, 0xa5, 0x14, 0x89, 0x67, 0xd2, 0x21, 0xce, 0x1e, 0xf4,
  0xee, 0xce, 0x41, 0xcb, 0xa2, 0xc4, 0x37, 0xb3, 0x16, 0xc2, 0x78, 0x46,
  0xe0, 0x9a, 0x8c, 0xe3, 0x3f, 0xd5, 0x2d, 0x94, 0xad, 0xd3, 0xbb, 0x00,
  0x36, 0x39, 0xaa, 0xdf, 0xd8, 0xd6, 0x19, 0x46, 0x85, 0x78, 0xa0, 0x02,
  0x80, 0xce, 0xb5, 0x59, 0x04, 0xbd, 0xef, 0xdb, 0xeb, 0xd2, 0x39, 0x4e,
  0xae, 0x68, 0x7a, 0x99, 0xaa, 0x97, 0x2a, 0x86, 0xfb, 0x9b, 0x7f, 0x37,
  0x59, 0x19, 0x50, 0x34, 0x75, 0xcf, 0xd6, 0xc6, 0x29, 0x4c, 0x79, 0x67,
  0x3a, 0x13, 0xed, 0xfb, 0xf8, 0x1e, 0xda, 0x20, 0x49, 0xed, 0xd9, 0x62,
  0xeb, 0xfa, 0xf2, 0x03, 0x3e, 0x68, 0x20, 0x79, 0x03, 0x57, 0xba, 0x07,
  0x2d, 0x87, 0x2d, 0x17, 0x2a, 0x51, 0x05, 0x65, 0xa3, 0x99, 0x55, 0x32,
  0x07, 0x16, 0x0e, 0xd3, 0xf2, 0x9a, 0x15, 0x69, 0xcf, 0xc5, 0xc5, 0xff,
  0xf0, 0x4d, 0xe2, 0xb8, 0xdd, 0xfd, 0x95, 0x11, 0x87, 0xb5, 0xb5, 0xe1,
  0x7a, 0x75, 0xf2, 0xd5, 0x4d, 0xa0, 0x62, 0x07, 0xf7, 0x3d, 0xc7, 0xbd,
  0x9a, 0xf7, 0x4b, 0x86, 0x15, 0x71, 0x65, 0x41, 0xe0, 0xea, 0xa0, 0x47,
  0xb2, 0xf7, 0x4f, 0xe7, 0x95, 0x4c, 0xb9, 0x1c, 0x37, 0x36, 0x5c, 0x9b,
  0x19, 0x1e, 0xc9, 0xa1, 0x36, 0x05, 0xb1, 0xc2, 0x14, 0xe1, 0x71, 0x0c,
  0xa8, 0x97, 0xf0, 0xfe, 0x5b, 0xf0, 0x96, 0x81, 0x73, 0x90, 0x2f, 0x91,
  0xdb, 0x0d, 0x08, 0x9e, 0xe0, 0x78, 0x90, 0xa1, 0x81, 0xc5, 0x7c, 0xba,
  0xe3, 0x5c, 0x5e, 0x02, 0x70, 0x37, 0x60, 0x26, 0x94, 0x3f, 0xd9, 0x73,
  0xcb, 0xa0, 0x32, 0xfd, 0xd0, 0x75, 0x86, 0x8b, 0xa0, 0x6d, 0x20, 0xbc,
  0x9f, 0xf2, 0x62, 0xfb, 0xd2, 0xb0, 0xee, 0x30, 0xad, 0x32, 0xca, 0x8b,
  0xc8, 0xeb, 0xc9, 0x12, 0x0b, 0x95, 0x02, 0x59, 0xf0, 0x3a, 0x8c, 0x04,
  0x6b, 0x26, 0x5f, 0x57, 0x19, 0x64, 0xe7, 0x00, 0xba, 0x87, 0x1f, 0x1b,
  0xee, 0xe8, 0x91, 0x25, 0x61, 0xd4, 0xad, 0xd0, 0xc6, 0x62, 0xfe, 0xdc,
  0x98, 0x25, 0xa0, 0x18, 0x4c, 0x07, 0x79, 0xb5, 0x29, 0xb0, 0xed, 0x73,
  0x25, 0xf5, 0xa7, 0x1d, 0xd3, 0x60, 0xd0, 0x17, 0xf2, 0xd5, 0x21, 0xbc,
  0xeb, 0x9e, 0x41, 0xf7, 0xf8, 0x0c, 0x69, 0x63, 0xcb, 0xe1, 0xaf, 0x7a,
  0x79, 0xf2, 0x37, 0x6f, 0x27, 0x37, 0x0d, 0x3c, 0x15, 0x43, 0x81, 0x4d,
  0x92, 0x16, 0x3d, 0x14, 0x7b, 0x0d, 0x18, 0x65, 0xf2, 0xaa, 0x12, 0x1e,
  0x73, 0x61, 0x26, 0xde, 0x3a, 0x77, 0xdb, 0x29, 0xe3, 0x8b, 0xab, 0x00,
  0xfe, 0x2f, 0x8b, 0x75, 0x5e, 0x5d, 0xe1, 0x36, 0xd3, 0x39, 0x9e, 0x1e,
  0x0c, 0x8c, 0x2f, 0x41, 0xbc, 0x4b, 0x6c, 0xa0, 0xe6, 0x59, 0x60, 0x06,
  0xfa, 0x55, 0xb0, 0xe5, 0x96, 0x08, 0xeb, 0xce, 0x23, 0x18, 0xbe, 0x70,
  0x55, 0x45, 0xe4, 0x5e, 0xde, 0xcf, 0x9c, 0xde, 0xea, 0x89, 0xf2, 0x4c,
  0xd3, 0xd1, 0xcd, 0x0a, 0x5b, 0x7f, 0x21, 0x1d, 0xdd, 0xc2, 0x8e, 0x5a,
  0x71, 0x01, 0xb9, 0xda, 0x35, 0xda, 0xc6, 0x58, 0xbc, 0x80, 0x5a, 0xa5,
  0xd5, 0x62, 0xb5, 0xf1, 0xb8, 0xe0, 0x3d, 0x02, 0x1b, 0x12, 0x5d, 0xe6,
  0xc8, 0x8a, 0x04, 0x4c, 0xab, 0x36, 0xcd, 0x64, 0xe0, 0xd1, 0xf2, 0x6d,
  0x9a, 0x60, 0xc5, 0xee, 0xba, 0xaa, 0x9e, 0xf5, 0x75, 0x67, 0xc8, 0x0d,
  0xc3, 0xc2, 0xcd, 0x95, 0xc9, 0x68, 0xf0, 0xb7, 0x1f, 0xad, 0xcd, 0x16,
  0x6f, 0xe8, 0xd4, 0x85, 0xd4, 0xaf, 0x2f, 0x9b, 0x01, 0x86, 0x01, 0x3a,
  0x78, 0x12, 0xdc, 0xe2, 0xfb, 0xdd, 0xf0, 0x7b, 0x0b, 0x9e, 0x5c, 0xc5,
  0xd3, 0x33, 0x80, 0x1f, 0x31, 0xcf, 0x3a, 0x66, 0xb8, 0xe7, 0x0e, 0x35,
  0x67, 0x36, 0x92, 0x04, 0x87, 0x06, 0xda, 0x34, 0xdb, 0xdd, 0x2e, 0xf0,
  0x77, 0x8b, 0xff, 0x58, 0x10, 0xf6, 0x0c, 0xe2, 0x75, 0x97, 0xe8, 0x66,
  0x6b, 0x9d, 0xde, 0xd8, 0x77, 0x80, 0xd9, 0x1b, 0xf0, 0xf5, 0xa1, 0xe4,
  0x57, 0x1c, 0x96, 0x8b, 0x3f, 0xae, 0x61, 0xbe, 0xb9, 0x0c, 0xe3, 0xa1,
  0xbd, 0xfe, 0x50, 0x36, 0xe2, 0xb9, 0x92, 0x8f, 0xc9, 0x39, 0xc4, 0xe7,
  0x25, 0x1f, 0x86, 0x76, 0xa4, 0x9b, 0x5a, 0x46, 0x60, 0x30, 0xbf, 0x9b,
  0xf2, 0x68, 0xed, 0x02, 0xf1, 0xeb, 0x7d, 0x1c, 0x6b, 0x3c, 0x0c, 0x5d,
  0x43, 0xd0, 0x89, 0x64, 0x15, 0xfe, 0x54, 0x3c, 0xc7, 0xc0, 0x14, 0xe3,
  0x75, 0x3a, 0xfa, 0x86, 0xdd, 0xd6, 0x24, 0xd6, 0xc3, 0x46, 0x82, 0x1b,
  0x4b, 0xb4, 0x05, 0xb9, 0xd1, 0x9a, 0x91, 0x2c, 0x5e, 0x05, 0xc1, 0xee,
  0x57, 0x08, 0x99, 0x07, 0xa6, 0x1b, 0x96, 0xbc, 0x3e, 0x14, 0x4f, 0xce,
  0x15, 0x29, 0x95, 0xc9, 0xc7, 0x7c, 0x8f, 0xb0, 0x74, 0x52, 0x21, 0xaa,
  0xa7, 0x18, 0x34, 0x88, 0x51, 0xec, 0xc5, 0x48, 0x8f, 0xaa, 0x80, 0xe1,
  0x81, 0xa3, 0xf1, 0x84, 0x31, 0xc2, 0xc9, 0xe6, 0xbb, 0xc8, 0xa6, 0xb2,
  0xed, 0x5f, 0x3d, 0x04, 0xb7, 0xde, 0xb9, 0x88, 0xe7, 0x47, 0xe6, 0x66,
  0xd9, 0x89, 0xd6, 0xbe, 0x6c, 0x74, 0x49, 0x0a, 0xe5, 0x55, 0xbe, 0xab,
  0x9f, 0x86, 0x80, 0x36, 0x82, 0x2d, 0xb5, 0x4d, 0xe6, 0x75, 0x12, 0xd0,
  0xa3, 0x78, 0x0d, 0x0a, 0xaf, 0x4a, 0x7a, 0x5a, 0x77, 0x29, 0x81, 0x93,
  0x60, 0xee, 0xe3, 0xf9, 0xc5, 0x0b, 0x42, 0xcf, 0x80, 0x3c, 0x9c, 0x0e,
  0x84, 0x1c, 0x3f, 0xab, 0x8d, 0x9d, 0xaa, 0x41, 0xb6, 0x22, 0x3f, 0x04,
  0x96, 0x8b, 0x0c, 0xc0, 0x2c, 0xf3, 0xd3, 0x63, 0xc7, 0x79, 0xd7, 0xed,
  0x90, 0xf8, 0xe6, 0x37, 0x90, 0x3a, 0xb4, 0xb1, 0xf6, 0x7c, 0x0f, 0xf2,
  0xd3, 0x79, 0xc2, 0xe1, 0xbf, 0x80, 0x9a, 0xd6, 0x0d, 0x9a, 0x6e, 0xdb,
  0xb1, 0x67, 0x95, 0x32, 0x93, 0xde, 0x2d, 0x27, 0x99, 0x4d, 0x7d, 0xfc,
  0x83, 0xb0, 0xc3, 0x7b, 0x02, 0x9a, 0xfc, 0x1f, 0x58, 0xf4, 0xea, 0xba,
  0x55, 0x68, 0xf2, 0x42, 0xf9, 0xe4, 0xce, 0x34, 0xa2, 0xf3, 0x7d, 0x0e,
  0x02, 0x12, 0xe4, 0x89, 0x04, 0x44, 0x27, 0xf8, 0x46, 0xeb, 0xac, 0x98,
  0xa2, 0x99, 0x35, 0x5f, 0x3b, 0x83, 0x42, 0x79, 0x95, 0xf0, 0x85, 0xb0,
  0xbb, 0x8a, 0x12, 0x2f, 0xd2, 0xa9, 0xc8, 0x9f, 0x96, 0xbc, 0x44, 0x49,
  0x21, 0xde, 0x15, 0x03, 0x04, 0x50, 0x3d, 0x7b, 0x5a, 0xcf, 0x02, 0x3b,
  0xa1, 0xb3, 0x6b, 0xaf, 0x53, 0x0c, 0x98, 0xb7, 0xfa, 0x6c, 0x82, 0x3e,
  0x9f, 0x18, 0x55, 0x2e, 0xda, 0xb3, 0x70, 0xf3, 0x79, 0xb3, 0x18, 0xd6,
  0x1b, 0xb4, 0xa1, 0x3b, 0xc9, 0x7d, 0x3e, 0x52, 0x66, 0xdf, 0x99, 0xdf,
  0xd5, 0xd4, 0xb1, 0x33, 0x2c, 0x7f, 0xa8, 0x09, 0xd7, 0x26, 0x62, 0x5e,
  0xeb, 0x51, 0xfa, 0x29, 0x6a, 0xa4, 0x3d, 0xa5, 0xbe, 0x37, 0x04, 0x85,
  0x92, 0xc3, 0xe3, 0xe1, 0xa3, 0xcd, 0x09, 0xf6, 0x2e, 0xb1, 0xdb, 0x21,
  0x88, 0x67, 0x4e, 0x2d, 0x0e, 0x28, 0x78, 0x1a, 0xc1, 0xb6, 0x01, 0x72,
  0x15, 0x04, 0x75, 0x1b, 0xd3, 0x15, 0xaf, 0x33, 0x08, 0x13, 0x5c, 0xbf,
  0x90, 0xc6, 0x78, 0x6f, 0xf0, 0xec, 0x0e, 0x99, 0x9f, 0xae, 0xd6, 0xa2,
  0xbb, 0x83, 0x0f, 0xfc, 0x7d, 0x3e, 0xe9, 0xce, 0x88, 0xd9, 0xef, 0xff,
  0x00, 0xdd, 0x62, 0xeb, 0x64, 0xaa, 0xc0, 0x69, 0x46, 0x9e, 0x18, 0x54,
  0x2d, 0xf8, 0x4c, 0xa2, 0x47, 0x24, 0x89, 0xfd, 0xd7, 0x99, 0xac, 0xf8,
  0x6c, 0xb3, 0xa3, 0xb1, 0x83, 0xed, 0x62, 0xca, 0xf6, 0x9e, 0x96, 0xb4,
  0x2d, 0x44, 0x19, 0x9e, 0xd0, 0x73, 0xaa, 0xc1, 0xd2, 0xd7, 0x4f, 0x58,
  0x0f, 0x8b, 0xf1, 0x60, 0x3c, 0x79, 0x40, 0xbb, 0x43, 0x61, 0x88, 0xa3,
  0x65, 0x3a, 0xfc, 0x12, 0x07, 0x28, 0xf8, 0x80, 0xd3, 0x22, 0x2d, 0xd6,
  0xcf, 0x8c, 0x80, 0xaf, 0xf9, 0xf0, 0xbd, 0xf4, 0xa7, 0x5a, 0xb7, 0x7b,
  0x7a, 0xaf, 0x18, 0x81, 0xed, 0x7f, 0x86, 0xa5, 0x7b, 0x12, 0xfd, 0x42,
  0x03, 0x8c, 0x18, 0x42, 0x20, 0xd3, 0xcd, 0x1f, 0xdc, 0x18, 0xc1, 0x3f,
  0x42, 0x4d, 0xcd, 0x2a, 0x3a, 0x70, 0x12, 0x72, 0x55, 0xb1, 0xb9, 0x7c,
  0xc0, 0xe7, 0x5d, 0xbb, 0x4b, 0x3c, 0x3d, 0x53, 0xc4, 0x5e, 0x20, 0x42,
  0xce, 0x20, 0x64, 0x06, 0x73, 0x40, 0x39, 0xd0, 0xba, 0x51, 0xf0, 0x02,
  0x42, 0xe7, 0x14, 0x8b, 0xe0, 0x18, 0x19, 0x12, 0x14, 0x8f, 0xb2, 0x39,
  0x40, 0x57, 0x88, 0xd1, 0xb6, 0x3f, 0xe8, 0xc6, 0xf2, 0x83, 0xaa, 0xe1,
  0xec, 0x85, 0x6e, 0x95, 0xd6, 0xad, 0xdb, 0x6c, 0x38, 0x06, 0x76, 0x22,
  0x66, 0x82, 0xe7, 0x8a, 0x74, 0x4f, 0xfd, 0x21, 0x5d, 0x89, 0x8a, 0xf0,
  0x84, 0xa5, 0x5e, 0x43, 0x02, 0xac, 0xbe, 0xc6, 0xbd, 0x08, 0xd0, 0x5b,
  0xa1, 0x56, 0x7a, 0xaa, 0x29, 0x53, 0x7f, 0x56, 0x0a, 0x37, 0xfc, 0x25,
  0xc9, 0xe0, 0xd1, 0xa5, 0x59, 0xc3, 0xe6, 0x5d, 0x49, 0xdd, 0x00, 0x60,
  0x2b, 0xf0, 0x24, 0x66, 0xf3, 0x69, 0x6f, 0xf2, 0xff, 0xd0, 0x85, 0x22,
  0xd5, 0x24, 0x42, 0xb4, 0x7f, 0xde, 0x7e, 0x50, 0x0b, 0x56, 0x46, 0x42,
  0x87, 0x71, 0x25, 0x12, 0x25, 0x49, 0xf5, 0x64, 0x3d, 0x6b, 0xab, 0x98,
  0xfb, 0x39, 0x92, 0xa4, 0x20, 0x2b, 0xde, 0x39, 0x7a, 0x09, 0x09, 0x59,
  0x02, 0x57, 0x0c, 0x1e, 0x6d, 0xb0, 0xed, 0xd8, 0x90, 0x6d, 0xec, 0x8c,
  0x5b, 0x19, 0x4f, 0x0a, 0xc8, 0x3b, 0x29, 0xbd, 0xa6, 0xce, 0xfd, 0x08,
  0xa3, 0xd3, 0xe1, 0x6e, 0xae, 0x64, 0xb6, 0x13, 0x0a, 0x9d, 0x39, 0xfb,
  0xb7, 0xa3, 0x18, 0xac, 0x7d, 0xa4, 0xaf, 0x71, 0xb3, 0x97, 0xaf, 0x7f,
  0xa2, 0x36, 0x37, 0x7f, 0xa6, 0xb9, 0xe6, 0xc9, 0xf6, 0x0e, 0xe3, 0xe5,
  0x94, 0x43, 0xb4, 0x77, 0x03, 0xe7, 0x0f, 0x9c, 0x8d, 0xcd, 0xdd, 0x89,
  0x55, 0x0f, 0xb7, 0x6f, 0xea, 0x25, 0x6a, 0x70, 0x5a, 0x19, 0x9e, 0x53,
  0x66, 0xce, 0x6c, 0x74, 0x90, 0x2b, 0x34, 0x11, 0xd9, 0x4d, 0xd9, 0xe0,
  0x2e, 0x2c, 0xb8, 0x3c, 0xa9, 0xbf, 0xa0, 0xed, 0x62, 0xaf, 0x99, 0x42,
  0x33, 0x99, 0x05, 0xe1, 0x9b, 0xd6, 0x6b, 0x67, 0xa2, 0x7a, 0x47, 0x35,
  0xe1, 0xd8, 0x8c, 0x25, 0xb9, 0xe8, 0xb2, 0xfe, 0x74, 0xbe, 0x3d, 0x64,
  0xce, 0x9b, 0xd2, 0xea, 0x96, 0x91, 0xf3, 0x3e, 0xf2, 0x8a, 0xb6, 0x9b,
  0x51, 0xa9, 0x75, 0x18, 0x27, 0x9d, 0x8f, 0xda, 0xab, 0x28, 0xe2, 0x68,
  0xad, 0xa2, 0xe4, 0xda, 0x0d, 0xf4, 0x42, 0xa0, 0x92, 0xc9, 0x23, 0xae,
  0x5b, 0x16, 0x11, 0x79, 0x47, 0x16, 0x33, 0x9e, 0x64, 0xb2, 0xc6, 0x07,
  0xb1, 0x00, 0xf3, 0x38, 0x2b, 0x02, 0x57, 0x8b, 0x09, 0x72, 0xe7, 0x88,
  0x0c, 0x1e, 0x69, 0xe2, 0x44, 0x69, 0x33, 0x9d, 0x24, 0x78, 0xa0, 0xd4,
  0xa3, 0x78, 0xbf, 0x79, 0x82, 0x4e, 0x31, 0x95, 0x4d, 0x4b, 0x90, 0xc5,
  0x47, 0xf8, 0x54, 0x74, 0x7f, 0xc7, 0x4f, 0xd9, 0xfc, 0x70, 0xc1, 0xa4,
  0x2a, 0xcb, 0xb1, 0xea, 0xd9, 0xc4, 0x1f, 0xed, 0x9c, 0xa8, 0xeb, 0xc7,
  0xff, 0xfa, 0x24, 0x3e, 0x4a, 0xc6, 0x5a, 0x79, 0xba, 0x00, 0x71, 0x32,
  0x3e, 0xbe, 0xda, 0x76, 0xb0, 0x00, 0xd7, 0xb3, 0x6d, 0x78, 0xd8, 0x92,
  0xd5, 0x65, 0x74, 0x59, 0xfd, 0x88, 0xe4, 0x8c, 0x90, 0x37, 0x56, 0x85,
  0x9e, 0xfc, 0x8f, 0x65, 0x7d, 0x69, 0x01, 0xca, 0x18, 0xf9, 0xaa, 0x59,
  0xe1, 0x36, 0xc4, 0xb7, 0xed, 0xd7, 0x14, 0xc3, 0x16, 0x95, 0x67, 0x0a,
  0x4a, 0xe2, 0x91, 0x9a, 0x0a, 0x1a, 0x0d, 0xe7, 0xfc, 0x9b, 0xcb, 0x2b,
  0x00, 0xcf, 0x1d, 0x9a, 0x7e, 0xa2, 0x74, 0x52, 0xbe, 0x91, 0xa2, 0xb8,
  0x1a, 0x85, 0xc4, 0x9b, 0xfb, 0x69, 0xff, 0x50, 0x27, 0x72, 0xca, 0xd3,
  0x3c, 0xd0, 0xaf, 0xa2, 0xa0, 0x38, 0x0c, 0x72, 0x62, 0x03, 0xf8, 0x54,
  0x4a, 0x85, 0xfe, 0x6c, 0x39, 0xc9, 0x47, 0xf8, 0xe2, 0x39, 0x5b, 0xb8,
  0xfc, 0x4c, 0xf6, 0x50, 0xd2, 0xe3, 0x44, 0x1b, 0x2b, 0x4c, 0xb6, 0xd3,
  0x8e, 0x85, 0xe2, 0x4d, 0x62, 0x5a, 0x32, 0x34, 0x25, 0x0a, 0xb4, 0x88,
  0x3d, 0xd2, 0x99, 0x01, 0xbc, 0x74, 0x85, 0xfe, 0x82, 0x6d, 0xf7, 0x15,
  0xac, 0x42, 0x5d, 0x3b, 0x2c, 0x77, 0xf9, 0xa7, 0xbf, 0x2c, 0x5a, 0x59,
  0x67, 0x67, 0xd4, 0x83, 0xe1, 0x4e, 0x1c, 0x04, 0xb1, 0xeb, 0xd9, 0x2b,
  0x7d, 0x53, 0xa8, 0x11, 0x0e, 0x0d, 0x18, 0xf9, 0xc2, 0x20, 0xa6, 0x9c,
  0x3d, 0x65, 0x4a, 0x80, 0xf7, 0x52, 0x1b, 0x81, 0x6b, 0x7b, 0xd3, 0xd3,
  0xf7, 0xab, 0x42, 0xea, 0xc7, 0x61, 0x11, 0x7a, 0x1a, 0x18, 0xe2, 0xba,
  0xea, 0x81, 0xfe, 0x7b, 0x52, 0x33, 0x90, 0x24, 0xc2, 0xea, 0x9a, 0x11,
  0xe2, 0x61, 0x4c, 0x1e, 0xac, 0x92, 0xe1, 0x0d, 0xfb, 0x74, 0x38, 0xe4,
  0x4b, 0x1a, 0x38, 0x90, 0xdb, 0x3a, 0x1b, 0x80, 0x98, 0xde, 0x06, 0x8d,
  0x72, 0x09, 0x7f, 0x22, 0x03, 0xa5, 0xa1, 0x36, 0x3b, 0x38, 0x92, 0xd3,
  0x46, 0x41, 0x0c, 0xb1, 0x97, 0x8d, 0x98, 0xba, 0x9c, 0x5d, 0x6c, 0x52,
  0x07, 0xd1, 0x08, 0xef, 0xd4, 0x80, 0x02, 0x61, 0xd9, 0xad, 0x03, 0x4d,
  0xf4, 0xbd, 0x81, 0x26, 0x8a, 0x10, 0xd5, 0xea, 0x38, 0x39, 0xd3, 0xd9,
  0xa8, 0xed, 0xd0, 0x65, 0x96, 0xa1, 0xc1, 0x64, 0x56, 0x26, 0x52, 0xd5,
  0x58, 0x93, 0x27, 0xb8, 0x92, 0xc2, 0x26, 0x3a, 0xc9, 0x51, 0x37, 0x34,
  0xc0, 0x1e, 0x1f, 0x3b, 0xdd, 0x85, 0x7b, 0x31, 0xff, 0xf1, 0x8c, 0x4d,
  0x8a, 0x86, 0x8f, 0x2a, 0x69, 0xb0, 0x8e, 0xe4, 0x59, 0x7c, 0x06, 0x22,
  0x3d, 0x5c, 0xf7, 0x71, 0x40, 0x84, 0x7d, 0xde, 0x2c, 0xbf, 0x8f, 0x98,
  0x79, 0xf8, 0xdf, 0x8d, 0xca, 0x37, 0xec, 0x10, 0x22, 0x39, 0x6a, 0x4f,
  0x7e, 0xc7, 0x92, 0xdb, 0x91, 0xe3, 0xf8, 0xcf, 0x41, 0xb9, 0x19, 0x0d,
  0xf3, 0x47, 0x5d, 0x72, 0x57, 0xef, 0x60, 0x6a, 0x4a, 0x98, 0xf9, 0x3d,
  0x61, 0x55, 0x7e, 0x04, 0xa0, 0x58, 0xf1, 0xec, 0x13, 0x29, 0x3c, 0x3b,
  0xe1, 0x03, 0x7e, 0xa7, 0x61, 0x30, 0x3a, 0xf3, 0xea, 0xc5, 0x7d, 0x3f,
  0xf0, 0xb9, 0xc2, 0x19, 0xd0, 0x87, 0x9e, 0x17, 0xbf, 0xa0, 0xbf, 0x6e,
  0xf8, 0xe8, 0x0f, 0x35, 0x7a, 0xf4, 0x76, 0x1e, 0x14, 0x25, 0xa0, 0x60,
  0xc7, 0x91, 0x8e, 0x14, 0x0c, 0xab, 0x95, 0xd8, 0xce, 0x7f, 0x1c, 0x4e,
  0xcc, 0xf6, 0x0d, 0x0b, 0x08, 0x74, 0x5c, 0xd1, 0xc9, 0x70, 0x5b, 0x1f,
  0x24, 0x7d, 0xb9, 0x8b, 0xcf, 0x4a, 0x9e, 0x6f, 0x4b, 0x7c, 0xa4, 0x88,
  0xd9, 0x2d, 0x8a, 0x4f, 0x88, 0xe7, 0x62, 0x98, 0x01, 0xe1, 0x1b, 0x3e,
  0xc5, 0xb6, 0xaf, 0x78, 0xea, 0xc9, 0x72, 0x6b, 0x29, 0x55, 0xe6, 0x2a,
  0x04, 0x6d, 0x73, 0xa8, 0x94, 0x9c, 0x4f, 0x06, 0xc9, 0x6c, 0xf1, 0x75,
  0x81, 0x90, 0xe9, 0x79, 0x70, 0xb3, 0x63, 0x33, 0xe0, 0x90, 0xde, 0x69,
  0xa2, 0x6a, 0xfc, 0x2e, 0x4b, 0x95, 0xcc, 0xf6, 0x97, 0x09, 0x7e, 0xdd,
  0xb6, 0x24, 0x29, 0x18, 0x38, 0xa0, 0x7c, 0x1e, 0x99, 0x74, 0x8e, 0xbd,
  0x80, 0xae, 0xa1, 0x1a, 0x49, 0x6c, 0xd1, 0x14, 0x45, 0xb4, 0xaf, 0x5b,
  0x6a, 0xd8, 0x13, 0xe6, 0x59, 0x35, 0xfc, 0xf3, 0xd7, 0x12, 0xc1, 0x79,
  0x25, 0x18, 0x67, 0xbb, 0x24, 0x7f, 0x71, 0xf7, 0xa1, 0x6e, 0x12, 0x74,
  0x5e, 0xaf, 0x2a, 0xe4, 0xde, 0xd0, 0xe8, 0xe3, 0xaa, 0x1e, 0xea, 0xa8,
  0xa3, 0x2f, 0x47, 0x25, 0xad, 0x44, 0xbc, 0xe7, 0x43, 0x13, 0x1d, 0xe7,
  0x3e, 0xbc, 0xcb, 0xdb, 0x42, 0x69, 0x13, 0x30, 0xa1, 0x2d, 0x08, 0x74,
  0xe7, 0x9d, 0xee, 0x88, 0xe0, 0xe1, 0x9c, 0xa0, 0x41, 0x2a, 0x95, 0x4a,
  0xf3, 0x7a, 0x96, 0x92, 0x67, 0x96, 0x76, 0xd0, 0x2d, 0x27, 0xfa, 0xa8,
  0x86, 0x9e, 0x90, 0x1c, 0xda, 0x9b, 0x21, 0xd3, 0x57, 0x8a, 0x30, 0x3e,
  0xd5, 0x28, 0x73, 0x51, 0xc5, 0x39, 0xe7, 0x0d, 0x7a, 0xdb, 0xcf, 0xae,
  0x44, 0x11, 0x85, 0xd3, 0x17, 0x9c, 0xbf, 0x3f, 0xda, 0xc0, 0xb8, 0x47,
  0xe7, 0x09, 0x14, 0xcb, 0x0e, 0xe1, 0xd8, 0xc0, 0x46, 0x49, 0x0a, 0x89,
  0xbc, 0x8a, 0xd3, 0x7c, 0xe6, 0xd9, 0xb4, 0xd0, 0x7a, 0xc2, 0x1d, 0x4a,
  0x03, 0xc6, 0xb9, 0x5f, 0x2f, 0xe7, 0x4e, 0x0d, 0x8a, 0xa6, 0x82, 0xb6,
  0x2a, 0x8a, 0x41, 0xdd, 0x53, 0xc1, 0x0b, 0x03, 0x33, 0x0f, 0xba, 0x2a,
  0xb3, 0x9c, 0xcb, 0x70, 0x1d, 0x95, 0x20, 0x73, 0x7e, 0xfc, 0x91, 0x97,
  0x26, 0xb2, 0xea, 0x5f, 0x7a, 0x93, 0x46, 0x1f, 0x52, 0x5e, 0x13, 0xcf,
  0xbf, 0xd3, 0x43, 0x97, 0x35, 0xcc, 0x5a, 0x17, 0xe2, 0xac, 0x23, 0x21,
  0xbe, 0x02, 0x91, 0x11, 0x22, 0xde, 0x99, 0x79, 0x17, 0xa8, 0x6e, 0x18,
  0x4a, 0xe2, 0x51, 0xf3, 0xf3, 0xb9, 0x9d, 0x58, 0xe9, 0xf1, 0xf2, 0x9a,
  0x8e, 0xc2, 0x4d, 0x27, 0x41, 0xd2, 0xd9, 0xde, 0x83, 0x39, 0x82, 0xc7,
  0xd4, 0x33, 0x54, 0x2c, 0x51, 0x22, 0xd6, 0xf1, 0x7b, 0x2f, 0x6f, 0x6d,
  0x1d, 0x39, 0x1a, 0xa4, 0xf7, 0x13, 0xda, 0x0f, 0xb3, 0x79, 0x55, 0x31,
  0xcf, 0xda, 0xe6, 0x7a, 0xcf, 0x49, 0xad, 0xb0, 0x09, 0x86, 0x48, 0x26,
  0x97, 0xe8, 0x39, 0xb6, 0x9b, 0x0b, 0xee, 0x73, 0x7f, 0x40, 0x58, 0xba,
  0x8f, 0x8e, 0x2c, 0xdc, 0x12, 0x69, 0x2f, 0x40, 0xfc, 0x4a, 0x91, 0x21,
  0xb4, 0xf2, 0x91, 0x92, 0x03, 0x4a, 0xb8, 0xc3, 0x51, 0xb5, 0xe7, 0xaa,
  0x1c, 0x22, 0x32, 0x3a, 0x83, 0x98, 0xc0, 0xf0, 0x44, 0x1e, 0x71, 0x08,
  0x9f, 0xdc, 0xd8, 0xcb, 0x66, 0xc2, 0x3c, 0xf6, 0x0c, 0x28, 0xf1, 0x55,
  0x29, 0xcf, 0x24, 0x6b, 0xa0, 0x1d, 0x1d, 0x69, 0x7e, 0x7c, 0xda, 0x2b,
  0x7c, 0x46, 0xe4, 0x36, 0xe7, 0x46, 0x4f, 0x0f, 0xbf, 0x3b, 0x53, 0xb4,
  0x78, 0x7d, 0x2e, 0x10, 0x1b, 0x3a, 0x09, 0x5a, 0x53, 0xad, 0xea, 0x41,
  0x8a, 0x3f, 0x40, 0x0f, 0xd2, 0xf5, 0xfa, 0x1b, 0x2d, 0xd5, 0x22, 0x73,
  0x12, 0xd2, 0x5f, 0xc5, 0xef, 0xec, 0x58, 0x28, 0x05, 0xf2, 0x9f, 0x5c,
  0x98, 0xba, 0xd0, 0xda, 0x25, 0x05, 0x15, 0xdc, 0xfc, 0x81, 0x76, 0xc4,
  0x24, 0x49, 0xfe, 0xb3, 0x19, 0x35, 0xc1, 0x59, 0x2a, 0xbd, 0xa5, 0x4f,
  0x23, 0x5e, 0xd4, 0x37, 0xbd, 0xa0, 0xf4, 0x92, 0xb2, 0xd9, 0x9b, 0x2a,
  0x29, 0xd8, 0x71, 0xe3, 0x71, 0x73, 0x66, 0xb8, 0x36, 0xdd, 0x83, 0x58,
  0x11, 0x91, 0x5d, 0xc5, 0xfb, 0x4f, 0x3c, 0xb1, 0xed, 0x7c, 0x84, 0x0c,
  0x68, 0x7c, 0xff, 0x40, 0x26, 0x8f, 0xdb, 0x72, 0xc7, 0xf6, 0x34, 0x99,
  0x28, 0x1a, 0xe8, 0x37, 0x89, 0x07, 0x3c, 0xda, 0x1b, 0xe9, 0x89, 0xca,
  0xbf, 0x65, 0x62, 0xd7, 0xe6, 0x40, 0xde, 0x78, 0x8b, 0x96, 0x06, 0x07,
  0xfb, 0xa6, 0x08, 0x76, 0xbc, 0xe6, 0x84, 0x0c, 0x4d, 0x49, 0x68, 0x72,
  0x6c, 0xd5, 0xc2, 0x9a, 0x93, 0xc3, 0x77, 0x7f, 0x74, 0x5c, 0xa5, 0xba,
  0xe5, 0x9b, 0x9b, 0x04, 0xd8, 0x6a, 0x6d, 0xed, 0x3a, 0x79, 0x10, 0xb6,
  0xcf, 0xba, 0x17, 0x6d, 0x26, 0x16, 0xaa, 0x66, 0x72, 0x53, 0xde, 0xeb,
  0x27, 0x1e, 0x07, 0xf7, 0xaa, 0xb7, 0x89, 0xe3, 0x75, 0x13, 0x91, 0xd9,
  0xca, 0x10, 0xd0, 0x64, 0x6c, 0x7a, 0x67, 0xe2, 0x69, 0xf5, 0x50, 0xcd,
  0x84, 0xa8, 0x49, 0x53, 0xdf, 0x57, 0x40, 0xb1, 0xaf, 0x9f, 0xe3, 0x62,
  0xb4, 0x2d, 0x36, 0x76, 0x2e, 0x5b, 0x68, 0x84, 0xde, 0xe6, 0x0c, 0xd7,
  0x4a, 0x69, 0xdd, 0x8a, 0xa2, 0xb0, 0x07, 0x89, 0xa8, 0xa4, 0x5b, 0xd2,
  0x7c, 0xd4, 0xbd, 0xab, 0x39, 0x1f, 0x19, 0x80, 0xef, 0x7c, 0xb4, 0x50,
  0x79, 0xe8, 0x30, 0x25, 0x4c, 0x9d, 0x5b, 0x42, 0xfc, 0x5c, 0xf8, 0x00,
  0x45, 0x62, 0x11, 0xc2, 0x7f, 0xc8, 0x3b, 0x1e, 0xae, 0x78, 0x5d, 0xe3,
  0xa6, 0x83, 0xf9, 0x68, 0x24, 0x31, 0x77, 0x32, 0xe2, 0x77, 0x84, 0x56,
  0xa1, 0xfb, 0xd8, 0xa4, 0x64, 0x0e, 0x72, 0xcc, 0x83, 0x2c, 0x41, 0xf8,
  0x0c, 0xa9, 0x04, 0x63, 0x59, 0x56, 0xc0, 0x96, 0x28, 0x4e, 0x9d, 0xdb,
  0x05, 0xd4, 0x4f, 0x7a, 0x09, 0x24, 0xa5, 0x16, 0xbe, 0xaa, 0x76, 0x32,
  0x58, 0xed, 0xc1, 0x72, 0x47, 0xd7, 0xe2, 0x90, 0xde, 0xb1, 0xae, 0x76,
  0x5a, 0xad, 0x2f, 0x31, 0x8d, 0xd4, 0x57, 0xc4, 0x07, 0xdf, 0x28, 0xfd,
  0xca, 0x69, 0x11, 0x24, 0x0d, 0x92, 0x2f, 0x28, 0x03, 0xae, 0x51, 0x68,
  0x1a, 0xe4, 0xee, 0x9a, 0x1b, 0xae, 0xa5, 0x74, 0xc8, 0xa8, 0xcc, 0x99,
  0x9d, 0x8a, 0x15, 0xbc, 0x21, 0xd5, 0x44, 0xd3, 0x50, 0x67, 0x79, 0x7a,
  0xd9, 0x3d, 0x42, 0x4a, 0x66, 0x20, 0xea, 0x8c, 0xe0, 0xd4, 0xf4, 0x43,
  0x13, 0x73, 0x84, 0xca, 0x3e, 0x38, 0x98, 0x21, 0x29, 0x44, 0x95, 0xa7,
  0x62, 0x17, 0x46, 0xf6, 0x22, 0x77, 0x88, 0x47, 0x5c, 0x65, 0xa3, 0xbf,
  0xc7, 0xc9, 0xac, 0x67, 0x72, 0xc8, 0x9b, 0xe8, 0xf7, 0x31, 0xe6, 0x6e,
  0x79, 0x9e, 0xc4, 0x6f, 0x34, 0xc7, 0xdb, 0xc0, 0x91, 0x42, 0x0e, 0x3a,
  0x60, 0x52, 0x83, 0xab, 0xdf, 0xde, 0xc5, 0x18, 0x04, 0x1e, 0x79, 0x47,
  0xdb, 0x0c, 0x4a, 0xab, 0x94, 0x8c, 0x94, 0x96, 0x0a, 0x46, 0xc5, 0x29,
  0x52, 0x77, 0x3c, 0xee, 0x32, 0xf3, 0x5f, 0xcf, 0xf3, 0x63, 0x8c, 0x77,
  0xee, 0x0c, 0x40, 0x77, 0x57, 0x49, 0xc2, 0x4b, 0xf1, 0xb7, 0xc0, 0xf9,
  0x51, 0x82, 0x95, 0x8d, 0xe3, 0xeb, 0x60, 0x40, 0x9c, 0x9c, 0xb2, 0xb7,
  0xe4, 0x8a, 0x64, 0x0b, 0x04, 0xbf, 0x7a, 0xe8, 0x98, 0x55, 0x24, 0x99,
  0x52, 0xce, 0x91, 0x6e, 0x7a, 0xe3, 0xd4, 0xf7, 0xe2, 0xfb, 0x90, 0x42,
  0x65, 0x56, 0x6a, 0x01, 0x00, 0x0c, 0xad, 0xe3, 0x8f, 0x1d, 0x62, 0xb4,
  0x4e, 0x5f, 0xac, 0xfa, 0x82, 0xdf, 0x7f, 0xb7, 0x8e, 0x54, 0x9a, 0x6e,
  0x22, 0x88, 0x79, 0x08, 0x3a, 0x6a, 0x2a, 0x00, 0x7f, 0xb3, 0xf7, 0x88,
  0xdf, 0x72, 0x7a, 0x8a, 0x8f, 0x5d, 0x3e, 0x0f, 0xe1, 0x2f, 0xd6, 0x15,
  0xcf, 0x00, 0x84, 0x9d, 0x6b, 0x75, 0xdf, 0x8e, 0x86, 0x72, 0xbc, 0xf5,
  0xb7, 0x62, 0x01, 0x35, 0x27, 0x10, 0x23, 0x0c, 0xf5, 0x0d, 0xcd, 0x81,
  0xcc, 0xb3, 0x68, 0x14, 0xe8, 0x41, 0x45, 0xe2, 0x47, 0xf2, 0xee, 0xe6,
  0xd2, 0x09, 0xff, 0x54, 0xd1, 0xe1, 0xe1, 0x61, 0x2d, 0x6f, 0x45, 0x5b,
  0xc2, 0x54, 0x45, 0xd6, 0xf3, 0x02, 0x1e, 0xae, 0xef, 0xed, 0x9a, 0x56,
  0x6c, 0x7f, 0xd6, 0xb9, 0x59, 0xfd, 0x73, 0xbe, 0x52, 0x0a, 0xcd, 0x80,
  0x91, 0xac, 0x45, 0xe7, 0x5a, 0xa4, 0x3b, 0xc4, 0xd7, 0x5b, 0x05, 0xe6,
  0xcc, 0xe9, 0x96, 0x0e, 0x32, 0xc3, 0x56, 0x2f, 0xad, 0x9f, 0xe2, 0x16,
  0xf5, 0xb8, 0x4a, 0x47, 0xc3, 0xfd, 0x4f, 0x02, 0xa6, 0x00, 0x0f, 0xd1,
  0x0d, 0x43, 0xa7, 0x6f, 0x46, 0x00, 0x24, 0xf2, 0xcd, 0x63, 0xc3, 0xf6,
  0x34, 0xf5, 0x0f, 0x0c, 0xf7, 0x56, 0xcd, 0xef, 0x5c, 0x72, 0xb0, 0xce,
  0xc5, 0x12, 0x52, 0xd5, 0x9d, 0x70, 0x84, 0x21, 0x78, 0x2a, 0x4d, 0x78,
  0xb6, 0x36, 0x4d, 0xd6, 0x51, 0x4a, 0x13, 0x76, 0xe6, 0x7c, 0x7f, 0xb0,
  0x41, 0xbf, 0xf9, 0xbc, 0x94, 0x48, 0x16, 0xcf, 0x95, 0x8d, 0xc7, 0x09,
  0x24, 0x6f, 0x15, 0x08, 0xb2, 0x41, 0xf7, 0x47, 0xb3, 0xcb, 0x88, 0xed,
  0x0e, 0x16, 0xae, 0x91, 0xcc, 0x46, 0xfe, 0x5d, 0x66, 0xc5, 0x29, 0xbc,
  0x04, 0xa9, 0x5b, 0x27, 0x04, 0xcc, 0x97, 0xc6, 0x19, 0x37, 0xea, 0xc0,
  0xa6, 0x67, 0x0e, 0x16, 0x6a, 0xd2, 0x84, 0xd9, 0xe1, 0x80, 0xc2, 0xf9,
  0xca, 0x09, 0xca, 0xed, 0x33, 0x43, 0x48, 0xf6, 0xe0, 0x18, 0xa0, 0xfb,
  0xef, 0x60, 0x5a, 0x0c, 0xf9, 0x56, 0xf9, 0xf2, 0xfa, 0x58, 0xc0, 0xe3,
  0x35, 0x5e, 0x4e, 0x77, 0x7a, 0x4b, 0xe6, 0x4b, 0x2c, 0xa8, 0xa2, 0x08,
  0x9e, 0x48, 0x06, 0x9b, 0xf8, 0xda, 0x11, 0x3c, 0x1b, 0x49, 0x0f, 0xc6,
  0xae, 0xff, 0x9f, 0x66, 0xd1, 0x35, 0x7d, 0x19, 0x5b, 0x2d, 0x95, 0x43,
  0x1c, 0x5e, 0xe9, 0x92, 0xb3, 0x27, 0x08, 0x92, 0xbf, 0xd6, 0xd4, 0x73,
  0xd0, 0x36, 0x30, 0xb9, 0x49, 0x3f, 0x44, 0xb6, 0xe7, 0x4e, 0x26, 0x5b,
  0xc2, 0x5d, 0xfa, 0xd3, 0x44, 0xc7, 0x53, 0xb7, 0x01, 0xe4, 0x64, 0x8b,
  0x48, 0x3c, 0xdb, 0x08, 0x18, 0x8b, 0x45, 0xe5, 0x9b, 0xef, 0xc0, 0x1d,
  0x8a, 0xb0, 0xb8, 0x1d, 0xee, 0xb9, 0x45, 0x37, 0xa3, 0x6f, 0x7c, 0x5f,
  0x4a, 0x78, 0x42, 0x42, 0xae, 0x9e, 0xa9, 0xae, 0xfd, 0xa2, 0xaf, 0x63,
  0x82, 0xd7, 0x54, 0xb7, 0x80, 0x24, 0xdc, 0x85, 0x0f, 0x13, 0x03, 0x6e,
  0x94, 0xba, 0x8f, 0xc4, 0xb3, 0x1f, 0xa7, 0x79, 0xd0, 0x32, 0xcf, 0xc1,
  0xff, 0x71, 0xb4, 0xb5, 0xb3, 0x7c, 0x42, 0x44, 0xf6, 0x3a, 0x46, 0xaa,
  0x7f, 0x2e, 0xcf, 0xc4, 0xcd, 0x55, 0x5a, 0x0a, 0x67, 0xdd, 0x14, 0xab,
  0xf9, 0x88, 0x79, 0x47, 0xcf, 0x92, 0x76, 0x82, 0x4a, 0x46, 0x68, 0xbe,
  0x3c, 0x4e, 0xd4, 0x75, 0x0a, 0x3b, 0x28, 0x1d, 0x93, 0x1f, 0x72, 0x1e,
  0xb5, 0x75, 0x2d, 0x7e, 0x42, 0x25, 0xe9, 0xc8, 0x25, 0xdf, 0x8b, 0xb5,
  0x9f, 0x1a, 0x6f, 0xb9, 0xa4, 0xee, 0x62, 0xd3, 0x00, 0x58, 0x96, 0x7a,
  0xa1, 0x67, 0xf2, 0xc8, 0x06, 0xe5, 0xc2, 0x4d, 0xb7, 0xa2, 0x9b, 0x9a,
  0x1b, 0x7f, 0x35, 0x8e, 0x75, 0xb7, 0xe9, 0x0c, 0x6f, 0x91, 0x30, 0x6e,
  0x4e, 0x4d, 0x55, 0x73, 0x33, 0xa3, 0x5a, 0x2c, 0x17, 0x89, 0xe0, 0x29,
  0x5a, 0x92, 0xcc, 0x2d, 0xbc, 0x5c, 0x62, 0x2c, 0x17, 0x7e, 0x8a, 0x3b,
  0x73, 0x36, 0xaa, 0x16, 0x22, 0x23, 0xe7, 0xb6, 0xb8, 0xff, 0x7a, 0x71,
  0x88, 0xff, 0x0f, 0x11, 0x4a, 0x7b, 0x3a, 0xe4, 0xfb, 0x53, 0x2b, 0xed,
  0x42, 0x64, 0x0b, 0xba, 0xe5, 0xa2, 0xa5, 0x81, 0xda, 0x0a, 0x46, 0xf5,
  0x8f, 0x09, 0x6e, 0xe9, 0x63, 0x06, 0x02, 0xdc, 0x83, 0xbb, 0x4a, 0x90,
  0x82, 0x17, 0x00, 0x08, 0x71, 0x1a, 0x9d, 0xbb, 0x51, 0xb0, 0xce, 0x75,
  0x70, 0xfa, 0x23, 0xeb, 0xf8, 0x6b, 0xd7, 0x84, 0xa0, 0x1a, 0x53, 0x82,
  0x02, 0x3b, 0x31, 0xc2, 0x6b, 0x06, 0x82, 0x7a, 0x1d, 0xce, 0x9d, 0x38,
  0x63, 0x51, 0x6a, 0x6a, 0xfe, 0x72, 0x7e, 0xc7, 0x7d, 0x27, 0x5f, 0xc9,
  0x7f, 0x15, 0xe7, 0x7a, 0xaf, 0x89, 0xd5, 0x30, 0xfa, 0xc8, 0x45, 0xda,
  0x79, 0x4e, 0xd2, 0x98, 0x8d, 0x64, 0xb6, 0xfd, 0x48, 0xbb, 0x09, 0xed,
  0x98, 0x7e, 0x07, 0x69, 0xd4, 0x66, 0x8c, 0xff, 0x0f, 0x6d, 0xd9, 0x08,
  0xea, 0xcc, 0xaa, 0xcc, 0xb1, 0x37, 0xbb, 0x1b, 0xd2, 0xef, 0x17, 0x79,
  0xf5, 0x24, 0xfc, 0x03, 0xe2, 0xa1, 0xa8, 0xc2, 0x07, 0x9e, 0x70, 0xa7,
  0x57, 0x44, 0x56, 0x49, 0x2d, 0x06, 0xe7, 0x0d, 0xed, 0xee, 0x15, 0xb0,
  0xab, 0xce, 0x12, 0xc6, 0xb6, 0x16, 0x18, 0xf6, 0xaa, 0x8a, 0xe7, 0xe6,
  0xb1, 0x71, 0x38, 0xe5, 0x6e, 0xb7, 0x02, 0x43, 0x50, 0xd7, 0xb1, 0x9e,
  0x35, 0x99, 0x0d, 0x9d, 0x7b, 0x34, 0x89, 0x54, 0x9c, 0x80, 0xd4, 0x2d,
  0x1f, 0xeb, 0x6a, 0x10, 0x50, 0x84, 0xb3, 0x90, 0xe4, 0x38, 0xef, 0xc9,
  0x69, 0xe0, 0xd7, 0x5c, 0xa9, 0x9c, 0xe2, 0x50, 0xcc, 0x72, 0x05, 0xfc,
  0xa2, 0xac, 0x94, 0x34, 0x60, 0x08, 0x72, 0xb6, 0x0f, 0x47, 0x1e, 0x49,
  0x12, 0xa7, 0x7d, 0x46, 0xc9, 0x3c, 0x8c, 0xb8, 0x79, 0x7e, 0x22, 0x3c,
  0xd3, 0xaa, 0xd8, 0xc2, 0xbb, 0x2a, 0x45, 0x15, 0xb7, 0xed, 0x2e, 0x8d,
  0x97, 0xc9, 0xfa, 0xfb, 0xf5, 0x21, 0xe3, 0x3a, 0x6b, 0x44, 0x79, 0x6a,
  0x9f, 0xb7, 0x24, 0x01, 0xd2, 0x54, 0xd3, 0x63, 0x6f, 0xb1, 0xc7, 0xef,
  0x91, 0x5f, 0x73, 0x0b, 0x59, 0xbc, 0x96, 0xb4, 0x3c, 0xe6, 0xa0, 0xff,
  0x39, 0x2a, 0x5d, 0xbe, 0xfa, 0xdb, 0x18, 0xfc, 0x25, 0x69, 0xc8, 0xbc,
  0xee, 0x8c, 0xba, 0xe7, 0xf7, 0x7a, 0x79, 0xcf, 0xc0, 0xe2, 0xb7, 0x0a,
  0x9b, 0x4e, 0xb1, 0x0a, 0x77, 0x83, 0xbd, 0xd0, 0x0e, 0x9c, 0xb8, 0xed,
  0x6a, 0xc4, 0x47, 0xd7, 0x7e, 0xfe, 0x3a, 0xa5, 0xa4, 0x4b, 0x2b, 0xd8,
  0x28, 0x7f, 0x04, 0xf4, 0x8b, 0x55, 0x10, 0x05, 0x20, 0xad, 0xf6, 0xb5,
  0xbf, 0x19, 0xfb, 0xe5, 0xa7, 0x99, 0x57, 0x94, 0x78, 0xbf, 0x5a, 0x4b,
  0x2e, 0x61, 0x3d, 0xec, 0xf6, 0x30, 0x35, 0x73, 0x59, 0xd2, 0x18, 0x96,
  0x59, 0x47, 0x1f, 0x1f, 0xdf, 0x01, 0x6f, 0x7a, 0x53, 0x55, 0x75, 0x00,
  0x45, 0x0a, 0xee, 0x7f, 0x55, 0x2d, 0xf9, 0xcf, 0x95, 0x48, 0x8f, 0x09,
  0x09, 0x32, 0x3c, 0xeb, 0x3a, 0x48, 0xc9, 0x5f, 0x15, 0x74, 0xd3, 0x4d,
  0x57, 0x62, 0x34, 0x40, 0x62, 0x56, 0x42, 0xd6, 0x36, 0xf8, 0x30, 0x5d,
  0xfe, 0xd3, 0x3d, 0x87, 0x35, 0xcd, 0xb8, 0xe1, 0xb7, 0xea, 0x4f, 0x45,
  0x89, 0x69, 0x66, 0x97, 0x8e, 0x93, 0xed, 0xd5, 0x93, 0x6c, 0x0b, 0xa0,
  0x53, 0x9d, 0x21, 0xc7, 0x34, 0x58, 0x8e, 0x1f, 0x63, 0x7b, 0xf1, 0x27,
  0x96, 0x5f, 0xfc, 0xb5, 0x73, 0x17, 0x39, 0xbc, 0xdf, 0xd9, 0xb5, 0x80,
  0x94, 0x5d, 0xd7, 0xd6, 0x06, 0xe3, 0x9e, 0x2d, 0x22, 0x06, 0xe6, 0x81,
  0xd1, 0x3b, 0x63, 0x76, 0x8d, 0x0e, 0xff, 0x5d, 0xcc, 0xa6, 0x43, 0x82,
  0x96, 0x87, 0x98, 0xda, 0xb3, 0x6c, 0x01, 0x7d, 0xc1, 0x45, 0xa6, 0xc7,
  0xf1, 0x7d, 0xff, 0x51, 0x74, 0x94, 0x53, 0x05, 0x0e, 0xcb, 0x51, 0xab,
  0xf1, 0xc7, 0xc7, 0xa8, 0xe6, 0x70, 0xe6, 0xc8, 0x10, 0xd9, 0x5f, 0xef,
  0x1d, 0x9d, 0xff, 0xa4, 0x3a, 0xdd, 0x51, 0x7a, 0x3d, 0xc4, 0x83, 0x59,
  0x70, 0xc4, 0x2f, 0xf6, 0xcf, 0xee, 0x08, 0x8c, 0x39, 0x44, 0x9b, 0x96,
  0x11, 0xf4, 0x3d, 0x1c, 0xea, 0xff, 0x09, 0x24, 0x36, 0x13, 0x66, 0x12,
  0xf7, 0xae, 0x5a, 0x67, 0x0a, 0x41, 0x09, 0xb1, 0x39, 0x92, 0x1d, 0x95,
  0xe6, 0x1d, 0x27, 0x48, 0xe2, 0xc3, 0x39, 0x1b, 0x35, 0xa7, 0xc2, 0xbe,
  0xbe, 0x15, 0xd1, 0x8f, 0x40, 0x72, 0x68, 0x3a, 0xbf, 0x20, 0x8b, 0x67,
  0x0c, 0xe0, 0x7d, 0x1a, 0x76, 0xfb, 0x0f, 0x13, 0x20, 0xfe, 0xbc, 0x21,
  0x51, 0x67, 0xc6, 0xa6, 0xa9, 0xb7, 0x7f, 0x3b, 0xe5, 0x0f, 0xa9, 0xe3,
  0xde, 0xc3, 0x03, 0x31, 0xe3, 0xf8, 0x32, 0xe8, 0xf5, 0x0c, 0xe0, 0x65,
  0x16, 0xac, 0xe8, 0x79, 0x06, 0x2e, 0x7c, 0xac, 0x4c, 0xaf, 0x2a, 0xfe,
  0x2c, 0xb4, 0xeb, 0x1f, 0xd9, 0x5d, 0xeb, 0xa6, 0x97, 0x45, 0xde, 0xad,
  0xe7, 0x96, 0xf8, 0xa3, 0xf8, 0x74, 0xca, 0x4b, 0xde, 0x18, 0xc4, 0x2c,
  0xd4, 0x05, 0x93, 0x13, 0x24, 0xfe, 0xcb, 0xac, 0x7c, 0x97, 0xf2, 0x84,
  0xce, 0xbe, 0x5a, 0x8c, 0x73, 0x5e, 0x35, 0x11, 0x1e, 0xd3, 0x8e, 0xf4,
  0x27, 0x58, 0x24, 0xcf, 0xff, 0xea, 0x2e, 0x79, 0x6e, 0x94, 0x9b, 0xab,
  0xfd, 0x0f, 0x36, 0x2b, 0xe9, 0x14, 0xbd, 0xde, 0x82, 0xff, 0x12, 0x8d,
  0x9a, 0xb7, 0x36, 0xa8, 0xdb, 0xb8, 0x29, 0xb6, 0x6f, 0x6c, 0x17, 0xb8,
  0xad, 0x46, 0xe4, 0x09, 0xae, 0x09, 0xfd, 0x4f, 0x05, 0x42, 0x3b, 0xab,
  0x6d, 0xef, 0x6c, 0xeb, 0xda, 0xf1, 0x3e, 0x57, 0xde, 0x2d, 0x1e, 0xe6,
  0x42, 0x25, 0x38, 0x04, 0x39, 0xb3, 0xae, 0xee, 0xcd, 0x2f, 0x92, 0x5d,
  0x02, 0x99, 0x16, 0x86, 0xe0, 0x15, 0xa5, 0x66, 0x6c, 0x8a, 0xa1, 0xe9,
  0x47, 0xab, 0xc3, 0x5d, 0x96, 0x6f, 0xa0, 0x9d, 0x6c, 0x34, 0x5c, 0xd3,
  0xde, 0x99, 0xea, 0x37, 0xd3, 0xbb, 0x74, 0x32, 0x4d, 0x7c, 0x1c, 0x81,
  0x10, 0x45, 0xb8, 0x5d, 0x22, 0x46, 0xe6, 0xfe, 0xab, 0x05, 0xa6, 0x57,
  0x6f, 0x15, 0x4f, 0x09, 0xa9, 0xe0, 0xee, 0xae, 0x37, 0x24, 0x3c, 0x95,
  0x76, 0xa3, 0xde, 0x9c, 0x15, 0x60, 0xdb, 0xed, 0x23, 0x12, 0x03, 0x20,
  0x2a, 0x22, 0x34, 0x21, 0xd1, 0x34, 0xbf, 0xc3, 0x05, 0x8f, 0x81, 0x87,
  0x63, 0x18, 0x4f, 0xf4, 0x52, 0xa0, 0x5e, 0xef, 0x21, 0xfb, 0x29, 0x1b,
  0x64, 0xa8, 0xf4, 0x3d, 0xa3, 0xa4, 0x5c, 0x34, 0xc8, 0x83, 0x2a, 0x2c,
  0x4e, 0x3e, 0x6c, 0x2c, 0x20, 0xb1, 0x92, 0x23, 0xd3, 0x9e, 0x1e, 0xe4,
  0x5b, 0xd4, 0x18, 0xf3, 0xb0, 0x0c, 0x64, 0xe1, 0x33, 0x83, 0x6b, 0x98,
  0x42, 0x5b, 0x7d, 0xa8, 0x52, 0x89, 0x12, 0x0a, 0xee, 0x2d, 0x8a, 0x40,
  0x10, 0xd3, 0xe2, 0x4a, 0xe4, 0xb6, 0x8e, 0x38, 0xa0, 0xe3, 0xd8, 0x94,
  0x2d, 0xfe, 0x10, 0x07, 0x21, 0x70, 0xcf, 0xd3, 0x2a, 0x99, 0x3f, 0x9c,
  0x90, 0x0d, 0x4b, 0xdd, 0xec, 0x82, 0x01, 0x31, 0xbe, 0x99, 0x38, 0x05,
  0x40, 0x09, 0x6f, 0x25, 0x8a, 0xc8, 0xb0, 0x27, 0xb9, 0xdf, 0xeb, 0x9e,
  0x15, 0x59, 0x7a, 0x84, 0xcb, 0x89, 0x81, 0x6a, 0xc9, 0x04, 0x98, 0x5a,
  0x47, 0xfd, 0xe3, 0xdd, 0x60, 0x0d, 0x0b, 0x5a, 0x0e, 0x7d, 0xf1, 0x09,
  0xd3, 0xb8, 0x9b, 0xd0, 0xbb, 0x84, 0x76, 0xba, 0x4e, 0xbf, 0x57, 0x78,
  0x13, 0xe7, 0x78, 0xe6, 0x2a, 0xdc, 0x34, 0xd3, 0xae, 0xd0, 0xd3, 0xbd,
  0xb0, 0xf7, 0xa0, 0xc3, 0xc0, 0xa9, 0xd1, 0x28, 0xc0, 0x8e, 0xed, 0x3d,
  0x7e, 0x0e, 0x7b, 0x2a, 0xca, 0xa8, 0x1a, 0xde, 0x86, 0xa7, 0x9c, 0x09,
  0x95, 0x2b, 0x70, 0x5c, 0xd8, 0xba, 0x34, 0x71, 0xe0, 0x9e, 0xb5, 0x28,
  0x37, 0x41, 0x39, 0x53, 0x3f, 0x5c, 0xdf, 0xe6, 0x78, 0x7b, 0x66, 0x41,
  0xee, 0x0e, 0x42, 0x5a, 0x15, 0x45, 0x60, 0xf0, 0x76, 0x99, 0xd9, 0x2e,
  0xfc, 0x42, 0x94, 0x83, 0x02, 0x9f, 0x1c, 0xb2, 0x2e, 0x1d, 0xc0, 0x1e,
  0xd7, 0x42, 0xef, 0x4b, 0x57, 0xdc, 0x5e, 0x3b, 0x47, 0xf4, 0xf5, 0xb9,
  0x09, 0xca, 0x35, 0x1c, 0x97, 0xd7, 0x35, 0x88, 0x23, 0xae, 0xca, 0xd2,
  0x72, 0x6d, 0x87, 0xbb, 0xe5, 0xf6, 0x79, 0x4e, 0xf6, 0xe8, 0x74, 0xc5,
  0xa7, 0xa1, 0xf8, 0xe3, 0x0d, 0x80, 0xfe, 0x98, 0x35, 0x8f, 0xe8, 0xb0,
  0xaa, 0xb1, 0x91, 0x7d, 0x50, 0xf9, 0x89, 0xd3, 0x03, 0x71, 0x3a, 0xc5,
  0xbe, 0x81, 0x10, 0xef, 0x14, 0xbc, 0x04, 0xf8, 0xa7, 0xfc, 0x74, 0xac,
  0x53, 0x69, 0x13, 0x5f, 0x1c, 0x27, 0xf3, 0xc2, 0xba, 0xd3, 0xe0, 0x85,
  0x1c, 0x44, 0xde, 0x73, 0x05, 0x65, 0x0f, 0xd8, 0xde, 0xb4, 0x23, 0x98,
  0x74, 0x21, 0x68, 0x09, 0x9a, 0xb4, 0xae, 0xf1, 0xfb, 0x3f, 0xa7, 0x1c,
  0xf9, 0x70, 0x81, 0x7e, 0xd6, 0x22, 0x5a, 0x43, 0xa5, 0xae, 0x3e, 0x76,
  0x50, 0x28, 0xa4, 0xfd, 0x02, 0x9c, 0x24, 0x7e, 0x5b, 0x23, 0x38, 0xe5,
  0x65, 0x43, 0x5c, 0xb7, 0x5a, 0xff, 0x99, 0xb6, 0x48, 0x95, 0x55, 0xa8,
  0x33, 0x6e, 0x42, 0x86, 0xa9, 0x78, 0x27, 0xca, 0x81, 0xee, 0x99, 0xa3,
  0x9c, 0x2f, 0x13, 0x7e, 0x30, 0x7c, 0x48, 0x61, 0x6e, 0x08, 0x62, 0xd6,
  0xe8, 0x7a, 0x78, 0xb7, 0x04, 0x7e, 0x35, 0xd5, 0x65, 0x9c, 0xe7, 0xdb,
  0x0c, 0x21, 0x6c, 0xcb, 0x83, 0x92, 0x35, 0x0a, 0x7f, 0x76, 0x46, 0x2f,
  0x11, 0xaa, 0xf5, 0x88, 0x00, 0x31, 0x30, 0xee, 0x46, 0x95, 0x39, 0x7d,
  0x62, 0xb7, 0x9c, 0x4f, 0x11, 0x38, 0xa8, 0x86, 0xfe, 0xa1, 0xab, 0xe2,
  0xd4, 0x44, 0xfb, 0x86, 0xe7, 0x07, 0x41, 0xbd, 0x17, 0x59, 0x6d, 0x7e,
  0xe2, 0xee, 0x7a, 0x14, 0x05, 0x74, 0x02, 0x0e, 0xdc, 0x38, 0xf7, 0x62,
  0x6d, 0xad, 0xc8, 0xe1, 0x74, 0xcd, 0x95, 0x00, 0x79, 0x44, 0x7e, 0xf9,
  0xdf, 0xa7, 0x82, 0xa4, 0x59, 0xf3, 0xf0, 0x53, 0xa2, 0x1c, 0x26, 0xcc,
  0x15, 0x83, 0x22, 0x6b, 0x7b, 0x7b, 0x5d, 0x80, 0x5a, 0xc5, 0xf2, 0x16,
  0xa4, 0x79, 0x1d, 0xa0, 0x9e, 0xf7, 0x5a, 0xf7, 0x9e, 0x1f, 0x8a, 0xdc,
  0x9e, 0x2d, 0x0f, 0x37, 0x19, 0x38, 0x13, 0x4e, 0xfb, 0x3b, 0xe6, 0x18,
  0x54, 0x52, 0x2f, 0xe7, 0x0f, 0x9a, 0xbc, 0x20, 0x90, 0x7e, 0x70, 0x69,
  0x4b, 0x79, 0x5e, 0x1d, 0x16, 0x1e, 0x13, 0xe7, 0xef, 0xa0, 0x2e, 0xd9,
  0xf6, 0x09, 0xf0, 0x87, 0x7d, 0x01, 0x32, 0xcd, 0x1b, 0x6c, 0x55, 0xf3,
  0xba, 0xfb, 0xf5, 0x9c, 0xc1, 0xe7, 0x78, 0x95, 0xb8, 0xdc, 0x7c, 0x36,
  0xd2, 0x92, 0xc6, 0xb0, 0xc7, 0xe9, 0xd9, 0xf2, 0x30, 0xae, 0x08, 0x4f,
  0x0b, 0x3b, 0xf5, 0x9a, 0xdb, 0xb1, 0xe1, 0xb6, 0x49, 0x25, 0xa0, 0x46,
  0x09, 0x9c, 0x7b, 0xae, 0xf9, 0xff, 0x58, 0x67, 0x8c, 0x67, 0x3c, 0x89,
  0x5e, 0x22, 0x31, 0x9b, 0xa4, 0xdc, 0x3f, 0x63, 0xa9, 0xa6, 0x40, 0x7d,
  0x6c, 0x35, 0x34, 0xd5, 0xb2, 0xe1, 0xb9, 0x8f, 0x62, 0x4c, 0x89, 0x7b,
  0x70, 0x98, 0x23, 0x96, 0x0f, 0xa1, 0x77, 0x6f, 0xee, 0x2e, 0x34, 0x46,
  0x0b, 0xb4, 0x4d, 0x3d, 0x1a, 0xc6, 0x19, 0x8b, 0x8e, 0xc9, 0xb9, 0x74,
  0x61, 0x66, 0xb2, 0x1e, 0x49, 0xa7, 0x82, 0xf3, 0xb0, 0x83, 0x37, 0xb3,
  0x1f, 0x6e, 0x39, 0x6c, 0x8b, 0xb1, 0xb9, 0xf1, 0xd4, 0x46, 0xf3, 0xcf,
  0x89, 0x14, 0xcc, 0xe0, 0x98, 0xdd, 0xb4, 0x66, 0x7c, 0x70, 0x8f, 0x95,
  0x29, 0xf5, 0xc6, 0x92, 0xdb, 0x28, 0x37, 0x40, 0x35, 0x03, 0x9d, 0xd9,
  0x98, 0xab, 0xa4, 0x6c, 0x55, 0xbd, 0xf1, 0x89, 0xa4, 0xf9, 0x87, 0x6b,
  0x33, 0x48, 0x9c, 0xb8, 0x54, 0x95, 0xff, 0xa7, 0x89, 0xa6, 0x99, 0x02,
  0x56, 0xee, 0x87, 0x0e, 0xa8, 0xb9, 0x53, 0xbb, 0x7d, 0x76, 0x1c, 0x1c,
  0xfc, 0x2e, 0x5a, 0xd7, 0x44, 0x8e, 0xd0, 0x17, 0x49, 0x3b, 0x85, 0x18,
  0x74, 0x7a, 0x2a, 0xe5, 0x03, 0xa9, 0xb0, 0x39, 0x70, 0x2b, 0xfa, 0xf0,
  0x68, 0x55, 0xbe, 0x30, 0x61, 0xc6, 0xaa, 0x8a, 0x96, 0x0b, 0xdb, 0x23,
  0x42, 0xfe, 0x29, 0xca, 0x08, 0xad, 0xf1, 0x03, 0x14, 0x01, 0x53, 0x06,
  0xaf, 0x05, 0x50, 0xe8, 0x21, 0xd4, 0xe7, 0x6a, 0x79, 0x8d, 0x27, 0x27,
  0xa2, 0x93, 0x49, 0x0d, 0x85, 0xc6, 0x13, 0x6a, 0x8a, 0xc1, 0x20, 0xfd,
  0xc3, 0x01, 0x56, 0x99, 0x2f, 0x7e, 0x39, 0xe2, 0x51, 0x36, 0x8e, 0xc9,
  0xd5, 0x01, 0xa6, 0xc0, 0x2b, 0xbb, 0xca, 0xaf, 0x1e, 0xd1, 0x74, 0xc4,
  0x6b, 0x1f, 0x3c, 0x92, 0x84, 0x97, 0xd4, 0x87, 0x6f, 0xad, 0xc7, 0xad,
  0x46, 0xb0, 0x21, 0xac, 0x88, 0x29, 0x21, 0x77, 0xf4, 0x4f, 0x44, 0x1f,
  0x6f, 0xf9, 0x40, 0x37, 0xc6, 0x34, 0x2a, 0x4a, 0x36, 0x9e, 0xc6, 0xa1,
  0x37, 0xb4, 0x89, 0x95, 0xbf, 0xd0, 0x55, 0x44, 0x86, 0xee, 0xaa, 0xc0,
  0x90, 0x5b, 0xbc, 0x10, 0xf6, 0x6c, 0x89, 0xc7, 0x27, 0x0d, 0xe1, 0x01,
  0x3c, 0x10, 0xdc, 0xe6, 0x3f, 0x1d, 0x0f, 0xca, 0x75, 0x43, 0xf9, 0x25,
  0xc2, 0xf8, 0xde, 0x5d, 0xa3, 0xf4, 0x28, 0x19, 0xff, 0x6a, 0x5b, 0x70,
  0xb1, 0x09, 0x2c, 0x36, 0x58, 0xf2, 0xb1, 0x5a, 0xdd, 0x05, 0x25, 0x83,
  0xa9, 0x80, 0x72, 0xa3, 0x90, 0xd1, 0xf1, 0x0b, 0xde, 0x6b, 0x03, 0x98,
  0xdd, 0xaa, 0x74, 0x7c, 0xcc, 0x42, 0xaa, 0x61, 0x55, 0x03, 0x3b, 0xbd,
  0xc0, 0x84, 0x54, 0x79
};
unsigned int coordinates_bin_len = 16384;


int ec_wNAF_precompute_mult_load(EC_GROUP *group, EC_POINT *point_st)
{
#if 1
    // 每个坐标的字节数，假设每个坐标使用 32 字节存储
    const SIZE_T coordinate_size = 32;
    int i;
    EC_PRE_COMP *pre_comp = &group->ec;
    EC_POINT **var, **points = (EC_POINT **)&pre_comp->point;

    var = points;
    for (i = 0; i < 256; i++) {
        var[i] = &point_st[i];
        // 读取 x 坐标
        BN_bin2bn(coordinates_bin + i * 2 * coordinate_size, coordinate_size, &var[i]->X);
        // 读取 y 坐标
        BN_bin2bn(coordinates_bin + i * 2 * coordinate_size + coordinate_size, coordinate_size, &var[i]->Y);

        BN_set_negative(&var[i]->X, 0);
        BN_set_negative(&var[i]->Y, 0);
        BN_copy(&var[i]->Z, BN_value_one());
        BN_set_negative(&var[i]->Z, 0);
        point_st[i].Z_is_one = 1;
    }

    group->ec.blocksize = 8;
    group->ec.numblocks = 32;
    group->ec.w = 4;
    group->ec.points = points;
    points = NULL;
    group->ec.num = 256;
#endif
    return 0;
}

int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx, EC_POINT *point_st)
{
    const EC_POINT *generator;
    EC_POINT tmp_point, base, **var;
    SIZE_T i, bits = 256, w, pre_points_per_block, blocksize, numblocks, num;
    EC_POINT **points = NULL;
    EC_PRE_COMP *pre_comp = &group->ec;
    int ret = 0;

    ec_GFp_simple_point_init(&tmp_point);
    ec_GFp_simple_point_init(&base);

    generator = EC_GROUP_get0_generator(group);
    if (generator == NULL) {
        goto err;
    }

    BN_CTX_start(ctx);

    /*
     * The following parameters mean we precompute (approximately) one point
     * per bit. TBD: The combination 8, 4 is perfect for 160 bits; for other
     * bit lengths, other parameter combinations might provide better
     * efficiency.
     */
    blocksize = 8;
    w = 4;

    numblocks = (bits + blocksize - 1) / blocksize; /* max. number of blocks
                                                     * to use for wNAF
                                                     * splitting */

    pre_points_per_block = (SIZE_T)1 << (w - 1);
    num = pre_points_per_block * numblocks; /* number of points to compute
                                             * and store */

    points = (EC_POINT **)&pre_comp->point;

    var = points;
    for (i = 0; i < num; i++) {
        var[i] = &point_st[i];
        ec_GFp_simple_point_init(var[i]);
    }

    if (!EC_POINT_copy(&base, generator))
        goto err;

    /* do the precomputation */
    for (i = 0; i < numblocks; i++) {
        SIZE_T j;

        if (!ec_GFp_simple_dbl(group, &tmp_point, &base, ctx))
            goto err;

        if (!EC_POINT_copy(*var++, &base))
            goto err;

        for (j = 1; j < pre_points_per_block; j++, var++) {
            /*
             * calculate odd multiples of the current base point
             */
            if (!ec_GFp_simple_add(group, *var, &tmp_point, *(var - 1), ctx))
                goto err;
        }

        if (i < numblocks - 1) {
            /*
             * get the next base (multiply current one by 2^blocksize)
             */
            SIZE_T k;

            if (blocksize <= 2) {
                goto err;
            }

            if (!ec_GFp_simple_dbl(group, &base, &tmp_point, ctx))
                goto err;
            for (k = 2; k < blocksize; k++) {
                if (!ec_GFp_simple_dbl(group, &base, &base, ctx))
                    goto err;
            }
        }
    }
    /*
    EC_POINTs_make_affine(group, num, points, ctx) 函数将椭圆曲线点从齐次坐标（Projective Coordinates）转换为仿射坐标（Affine Coordinates）。
    转换后的仿射坐标会直接存储在传入的 points 数组中，
    即 points 数组中的每个椭圆曲线点在转换之后仍然会保存在原有的内存位置，只是坐标形式已经被转换为仿射坐标。
     */
    if (!ec_GFp_simple_points_make_affine(group, num, points, ctx))
        goto err;

    group->ec.blocksize = blocksize;
    group->ec.numblocks = numblocks;
    group->ec.w = w;
    group->ec.points = points;
    points = NULL;
    group->ec.num = num;
    pre_comp = NULL;
    ret = 1;

 err:
    if (ctx != NULL)
        BN_CTX_end(ctx);
    return ret;
}


///////////////////////////////////////////////////////////////////////////////

/* functions for EC_GROUP objects */

/*
 * ec_precompute_mont_data sets |group->mont_data| from |group->order| and
 * returns one on success. On error it returns zero.
 */
static int ec_precompute_mont_data(EC_GROUP *group, BN_CTX *ctx)
{
    int ret = 0;

    if (!BN_MONT_CTX_set(&group->mont_data, &group->order, ctx)) {
        goto err;
    }
    ret = 1;

 err:
    return ret;
}


int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,
                           const BIGNUM *order, const BIGNUM *cofactor, BN_CTX *ctx)
{
    if (generator == NULL) {
        return 0;
    }

    if (!EC_POINT_copy(&group->generator, generator))
        return 0;

    if (order != NULL) {
        if (!BN_copy(&group->order, order))
            return 0;
    } else
        BN_zero(&group->order);

    if (cofactor != NULL) {
        if (!BN_copy(&group->cofactor, cofactor))
            return 0;
    } else
        BN_zero(&group->cofactor);

    /*
     * Some groups have an order with
     * factors of two, which makes the Montgomery setup fail.
     * |group->mont_data| will be NULL in this case.
     */
    if (BN_is_odd(&group->order)) {
        return ec_precompute_mont_data(group, ctx);
    }

    return 1;
}

const EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group)
{
    return &group->generator;
}

int EC_POINT_copy(EC_POINT *dest, const EC_POINT *src)
{
    if (dest == src)
        return 1;
    return ec_GFp_simple_point_copy(dest, src);
}

int EC_POINT_get_affine_coordinates(const EC_GROUP *group,
                                    const EC_POINT *point, BIGNUM *x, BIGNUM *y,
                                    BN_CTX *ctx)
{
    if (ec_GFp_simple_is_at_infinity(group, point)) {
        return 0;
    }
    return ec_GFp_simple_point_get_affine_coordinates(group, point, x, y, ctx);
}

/*
 * Functions for point multiplication. If group->meth->mul is 0, we use the
 * wNAF-based implementations in ec_mult.c; otherwise we dispatch through
 * methods.
 */

int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                  SIZE_T num, const EC_POINT *points[],
                  const BIGNUM *scalars[], BN_CTX *ctx)
{
    int ret = 0;

    if ((scalar == NULL) && (num == 0)) {
        return ec_GFp_simple_point_set_to_infinity(group, r);
    }

    if (ctx == NULL)
        return 0;

    ret = ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);

    return ret;
}

int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}

///////////////////////////////////////////////////////////////////////////////

static const unsigned char _EC_sm2p256v1[0 + 32 * 6]  = {
    /* no seed */

    /* p */
    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    /* a */
    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
    /* b */
    0x28, 0xe9, 0xfa, 0x9e, 0x9d, 0x9f, 0x5e, 0x34, 0x4d, 0x5a, 0x9e, 0x4b,
    0xcf, 0x65, 0x09, 0xa7, 0xf3, 0x97, 0x89, 0xf5, 0x15, 0xab, 0x8f, 0x92,
    0xdd, 0xbc, 0xbd, 0x41, 0x4d, 0x94, 0x0e, 0x93,
    /* x */
    0x32, 0xc4, 0xae, 0x2c, 0x1f, 0x19, 0x81, 0x19, 0x5f, 0x99, 0x04, 0x46,
    0x6a, 0x39, 0xc9, 0x94, 0x8f, 0xe3, 0x0b, 0xbf, 0xf2, 0x66, 0x0b, 0xe1,
    0x71, 0x5a, 0x45, 0x89, 0x33, 0x4c, 0x74, 0xc7,
    /* y */
    0xbc, 0x37, 0x36, 0xa2, 0xf4, 0xf6, 0x77, 0x9c, 0x59, 0xbd, 0xce, 0xe3,
    0x6b, 0x69, 0x21, 0x53, 0xd0, 0xa9, 0x87, 0x7c, 0xc6, 0x2a, 0x47, 0x40,
    0x02, 0xdf, 0x32, 0xe5, 0x21, 0x39, 0xf0, 0xa0,
    /* order */
    0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x72, 0x03, 0xdf, 0x6b, 0x21, 0xc6, 0x05, 0x2b,
    0x53, 0xbb, 0xf4, 0x09, 0x39, 0xd5, 0x41, 0x23,
};

EC_GROUP *EC_GROUP_init_curve(EC_GROUP *group, BN_CTX *ctx)
{
    EC_POINT P;
    BIGNUM p_st, a_st, b_st, x_st, y_st, order_st;
    BIGNUM *p = (BIGNUM *)&p_st, *a = (BIGNUM *)&a_st, *b = (BIGNUM *)&b_st, *x = (BIGNUM *)&x_st, *y = (BIGNUM *)&y_st, *order = &order_st;
    int ok = 0;
    int param_len = 32;

    const unsigned char *params = _EC_sm2p256v1;

    if ((p = BN_bin2bn(params + 0 * param_len, param_len, p)) == NULL
        || (a = BN_bin2bn(params + 1 * param_len, param_len, a)) == NULL
        || (b = BN_bin2bn(params + 2 * param_len, param_len, b)) == NULL) {
        goto err;
    }

    if (!ec_GFp_mont_group_set_curve(group, p, a, b, ctx))
        goto err;

    ec_GFp_simple_point_init(&P);

    if ((x = BN_bin2bn(params + 3 * param_len, param_len, x)) == NULL
        || (y = BN_bin2bn(params + 4 * param_len, param_len, y)) == NULL) {
        goto err;
    }
    if (!ec_GFp_simple_set_Jprojective_coordinates_GFp(group, &P, x, y, BN_value_one(), ctx)) {
        goto err;
    }
    if ((order = BN_bin2bn(params + 5 * param_len, param_len, order)) == NULL
        || !BN_set_word(x, 1)) {
        goto err;
    }
    if (!EC_GROUP_set_generator(group, &P, order, x, ctx)) {
        goto err;
    }

    ok = 1;
err:
    if (!ok) {
        group = NULL;
    }
    return group;
}

///////////////////////////////////////////////////////////////////////////////

SIZE_T ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
                               unsigned char *buf, SIZE_T len, BN_CTX *ctx)
{
    SIZE_T ret;
    BIGNUM *x, *y;
    SIZE_T field_len, i, skip;

    if (ec_GFp_simple_is_at_infinity(group, point)) {
        /* encodes to a single 0 octet */
        buf[0] = 0;
        return 1;
    }

    /* ret := required output buffer length */
    field_len = BN_num_bytes(&group->field);
    ret = 2 * field_len;  // Uncompressed format without the extra byte for form

    if (len < ret) {
        return 0;  // Buffer is too small
    }

    BN_CTX_start(ctx);
    x = BN_CTX_get(ctx);
    y = BN_CTX_get(ctx);
    if (y == NULL) {
        return 0;  // Error in context allocation
    }

    if (!EC_POINT_get_affine_coordinates(group, point, x, y, ctx)) {
        return 0;  // Error getting point coordinates
    }

    // Write x coordinate to buf
    i = 0;
    skip = field_len - BN_num_bytes(x);
    while (skip > 0) {
        buf[i++] = 0;
        skip--;
    }
    i += BN_bn2bin(x, buf + i);

    // Write y coordinate to buf
    skip = field_len - BN_num_bytes(y);
    while (skip > 0) {
        buf[i++] = 0;
        skip--;
    }
    i += BN_bn2bin(y, buf + i);

    BN_CTX_end(ctx);
    return ret;
}

__kernel void keypair(const __global unsigned int* input, __global unsigned int* pubkey) {
    int gid = get_global_id(0);

    __global const unsigned int* prikey = input + gid * 8;
    __global unsigned int* out = pubkey + gid * 16;

    EC_GROUP group_st, *group = &group_st;
    BN_CTX ctx_st, *ctx = &ctx_st;
    BN_CTX_init(ctx);
    group = EC_GROUP_init_curve(group, ctx);
    BIGNUM priv_bn_st;
    BIGNUM *priv_bn = (BIGNUM *)&priv_bn_st;
    priv_bn = BN_bin2bn((unsigned char *)prikey, 32, priv_bn);
    EC_POINT point_mem[256];
    ec_wNAF_precompute_mult_load(group, point_mem);
    EC_POINT pub_key;
    ec_GFp_simple_point_init(&pub_key);
    BN_CTX_init(ctx);
    EC_POINT_mul(group, &pub_key, priv_bn, NULL, NULL, ctx);
    BN_CTX_init(ctx);
    ec_GFp_simple_point2oct(group, &pub_key, (unsigned char *)out, 64, ctx);
}
